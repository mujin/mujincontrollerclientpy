# -*- coding: utf-8 -*-
#
# DO NOT EDIT, THIS FILE WAS AUTO-GENERATED
# GENERATED BY: mujin_controllerclientpy_generategraphclient.py
# GENERATED AGAINST: mujinwebstack/2.1.5.c82a43cab07937f929109ee808f3b81b15211969
#

from .controllergraphclientutils import ControllerGraphClientBase

class ControllerGraphQueries:

    def GetApplication(self, applicationId, fields=None, timeout=None):
        """Get a specific application.

        Args:
            applicationId (str): ID of an existing application.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Application: A front-end application.
        """
        parameterNameTypeValues = [
            ('applicationId', 'String!', applicationId),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetApplication', parameterNameTypeValues=parameterNameTypeValues, returnType='Application', fields=fields, timeout=timeout)

    def GetAttachedSensor(self, attachedSensorId, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular attached sensor on a robot.

        Args:
            attachedSensorId (str): ID of the existing attached sensor.
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            AttachedSensor: A sensor that is attached to a robot, e.g. a camera or a force sensor.
        """
        parameterNameTypeValues = [
            ('attachedSensorId', 'String!', attachedSensorId),
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetAttachedSensor', parameterNameTypeValues=parameterNameTypeValues, returnType='AttachedSensor', fields=fields, timeout=timeout)

    def GetBody(self, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular body in an environment.

        Args:
            bodyId (str): ID of the existing body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Body: An OpenRAVE body in an environment. Can also describe a robot (a body with multiple links and joints)
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetBody', parameterNameTypeValues=parameterNameTypeValues, returnType='Body', fields=fields, timeout=timeout)

    def GetBodyParameters(self, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a body parameters in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            BodyParameters: Parameters of an OpenRAVE 'Body'
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetBodyParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='BodyParameters', fields=fields, timeout=timeout)

    def GetConfiguration(self, configurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular configuration.

        Args:
            configurationId (str): ID of the configuration, for example "controllersystem.conf".
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Configuration: 
        """
        parameterNameTypeValues = [
            ('configurationId', 'String!', configurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='Configuration', fields=fields, timeout=timeout)

    def GetConfigurationContent(self, configurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular configuration without typing.

        Args:
            configurationId (str): ID of the configuration, for example "controllersystem.conf".
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Any: 
        """
        parameterNameTypeValues = [
            ('configurationId', 'String!', configurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetConfigurationContent', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def GetConnectedBody(self, bodyId, connectedBodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular connected body on a robot.

        Args:
            bodyId (str): ID of the body.
            connectedBodyId (str): ID of the existing connected body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ConnectedBody: A body that is connected to another.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('connectedBodyId', 'String!', connectedBodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetConnectedBody', parameterNameTypeValues=parameterNameTypeValues, returnType='ConnectedBody', fields=fields, timeout=timeout)

    def GetControllerSystemConfiguration(self, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get configurations for controller system.

        Args:
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ControllerSystemConfiguration: 
        """
        parameterNameTypeValues = [
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetControllerSystemConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='ControllerSystemConfiguration', fields=fields, timeout=timeout)

    def GetEnvironment(self, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a specific environment.

        Args:
            environmentId (str): ID of an existing environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Environment: An OpenRAVE Environment
        """
        parameterNameTypeValues = [
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetEnvironment', parameterNameTypeValues=parameterNameTypeValues, returnType='Environment', fields=fields, timeout=timeout)

    def GetGeometry(self, bodyId, environmentId, geometryId, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular geometry in a link.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            geometryId (str): ID of the existing geometry.
            linkId (str): ID of the link.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Geometry: Geometry of a link. A link can have multiple geometries, and a body can have multiple links. All geometries of a link move together.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('geometryId', 'String!', geometryId),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetGeometry', parameterNameTypeValues=parameterNameTypeValues, returnType='Geometry', fields=fields, timeout=timeout)

    def GetGrabbed(self, bodyId, environmentId, grabbedId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular grabbed object in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            grabbedId (str): ID of the existing grabbed object.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Grabbed: An object that is currently grabbed (grasped) by the robot.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('grabbedId', 'String!', grabbedId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetGrabbed', parameterNameTypeValues=parameterNameTypeValues, returnType='Grabbed', fields=fields, timeout=timeout)

    def GetGraspSet(self, bodyId, environmentId, graspSetId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular grasp set in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            graspSetId (str): ID of the existing grasp set.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GraspSet: Represents a set of IKParams at which an object may be grasped.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('graspSetId', 'String!', graspSetId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetGraspSet', parameterNameTypeValues=parameterNameTypeValues, returnType='GraspSet', fields=fields, timeout=timeout)

    def GetGripperInfo(self, bodyId, environmentId, gripperInfoId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular gripper info on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            gripperInfoId (str): ID of the existing gripper info.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GripperInfo: Gripper info describing the gripper properties, used for planning gripper operations.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('gripperInfoId', 'String!', gripperInfoId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetGripperInfo', parameterNameTypeValues=parameterNameTypeValues, returnType='GripperInfo', fields=fields, timeout=timeout)

    def GetHypervisorCapabilities(self, fields=None, timeout=None):
        """Get capabilities supported by hypervisor.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            [String]: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetHypervisorCapabilities', parameterNameTypeValues=parameterNameTypeValues, returnType='String', fields=fields, timeout=timeout)

    def GetHypervisorStatus(self, fields=None, timeout=None):
        """Get status of hypervisor.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            HypervisorStatus: Hypervisor status
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetHypervisorStatus', parameterNameTypeValues=parameterNameTypeValues, returnType='HypervisorStatus', fields=fields, timeout=timeout)

    def GetHypervisorVersion(self, fields=None, timeout=None):
        """Get version of hypervisor.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            str: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetHypervisorVersion', parameterNameTypeValues=parameterNameTypeValues, returnType='String', fields=fields, timeout=timeout)

    def GetIKParameterization(self, bodyId, environmentId, ikParamId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular ikparam in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            ikParamId (str): ID of the existing ikparam.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            IKParameterization: Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('ikParamId', 'String!', ikParamId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetIKParameterization', parameterNameTypeValues=parameterNameTypeValues, returnType='IKParameterization', fields=fields, timeout=timeout)

    def GetJoint(self, bodyId, environmentId, jointId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular joint in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            jointId (str): ID of the existing joint.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Joint: Joint in a body, which connects a parent link and a child link. Can have multiple degrees of freedom.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('jointId', 'String!', jointId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetJoint', parameterNameTypeValues=parameterNameTypeValues, returnType='Joint', fields=fields, timeout=timeout)

    def GetLink(self, bodyId, environmentId, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular link in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            linkId (str): ID of the existing link.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Link: Link of a body, containing geometries. Links can be connected by joints.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetLink', parameterNameTypeValues=parameterNameTypeValues, returnType='Link', fields=fields, timeout=timeout)

    def GetPositionConfiguration(self, bodyId, environmentId, positionConfigurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular position configuration in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            positionConfigurationId (str): ID of the existing position configuration.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            PositionConfiguration: A robot configuration defined via joint values.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('positionConfigurationId', 'String!', positionConfigurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetPositionConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='PositionConfiguration', fields=fields, timeout=timeout)

    def GetProgram(self, programId, fields=None, timeout=None):
        """Get a specific program.

        Args:
            programId (str): ID of an existing program.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Program: ITL program.
        """
        parameterNameTypeValues = [
            ('programId', 'String!', programId),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetProgram', parameterNameTypeValues=parameterNameTypeValues, returnType='Program', fields=fields, timeout=timeout)

    def GetRevision(self, environmentId, revisionId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular revision of an environment.

        Args:
            environmentId (str): ID of the environment.
            revisionId (int): ID of the revision.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Revision: Revision of an environment, contains backward and forward differences.
        """
        parameterNameTypeValues = [
            ('environmentId', 'String!', environmentId),
            ('revisionId', 'Int!', revisionId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetRevision', parameterNameTypeValues=parameterNameTypeValues, returnType='Revision', fields=fields, timeout=timeout)

    def GetRobotBridgesConfiguration(self, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get configurations for robotbridges.

        Args:
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            RobotBridgesConfiguration: 
        """
        parameterNameTypeValues = [
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetRobotBridgesConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='RobotBridgesConfiguration', fields=fields, timeout=timeout)

    def GetRobotMotionParameters(self, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a robot motion parameters in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            RobotMotionParameters: A set of parameters that constrain the motion of a robot, e.g. maximum tool (cartesian) speed and acceleration.
                    Also includes information about the robot model and maker.
                    These parameters are used only during planning - the values in SafetySpeedConstraintsInfo are used to limit speed during execution.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetRobotMotionParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='RobotMotionParameters', fields=fields, timeout=timeout)

    def GetSignalMapConfiguration(self, configurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get signal map.

        Args:
            configurationId (str): ID of the signal map, for example "signalmaps/custom.signalmap".
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            SignalMapConfiguration: 
        """
        parameterNameTypeValues = [
            ('configurationId', 'String!', configurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetSignalMapConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='SignalMapConfiguration', fields=fields, timeout=timeout)

    def GetTool(self, bodyId, environmentId, toolId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Get a particular tool on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            toolId (str): ID of the existing tool.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Tool: Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('toolId', 'String!', toolId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetTool', parameterNameTypeValues=parameterNameTypeValues, returnType='Tool', fields=fields, timeout=timeout)

    def GetUntypedHypervisorStatus(self, fields=None, timeout=None):
        """Get untyped status of hypervisor.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Any: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('query', operationName='GetUntypedHypervisorStatus', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def IsAttachedSensorMoveable(self, attachedSensorName, bodyName, environmentId, fields=None, timeout=None):
        """Check and see if attached sensor is moveable on a robot

        Args:
            attachedSensorName (str): Name of the attached sensor, could be in the format of "connectedBodyName_attachedSensorName"
            bodyName (str): Name of the body to check
            environmentId (str): ID of the environment to check
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            bool: 
        """
        parameterNameTypeValues = [
            ('attachedSensorName', 'String!', attachedSensorName),
            ('bodyName', 'String!', bodyName),
            ('environmentId', 'String!', environmentId),
        ]
        return self._CallSimpleGraphAPI('query', operationName='IsAttachedSensorMoveable', parameterNameTypeValues=parameterNameTypeValues, returnType='Boolean', fields=fields, timeout=timeout)

    def ListApplications(self, options=None, fields=None, timeout=None):
        """List all applications.

        Args:
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListApplicationsReturnValue: 
        """
        parameterNameTypeValues = [
            ('options', 'ListOptionsInput', options),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListApplications', parameterNameTypeValues=parameterNameTypeValues, returnType='ListApplicationsReturnValue', fields=fields, timeout=timeout)

    def ListAttachedSensors(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List attached sensors defined on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListAttachedSensorsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListAttachedSensors', parameterNameTypeValues=parameterNameTypeValues, returnType='ListAttachedSensorsReturnValue', fields=fields, timeout=timeout)

    def ListBodies(self, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List bodies in an environment.

        Args:
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListBodiesReturnValue: 
        """
        parameterNameTypeValues = [
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListBodies', parameterNameTypeValues=parameterNameTypeValues, returnType='ListBodiesReturnValue', fields=fields, timeout=timeout)

    def ListConfigurations(self, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List available configurations.

        Args:
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListConfigurationsReturnValue: 
        """
        parameterNameTypeValues = [
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListConfigurations', parameterNameTypeValues=parameterNameTypeValues, returnType='ListConfigurationsReturnValue', fields=fields, timeout=timeout)

    def ListConnectedBodies(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List connected bodies defined on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListConnectedBodiesReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListConnectedBodies', parameterNameTypeValues=parameterNameTypeValues, returnType='ListConnectedBodiesReturnValue', fields=fields, timeout=timeout)

    def ListEnvironments(self, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List all environments.

        Args:
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListEnvironmentsReturnValue: 
        """
        parameterNameTypeValues = [
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListEnvironments', parameterNameTypeValues=parameterNameTypeValues, returnType='ListEnvironmentsReturnValue', fields=fields, timeout=timeout)

    def ListGeometries(self, bodyId, environmentId, linkId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List geometries in a link.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            linkId (str): ID of the link.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListGeometriesReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('linkId', 'String!', linkId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListGeometries', parameterNameTypeValues=parameterNameTypeValues, returnType='ListGeometriesReturnValue', fields=fields, timeout=timeout)

    def ListGrabbeds(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List grabbed objects in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListGrabbedsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListGrabbeds', parameterNameTypeValues=parameterNameTypeValues, returnType='ListGrabbedsReturnValue', fields=fields, timeout=timeout)

    def ListGraspSets(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List grasp sets in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListGraspSetsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListGraspSets', parameterNameTypeValues=parameterNameTypeValues, returnType='ListGraspSetsReturnValue', fields=fields, timeout=timeout)

    def ListGripperInfos(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List gripper infos defined on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListGripperInfosReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListGripperInfos', parameterNameTypeValues=parameterNameTypeValues, returnType='ListGripperInfosReturnValue', fields=fields, timeout=timeout)

    def ListIKParameterizations(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List ikparams in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListIKParameterizationsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListIKParameterizations', parameterNameTypeValues=parameterNameTypeValues, returnType='ListIKParameterizationsReturnValue', fields=fields, timeout=timeout)

    def ListJoints(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List joints in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListJointsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListJoints', parameterNameTypeValues=parameterNameTypeValues, returnType='ListJointsReturnValue', fields=fields, timeout=timeout)

    def ListLinks(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List links in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListLinksReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListLinks', parameterNameTypeValues=parameterNameTypeValues, returnType='ListLinksReturnValue', fields=fields, timeout=timeout)

    def ListPositionConfigurations(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List position configurations in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListPositionConfigurationsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListPositionConfigurations', parameterNameTypeValues=parameterNameTypeValues, returnType='ListPositionConfigurationsReturnValue', fields=fields, timeout=timeout)

    def ListPrograms(self, options=None, fields=None, timeout=None):
        """List all programs.

        Args:
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListProgramsReturnValue: 
        """
        parameterNameTypeValues = [
            ('options', 'ListOptionsInput', options),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListPrograms', parameterNameTypeValues=parameterNameTypeValues, returnType='ListProgramsReturnValue', fields=fields, timeout=timeout)

    def ListRevisions(self, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List revisions of an environment.

        Args:
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListRevisionsReturnValue: 
        """
        parameterNameTypeValues = [
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListRevisions', parameterNameTypeValues=parameterNameTypeValues, returnType='ListRevisionsReturnValue', fields=fields, timeout=timeout)

    def ListTools(self, bodyId, environmentId, options=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """List tools defined on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            options (ListOptionsInput, optional): Optional list query parameters, used to filter returned results.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ListToolsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('options', 'ListOptionsInput', options),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('query', operationName='ListTools', parameterNameTypeValues=parameterNameTypeValues, returnType='ListToolsReturnValue', fields=fields, timeout=timeout)

    def QueryAvailableUpgrades(self, fields=None, timeout=None):
        """Query available upgrade images for this controller.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            [HypervisorAvailableUpgrade]: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('query', operationName='QueryAvailableUpgrades', parameterNameTypeValues=parameterNameTypeValues, returnType='HypervisorAvailableUpgrade', fields=fields, timeout=timeout)


class ControllerGraphMutations:

    def ActivateRuntimeImage(self, imageId, fields=None, timeout=None):
        """Activate an runtime image.

        Args:
            imageId (str): ID of the runtime image to activate.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('imageId', 'String!', imageId),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ActivateRuntimeImage', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def AddDiskDriveToDiskArray(self, diskArray, diskDrive, fields=None, timeout=None):
        """Add a disk drive to a disk array.

        Args:
            diskArray (str): Array name, e.g. "/dev/md0".
            diskDrive (str): Drive name, e.g. "/dev/sda".
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('diskArray', 'String!', diskArray),
            ('diskDrive', 'String!', diskDrive),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='AddDiskDriveToDiskArray', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def CancelUpgrade(self, fields=None, timeout=None):
        """Cancel ongoing upgrade.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CancelUpgrade', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def CommandPlanningServer(self, command, environmentId, taskType, parameters=None, slaveRequestId=None, fields=None, timeout=None):
        parameterNameTypeValues = [
            ('command', 'String!', command),
            ('environmentId', 'String!', environmentId),
            ('taskType', 'String!', taskType),
            ('parameters', 'Any', parameters),
            ('slaveRequestId', 'String', slaveRequestId),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CommandPlanningServer', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def CommandRobotBridges(self, command, parameters=None, queueId=None, fields=None, timeout=None):
        parameterNameTypeValues = [
            ('command', 'String!', command),
            ('parameters', 'Any', parameters),
            ('queueId', 'String', queueId),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CommandRobotBridges', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def CommandVisionManager(self, command, parameters=None, fields=None, timeout=None):
        parameterNameTypeValues = [
            ('command', 'String!', command),
            ('parameters', 'Any', parameters),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CommandVisionManager', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def ConfigureRobotBridges(self, command, parameters=None, fields=None, timeout=None):
        parameterNameTypeValues = [
            ('command', 'String!', command),
            ('parameters', 'Any', parameters),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ConfigureRobotBridges', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def ConfigureVisionManager(self, command, parameters=None, fields=None, timeout=None):
        parameterNameTypeValues = [
            ('command', 'String!', command),
            ('parameters', 'Any', parameters),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ConfigureVisionManager', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def CopyAttachedSensor(self, attachedSensor, attachedSensorId, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing attached sensor on a robot to a new one.

        Args:
            attachedSensor (AttachedSensorInput): Properties to change on the copied the attached sensor.
            attachedSensorId (str): ID of the existing attached sensor.
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            AttachedSensor: A sensor that is attached to a robot, e.g. a camera or a force sensor.
        """
        parameterNameTypeValues = [
            ('attachedSensor', 'AttachedSensorInput!', attachedSensor),
            ('attachedSensorId', 'String!', attachedSensorId),
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyAttachedSensor', parameterNameTypeValues=parameterNameTypeValues, returnType='AttachedSensor', fields=fields, timeout=timeout)

    def CopyBody(self, body, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing body in an environment to a new one.

        Args:
            body (BodyInput): Properties to be applied on the copied body.
            bodyId (str): ID of the existing body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Body: An OpenRAVE body in an environment. Can also describe a robot (a body with multiple links and joints)
        """
        parameterNameTypeValues = [
            ('body', 'BodyInput!', body),
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyBody', parameterNameTypeValues=parameterNameTypeValues, returnType='Body', fields=fields, timeout=timeout)

    def CopyConnectedBody(self, bodyId, connectedBody, connectedBodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing connected body on a robot to a new one.

        Args:
            bodyId (str): ID of the body.
            connectedBody (ConnectedBodyInput): Properties to change on the copied the connected body.
            connectedBodyId (str): ID of the existing connected body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ConnectedBody: A body that is connected to another.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('connectedBody', 'ConnectedBodyInput!', connectedBody),
            ('connectedBodyId', 'String!', connectedBodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyConnectedBody', parameterNameTypeValues=parameterNameTypeValues, returnType='ConnectedBody', fields=fields, timeout=timeout)

    def CopyEnvironment(self, environment, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing environment to a new one.

        Args:
            environment (EnvironmentInput): Properties to be applied on the copied environment.
            environmentId (str): ID of the existing environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Environment: An OpenRAVE Environment
        """
        parameterNameTypeValues = [
            ('environment', 'EnvironmentInput!', environment),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyEnvironment', parameterNameTypeValues=parameterNameTypeValues, returnType='Environment', fields=fields, timeout=timeout)

    def CopyGeometry(self, bodyId, environmentId, geometry, geometryId, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing geometry in a link to a new one.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            geometry (GeometryInput): Properties to be applied on the copied geometry.
            geometryId (str): ID of the existing geometry.
            linkId (str): ID of the link.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Geometry: Geometry of a link. A link can have multiple geometries, and a body can have multiple links. All geometries of a link move together.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('geometry', 'GeometryInput!', geometry),
            ('geometryId', 'String!', geometryId),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyGeometry', parameterNameTypeValues=parameterNameTypeValues, returnType='Geometry', fields=fields, timeout=timeout)

    def CopyGrabbed(self, bodyId, environmentId, grabbed, grabbedId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing grabbed object in a body to a new one.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            grabbed (GrabbedInput): Properties to be applied on the copied grabbed object.
            grabbedId (str): ID of the existing grabbed object.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Grabbed: An object that is currently grabbed (grasped) by the robot.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('grabbed', 'GrabbedInput!', grabbed),
            ('grabbedId', 'String!', grabbedId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyGrabbed', parameterNameTypeValues=parameterNameTypeValues, returnType='Grabbed', fields=fields, timeout=timeout)

    def CopyGraspSet(self, bodyId, environmentId, graspSet, graspSetId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing grasp set in a body to a new one.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            graspSet (GraspSetInput): Properties to be applied on the copied grasp set.
            graspSetId (str): ID of the existing grasp set.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GraspSet: Represents a set of IKParams at which an object may be grasped.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('graspSet', 'GraspSetInput!', graspSet),
            ('graspSetId', 'String!', graspSetId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyGraspSet', parameterNameTypeValues=parameterNameTypeValues, returnType='GraspSet', fields=fields, timeout=timeout)

    def CopyGripperInfo(self, bodyId, environmentId, gripperInfo, gripperInfoId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing gripper info on a robot to a new one.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            gripperInfo (GripperInfoInput): Properties to change on the copied the gripper info.
            gripperInfoId (str): ID of the existing gripper info.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GripperInfo: Gripper info describing the gripper properties, used for planning gripper operations.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('gripperInfo', 'GripperInfoInput!', gripperInfo),
            ('gripperInfoId', 'String!', gripperInfoId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyGripperInfo', parameterNameTypeValues=parameterNameTypeValues, returnType='GripperInfo', fields=fields, timeout=timeout)

    def CopyIKParameterization(self, bodyId, environmentId, ikParam, ikParamId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing ikparam in a body to a new one.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            ikParam (IKParameterizationInput): Properties to be applied on the copied ikparam.
            ikParamId (str): ID of the existing ikparam.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            IKParameterization: Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('ikParam', 'IKParameterizationInput!', ikParam),
            ('ikParamId', 'String!', ikParamId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyIKParameterization', parameterNameTypeValues=parameterNameTypeValues, returnType='IKParameterization', fields=fields, timeout=timeout)

    def CopyLinkAndJoint(self, bodyId, environmentId, joint, link, linkId, parentLinkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing link and joint in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            joint (JointInput): Properties to be applied on the copied joint.
            link (LinkInput): Properties to be applied on the copied link.
            linkId (str): ID of the existing link.
            parentLinkId (str): ID of the parent link where copied link belongs to.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            CopyLinkAndJointReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('joint', 'JointInput!', joint),
            ('link', 'LinkInput!', link),
            ('linkId', 'String!', linkId),
            ('parentLinkId', 'String!', parentLinkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyLinkAndJoint', parameterNameTypeValues=parameterNameTypeValues, returnType='CopyLinkAndJointReturnValue', fields=fields, timeout=timeout)

    def CopyPositionConfiguration(self, bodyId, environmentId, positionConfiguration, positionConfigurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing position configuration in a body to a new one.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            positionConfiguration (PositionConfigurationInput): Properties to be applied on the copied position configuration.
            positionConfigurationId (str): ID of the existing position configuration.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            PositionConfiguration: A robot configuration defined via joint values.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('positionConfiguration', 'PositionConfigurationInput!', positionConfiguration),
            ('positionConfigurationId', 'String!', positionConfigurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyPositionConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='PositionConfiguration', fields=fields, timeout=timeout)

    def CopyTool(self, bodyId, environmentId, tool, toolId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Copy an existing tool on a robot to a new one.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            tool (ToolInput): Properties to change on the copied the tool.
            toolId (str): ID of the existing tool.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Tool: Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('tool', 'ToolInput!', tool),
            ('toolId', 'String!', toolId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CopyTool', parameterNameTypeValues=parameterNameTypeValues, returnType='Tool', fields=fields, timeout=timeout)

    def CreateAttachedSensor(self, attachedSensor, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new attached sensor on a robot.

        Args:
            attachedSensor (AttachedSensorInput): Properties for the new attached sensor.
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            AttachedSensor: A sensor that is attached to a robot, e.g. a camera or a force sensor.
        """
        parameterNameTypeValues = [
            ('attachedSensor', 'AttachedSensorInput!', attachedSensor),
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateAttachedSensor', parameterNameTypeValues=parameterNameTypeValues, returnType='AttachedSensor', fields=fields, timeout=timeout)

    def CreateBody(self, body, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new body in an environment.

        Args:
            body (BodyInput): Properties to be applied on the newly created body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Body: An OpenRAVE body in an environment. Can also describe a robot (a body with multiple links and joints)
        """
        parameterNameTypeValues = [
            ('body', 'BodyInput!', body),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateBody', parameterNameTypeValues=parameterNameTypeValues, returnType='Body', fields=fields, timeout=timeout)

    def CreateBodyParameters(self, bodyId, bodyParameters, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new body parameters in a body.

        Args:
            bodyId (str): ID of the body.
            bodyParameters (BodyParametersInput): Properties to be applied on the newly created body parameters.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            BodyParameters: Parameters of an OpenRAVE 'Body'
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('bodyParameters', 'BodyParametersInput!', bodyParameters),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateBodyParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='BodyParameters', fields=fields, timeout=timeout)

    def CreateConnectedBody(self, bodyId, connectedBody, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new connected body on a robot.

        Args:
            bodyId (str): ID of the body.
            connectedBody (ConnectedBodyInput): Properties for the new connected body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ConnectedBody: A body that is connected to another.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('connectedBody', 'ConnectedBodyInput!', connectedBody),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateConnectedBody', parameterNameTypeValues=parameterNameTypeValues, returnType='ConnectedBody', fields=fields, timeout=timeout)

    def CreateEnvironment(self, environment, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new environment.

        Args:
            environment (EnvironmentInput): Properties to be applied on the newly created environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Environment: An OpenRAVE Environment
        """
        parameterNameTypeValues = [
            ('environment', 'EnvironmentInput!', environment),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateEnvironment', parameterNameTypeValues=parameterNameTypeValues, returnType='Environment', fields=fields, timeout=timeout)

    def CreateGeometry(self, bodyId, environmentId, geometry, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new geometry in a link.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            geometry (GeometryInput): Properties to be applied on the newly created geometry.
            linkId (str): ID of the existing geometry.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Geometry: Geometry of a link. A link can have multiple geometries, and a body can have multiple links. All geometries of a link move together.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('geometry', 'GeometryInput!', geometry),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateGeometry', parameterNameTypeValues=parameterNameTypeValues, returnType='Geometry', fields=fields, timeout=timeout)

    def CreateGrabbed(self, bodyId, environmentId, grabbed, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new grabbed object in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            grabbed (GrabbedInput): Properties to be applied on the newly created grabbed object.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Grabbed: An object that is currently grabbed (grasped) by the robot.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('grabbed', 'GrabbedInput!', grabbed),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateGrabbed', parameterNameTypeValues=parameterNameTypeValues, returnType='Grabbed', fields=fields, timeout=timeout)

    def CreateGraspSet(self, bodyId, environmentId, graspSet, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new grasp set in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            graspSet (GraspSetInput): Properties to be applied on the newly created grasp set.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GraspSet: Represents a set of IKParams at which an object may be grasped.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('graspSet', 'GraspSetInput!', graspSet),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateGraspSet', parameterNameTypeValues=parameterNameTypeValues, returnType='GraspSet', fields=fields, timeout=timeout)

    def CreateGripperInfo(self, bodyId, environmentId, gripperInfo, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new gripper info on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            gripperInfo (GripperInfoInput): Properties for the new gripper info.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GripperInfo: Gripper info describing the gripper properties, used for planning gripper operations.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('gripperInfo', 'GripperInfoInput!', gripperInfo),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateGripperInfo', parameterNameTypeValues=parameterNameTypeValues, returnType='GripperInfo', fields=fields, timeout=timeout)

    def CreateIKParameterization(self, bodyId, environmentId, ikParam, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new ikparam in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            ikParam (IKParameterizationInput): Properties to be applied on the newly created ikparam.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            IKParameterization: Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('ikParam', 'IKParameterizationInput!', ikParam),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateIKParameterization', parameterNameTypeValues=parameterNameTypeValues, returnType='IKParameterization', fields=fields, timeout=timeout)

    def CreateLinkAndJoint(self, bodyId, environmentId, link, joint=None, parentLinkId=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new link and joint in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            link (LinkInput): Properties to be applied on the newly created link.
            joint (JointInput, optional): Properties to be applied on the newly created joint. When creating base link, no joint will be created.
            parentLinkId (str, optional): ID of the parent link, if any. When creating base link, do not supply parent link ID.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            CreateLinkAndJointReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('link', 'LinkInput!', link),
            ('joint', 'JointInput', joint),
            ('parentLinkId', 'String', parentLinkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateLinkAndJoint', parameterNameTypeValues=parameterNameTypeValues, returnType='CreateLinkAndJointReturnValue', fields=fields, timeout=timeout)

    def CreatePositionConfiguration(self, bodyId, environmentId, positionConfiguration, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new position configuration in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            positionConfiguration (PositionConfigurationInput): Properties to be applied on the newly created position configuration.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            PositionConfiguration: A robot configuration defined via joint values.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('positionConfiguration', 'PositionConfigurationInput!', positionConfiguration),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreatePositionConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='PositionConfiguration', fields=fields, timeout=timeout)

    def CreateRobotMotionParameters(self, bodyId, environmentId, robotMotionParameters, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new robot motion parameters in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            robotMotionParameters (RobotMotionParametersInput): Properties to be applied on the newly created robot motion parameters.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            RobotMotionParameters: A set of parameters that constrain the motion of a robot, e.g. maximum tool (cartesian) speed and acceleration.
                    Also includes information about the robot model and maker.
                    These parameters are used only during planning - the values in SafetySpeedConstraintsInfo are used to limit speed during execution.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('robotMotionParameters', 'RobotMotionParametersInput!', robotMotionParameters),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateRobotMotionParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='RobotMotionParameters', fields=fields, timeout=timeout)

    def CreateTool(self, bodyId, environmentId, tool, resolveReferences=None, units=None, fields=None, timeout=None):
        """Create a new tool on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            tool (ToolInput): Properties for the new tool.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Tool: Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('tool', 'ToolInput!', tool),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='CreateTool', parameterNameTypeValues=parameterNameTypeValues, returnType='Tool', fields=fields, timeout=timeout)

    def DeleteApplication(self, applicationId, fields=None, timeout=None):
        """Delete an application.

        Args:
            applicationId (str): ID of the application to delete.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('applicationId', 'String!', applicationId),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteApplication', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteAttachedSensor(self, attachedSensorId, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a attached sensor from a robot.

        Args:
            attachedSensorId (str): ID of the attached sensor to delete.
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('attachedSensorId', 'String!', attachedSensorId),
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteAttachedSensor', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteBody(self, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a body in an environment.

        Args:
            bodyId (str): ID of the body to delete.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteBody', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteBodyParameters(self, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a body parameters in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteBodyParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteConfiguration(self, configurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete configuration.

        Args:
            configurationId (str): ID of the configuration to delete.
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('configurationId', 'String!', configurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteConnectedBody(self, bodyId, connectedBodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a connected body from a robot.

        Args:
            bodyId (str): ID of the body.
            connectedBodyId (str): ID of the connected body to delete.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('connectedBodyId', 'String!', connectedBodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteConnectedBody', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteEnvironment(self, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete an environment.

        Args:
            environmentId (str): ID of the environment to delete.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteEnvironment', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteGeometry(self, bodyId, environmentId, geometryId, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a geometry in a link.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            geometryId (str): ID of the geometry to delete.
            linkId (str): ID of the link.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('geometryId', 'String!', geometryId),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteGeometry', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteGrabbed(self, bodyId, environmentId, grabbedId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a grabbed object in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            grabbedId (str): ID of the grabbed object to delete.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('grabbedId', 'String!', grabbedId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteGrabbed', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteGraspSet(self, bodyId, environmentId, graspSetId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a grasp set in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            graspSetId (str): ID of the grasp set to delete.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('graspSetId', 'String!', graspSetId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteGraspSet', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteGripperInfo(self, bodyId, environmentId, gripperInfoId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a gripper info from a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            gripperInfoId (str): ID of the gripper info to delete.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('gripperInfoId', 'String!', gripperInfoId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteGripperInfo', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteIKParameterization(self, bodyId, environmentId, ikParamId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a ikparam in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            ikParamId (str): ID of the ikparam to delete.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('ikParamId', 'String!', ikParamId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteIKParameterization', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteLinkAndJoint(self, bodyId, environmentId, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a link and its joint in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            linkId (str): ID of the link to be deleted.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            DeleteLinkAndJointReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteLinkAndJoint', parameterNameTypeValues=parameterNameTypeValues, returnType='DeleteLinkAndJointReturnValue', fields=fields, timeout=timeout)

    def DeletePositionConfiguration(self, bodyId, environmentId, positionConfigurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a position configuration in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            positionConfigurationId (str): ID of the position configuration to delete.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('positionConfigurationId', 'String!', positionConfigurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeletePositionConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteProgram(self, programId, fields=None, timeout=None):
        """Delete an program.

        Args:
            programId (str): ID of the program to delete.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('programId', 'String!', programId),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteProgram', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteRobotMotionParameters(self, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a robot motion parameters in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteRobotMotionParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def DeleteTool(self, bodyId, environmentId, toolId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Delete a tool from a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            toolId (str): ID of the tool to delete.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('toolId', 'String!', toolId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='DeleteTool', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def ExtractBody(self, body, bodyId, environment, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Extract a body from an environment as a new single body environment.

        Args:
            body (BodyInput): Properties to be applied on the newly created body.
            bodyId (str): ID of the body to extract.
            environment (EnvironmentInput): Properties to be applied on the newly created environment.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Environment: An OpenRAVE Environment
        """
        parameterNameTypeValues = [
            ('body', 'BodyInput!', body),
            ('bodyId', 'String!', bodyId),
            ('environment', 'EnvironmentInput!', environment),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ExtractBody', parameterNameTypeValues=parameterNameTypeValues, returnType='Environment', fields=fields, timeout=timeout)

    def ForceSyncNetworkTime(self, fields=None, timeout=None):
        """Force sync network time.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ForceSyncNetworkTime', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def Halt(self, fields=None, timeout=None):
        """Power off controller.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='Halt', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def IdentifyNetworkInterface(self, label=None, fields=None, timeout=None):
        """Blink the LED on the LAN port.

        Args:
            label (str, optional): Interface label, omit to stop blinking.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('label', 'String', label),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='IdentifyNetworkInterface', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def MergeConfigurationContent(self, configurationId, content, resolveReferences=None, units=None, fields=None, timeout=None):
        """Merge changes into a particular configuration without typing.

        Args:
            configurationId (str): ID of the configuration, for example "controllersystem.conf".
            content (Any): Untyped content to merge into the configuration.
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Any: 
        """
        parameterNameTypeValues = [
            ('configurationId', 'String!', configurationId),
            ('content', 'Any!', content),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='MergeConfigurationContent', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def MergeControllerSystemConfiguration(self, controllerSystemConfiguration, resolveReferences=None, units=None, fields=None, timeout=None):
        """Update configuration by merging a partial configuration into it.

        Args:
            controllerSystemConfiguration (ControllerSystemConfigurationInput): Partial configuration to be merged into existing configuration.
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ControllerSystemConfiguration: 
        """
        parameterNameTypeValues = [
            ('controllerSystemConfiguration', 'ControllerSystemConfigurationInput!', controllerSystemConfiguration),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='MergeControllerSystemConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='ControllerSystemConfiguration', fields=fields, timeout=timeout)

    def MergeRobotBridgesConfiguration(self, robotBridgesConfiguration, resolveReferences=None, units=None, fields=None, timeout=None):
        """Update configuration by merging a partial configuration into it.

        Args:
            robotBridgesConfiguration (RobotBridgesConfigurationInput): Partial configuration to be merged into existing configuration.
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            RobotBridgesConfiguration: 
        """
        parameterNameTypeValues = [
            ('robotBridgesConfiguration', 'RobotBridgesConfigurationInput!', robotBridgesConfiguration),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='MergeRobotBridgesConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='RobotBridgesConfiguration', fields=fields, timeout=timeout)

    def MergeSignalMapConfiguration(self, configurationId, signalMapConfiguration, resolveReferences=None, units=None, fields=None, timeout=None):
        """Update configuration by merging a partial configuration into it.

        Args:
            configurationId (str): ID of the signal map, for example "signalmaps/custom.signalmap".
            signalMapConfiguration (SignalMapConfigurationInput): Partial configuration to be merged into existing configuration.
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            SignalMapConfiguration: 
        """
        parameterNameTypeValues = [
            ('configurationId', 'String!', configurationId),
            ('signalMapConfiguration', 'SignalMapConfigurationInput!', signalMapConfiguration),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='MergeSignalMapConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='SignalMapConfiguration', fields=fields, timeout=timeout)

    def ModifyAttachedSensor(self, attachedSensor, attachedSensorId, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing attached sensor on a robot.

        Args:
            attachedSensor (AttachedSensorInput): Proprties to modify on the attached sensor.
            attachedSensorId (str): ID of the attached sensor to modify.
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            AttachedSensor: A sensor that is attached to a robot, e.g. a camera or a force sensor.
        """
        parameterNameTypeValues = [
            ('attachedSensor', 'AttachedSensorInput!', attachedSensor),
            ('attachedSensorId', 'String!', attachedSensorId),
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyAttachedSensor', parameterNameTypeValues=parameterNameTypeValues, returnType='AttachedSensor', fields=fields, timeout=timeout)

    def ModifyBody(self, body, bodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing body in an environment.

        Args:
            body (BodyInput): Properties to be modified on the body.
            bodyId (str): ID of the body to modify.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Body: An OpenRAVE body in an environment. Can also describe a robot (a body with multiple links and joints)
        """
        parameterNameTypeValues = [
            ('body', 'BodyInput!', body),
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyBody', parameterNameTypeValues=parameterNameTypeValues, returnType='Body', fields=fields, timeout=timeout)

    def ModifyBodyParameters(self, bodyId, bodyParameters, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing body parameters in a body.

        Args:
            bodyId (str): ID of the body.
            bodyParameters (BodyParametersInput): Properties to be modified on the body parameters.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            BodyParameters: Parameters of an OpenRAVE 'Body'
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('bodyParameters', 'BodyParametersInput!', bodyParameters),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyBodyParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='BodyParameters', fields=fields, timeout=timeout)

    def ModifyConnectedBody(self, bodyId, connectedBody, connectedBodyId, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing connected body on a robot.

        Args:
            bodyId (str): ID of the body.
            connectedBody (ConnectedBodyInput): Proprties to modify on the connected body.
            connectedBodyId (str): ID of the connected body to modify.
            environmentId (str): ID of the environment.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ConnectedBody: A body that is connected to another.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('connectedBody', 'ConnectedBodyInput!', connectedBody),
            ('connectedBodyId', 'String!', connectedBodyId),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyConnectedBody', parameterNameTypeValues=parameterNameTypeValues, returnType='ConnectedBody', fields=fields, timeout=timeout)

    def ModifyEnvironment(self, environment, environmentId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing environment.

        Args:
            environment (EnvironmentInput): Properties to be modified on the existing environment.
            environmentId (str): ID of the environment to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Environment: An OpenRAVE Environment
        """
        parameterNameTypeValues = [
            ('environment', 'EnvironmentInput!', environment),
            ('environmentId', 'String!', environmentId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyEnvironment', parameterNameTypeValues=parameterNameTypeValues, returnType='Environment', fields=fields, timeout=timeout)

    def ModifyGeometry(self, bodyId, environmentId, geometry, geometryId, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing geometry in a link.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            geometry (GeometryInput): Properties to be modified on the geometry.
            geometryId (str): ID of the geometry to modify.
            linkId (str): ID of the link.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Geometry: Geometry of a link. A link can have multiple geometries, and a body can have multiple links. All geometries of a link move together.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('geometry', 'GeometryInput!', geometry),
            ('geometryId', 'String!', geometryId),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyGeometry', parameterNameTypeValues=parameterNameTypeValues, returnType='Geometry', fields=fields, timeout=timeout)

    def ModifyGrabbed(self, bodyId, environmentId, grabbed, grabbedId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing grabbed object in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            grabbed (GrabbedInput): Properties to be modified on the grabbed object.
            grabbedId (str): ID of the grabbed object to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Grabbed: An object that is currently grabbed (grasped) by the robot.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('grabbed', 'GrabbedInput!', grabbed),
            ('grabbedId', 'String!', grabbedId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyGrabbed', parameterNameTypeValues=parameterNameTypeValues, returnType='Grabbed', fields=fields, timeout=timeout)

    def ModifyGraspSet(self, bodyId, environmentId, graspSet, graspSetId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing grasp set in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            graspSet (GraspSetInput): Properties to be modified on the grasp set.
            graspSetId (str): ID of the grasp set to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GraspSet: Represents a set of IKParams at which an object may be grasped.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('graspSet', 'GraspSetInput!', graspSet),
            ('graspSetId', 'String!', graspSetId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyGraspSet', parameterNameTypeValues=parameterNameTypeValues, returnType='GraspSet', fields=fields, timeout=timeout)

    def ModifyGripperInfo(self, bodyId, environmentId, gripperInfo, gripperInfoId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing gripper info on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            gripperInfo (GripperInfoInput): Proprties to modify on the gripper info.
            gripperInfoId (str): ID of the gripper info to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            GripperInfo: Gripper info describing the gripper properties, used for planning gripper operations.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('gripperInfo', 'GripperInfoInput!', gripperInfo),
            ('gripperInfoId', 'String!', gripperInfoId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyGripperInfo', parameterNameTypeValues=parameterNameTypeValues, returnType='GripperInfo', fields=fields, timeout=timeout)

    def ModifyIKParameterization(self, bodyId, environmentId, ikParam, ikParamId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing ikparam in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            ikParam (IKParameterizationInput): Properties to be modified on the ikparam.
            ikParamId (str): ID of the ikparam to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            IKParameterization: Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('ikParam', 'IKParameterizationInput!', ikParam),
            ('ikParamId', 'String!', ikParamId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyIKParameterization', parameterNameTypeValues=parameterNameTypeValues, returnType='IKParameterization', fields=fields, timeout=timeout)

    def ModifyJoint(self, bodyId, environmentId, joint, jointId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing joint in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            joint (JointInput): Properties to be modified on the joint.
            jointId (str): ID of the joint to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Joint: Joint in a body, which connects a parent link and a child link. Can have multiple degrees of freedom.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('joint', 'JointInput!', joint),
            ('jointId', 'String!', jointId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyJoint', parameterNameTypeValues=parameterNameTypeValues, returnType='Joint', fields=fields, timeout=timeout)

    def ModifyLink(self, bodyId, environmentId, link, linkId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing link in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            link (LinkInput): Properties to be modified on the link.
            linkId (str): ID of the link to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Link: Link of a body, containing geometries. Links can be connected by joints.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('link', 'LinkInput!', link),
            ('linkId', 'String!', linkId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyLink', parameterNameTypeValues=parameterNameTypeValues, returnType='Link', fields=fields, timeout=timeout)

    def ModifyPositionConfiguration(self, bodyId, environmentId, positionConfiguration, positionConfigurationId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing position configuration in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            positionConfiguration (PositionConfigurationInput): Properties to be modified on the position configuration.
            positionConfigurationId (str): ID of the position configuration to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            PositionConfiguration: A robot configuration defined via joint values.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('positionConfiguration', 'PositionConfigurationInput!', positionConfiguration),
            ('positionConfigurationId', 'String!', positionConfigurationId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyPositionConfiguration', parameterNameTypeValues=parameterNameTypeValues, returnType='PositionConfiguration', fields=fields, timeout=timeout)

    def ModifyReferenceObjectPKs(self, bodyId, environmentId, addDisabledReferenceObjectPks=None, addReferenceObjectPks=None, removeDisabledReferenceObjectPks=None, removeReferenceObjectPks=None, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify reference object pks in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            addDisabledReferenceObjectPks ([String], optional): A list of reference object pks to add to the disable list.
            addReferenceObjectPks ([String], optional): A list of reference object pks to add.
            removeDisabledReferenceObjectPks ([String], optional): A list of reference object pks to remove from the disable list.
            removeReferenceObjectPks ([String], optional): A list of reference object pks to remove.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            ModifyReferenceObjectPKsReturnValue: 
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('addDisabledReferenceObjectPks', '[String!]', addDisabledReferenceObjectPks),
            ('addReferenceObjectPks', '[String!]', addReferenceObjectPks),
            ('removeDisabledReferenceObjectPks', '[String!]', removeDisabledReferenceObjectPks),
            ('removeReferenceObjectPks', '[String!]', removeReferenceObjectPks),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyReferenceObjectPKs', parameterNameTypeValues=parameterNameTypeValues, returnType='ModifyReferenceObjectPKsReturnValue', fields=fields, timeout=timeout)

    def ModifyRobotMotionParameters(self, bodyId, environmentId, robotMotionParameters, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing robot motion parameters in a body.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            robotMotionParameters (RobotMotionParametersInput): Properties to be modified on the robot motion parameters.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            RobotMotionParameters: A set of parameters that constrain the motion of a robot, e.g. maximum tool (cartesian) speed and acceleration.
                    Also includes information about the robot model and maker.
                    These parameters are used only during planning - the values in SafetySpeedConstraintsInfo are used to limit speed during execution.
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('robotMotionParameters', 'RobotMotionParametersInput!', robotMotionParameters),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyRobotMotionParameters', parameterNameTypeValues=parameterNameTypeValues, returnType='RobotMotionParameters', fields=fields, timeout=timeout)

    def ModifyTool(self, bodyId, environmentId, tool, toolId, resolveReferences=None, units=None, fields=None, timeout=None):
        """Modify an existing tool on a robot.

        Args:
            bodyId (str): ID of the body.
            environmentId (str): ID of the environment.
            tool (ToolInput): Proprties to modify on the tool.
            toolId (str): ID of the tool to modify.
            resolveReferences (bool, optional): Whether to operate on resolved bodies in the environment. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Tool: Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
        """
        parameterNameTypeValues = [
            ('bodyId', 'String!', bodyId),
            ('environmentId', 'String!', environmentId),
            ('tool', 'ToolInput!', tool),
            ('toolId', 'String!', toolId),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ModifyTool', parameterNameTypeValues=parameterNameTypeValues, returnType='Tool', fields=fields, timeout=timeout)

    def PurgeUnusedRuntimeImages(self, fields=None, timeout=None):
        """Purge unused runtime images

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='PurgeUnusedRuntimeImages', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def Reboot(self, fields=None, timeout=None):
        """Reboot controller.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='Reboot', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def RemoveDiskDriveFromDiskArray(self, diskArray, diskDrive, fields=None, timeout=None):
        """Remove a disk drive from a disk array.

        Args:
            diskArray (str): Array name, e.g. "/dev/md0".
            diskDrive (str): Drive name, e.g. "/dev/sda".
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('diskArray', 'String!', diskArray),
            ('diskDrive', 'String!', diskDrive),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='RemoveDiskDriveFromDiskArray', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def RemoveRuntimeImage(self, imageId, fields=None, timeout=None):
        """Remove an runtime image, if it is not in use.

        Args:
            imageId (str): ID of the runtime image to remove.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('imageId', 'String!', imageId),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='RemoveRuntimeImage', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def RestartRuntimeContainer(self, fields=None, timeout=None):
        """Restart current runtime container.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='RestartRuntimeContainer', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def ScanWirelessNetwork(self, fields=None, timeout=None):
        """Trigger scanning of wireless network. The scanned result will appear in hypervisor status.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ScanWirelessNetwork', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def ScavengeProgramObjects(self, fields=None, timeout=None):
        """Scavenge orphaned objects no longer used by any program to free up space.

        Args:
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='ScavengeProgramObjects', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)

    def SetConfigurationContent(self, configurationId, content, resolveReferences=None, units=None, fields=None, timeout=None):
        """Set a particular configuration without typing.

        Args:
            configurationId (str): ID of the configuration, for example "controllersystem.conf".
            content (Any): Untyped content to replace the configuration with.
            resolveReferences (bool, optional): Whether to operate on resolved configurations. Defaults to operate and return unresolved data.
            units (UnitSelectionInput, optional): Optional unit selection.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Any: 
        """
        parameterNameTypeValues = [
            ('configurationId', 'String!', configurationId),
            ('content', 'Any!', content),
            ('resolveReferences', 'Boolean', resolveReferences),
            ('units', 'UnitSelectionInput', units),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='SetConfigurationContent', parameterNameTypeValues=parameterNameTypeValues, returnType='Any', fields=fields, timeout=timeout)

    def Upgrade(self, autoRestartRuntimeContainer=None, purgeUnusedRuntimeImages=None, url=None, fields=None, timeout=None):
        """Upgrade controller with upgrade image.

        Args:
            autoRestartRuntimeContainer (bool, optional): Whether to auto restart runtime container after upgrade.
            purgeUnusedRuntimeImages (bool, optional): Whether to purge unused runtime images to make room for upgrade.
            url (str, optional): URL to download upgrade image from.
            fields (list or dict, optional): Specifies a subset of fields to return.
            timeout (float, optional): Number of seconds to wait for response.

        Returns:
            Void: 
        """
        parameterNameTypeValues = [
            ('autoRestartRuntimeContainer', 'Boolean', autoRestartRuntimeContainer),
            ('purgeUnusedRuntimeImages', 'Boolean', purgeUnusedRuntimeImages),
            ('url', 'String', url),
        ]
        return self._CallSimpleGraphAPI('mutation', operationName='Upgrade', parameterNameTypeValues=parameterNameTypeValues, returnType='Void', fields=fields, timeout=timeout)


class ControllerGraphClient(ControllerGraphClientBase, ControllerGraphQueries, ControllerGraphMutations):

    typeDatabase = {

        # A front-end application.
        'Application': {
            # Base route component string, or slug.
            'baseRoute': 'String', # String
            # Timestamp when the application was created.
            'createdAt': 'DateTime', # DateTime
            # Entry point of the application, usually "index.html".
            'entry': 'String', # String
            # Filename of the icon.
            'icon': 'String', # String
            # The unique ID of the application.
            'id': 'String', # String!
            # Timestamp when the application was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # Name.
            'name': 'String', # String
            # For internal applications, the filename on disk is used to check if re-import is needed.
            'referenceFilename': 'String', # String
            # List of resources belonging to this application.
            'resources': 'ApplicationResource', # [ApplicationResource!]
            # Version string.
            'version': 'String', # String
        },

        # A resource belonging to a front-end application.
        'ApplicationResource': {
            # Content type of the resource.
            'contentType': 'String', # String
            # Timestamp when the resource was created.
            'createdAt': 'DateTime', # DateTime
            # The unique ID of the resource, usually a filename, such as "static/favicon.ico".
            'id': 'String', # String!
            # Timestamp when the resource was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Size of the resource in bytes
            'size': 'Int', # Int
        },

        # A sensor that is attached to a robot, e.g. a camera or a force sensor.
        'AttachedSensor': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The ID of the attached sensor. Unique within a body.
            'id': 'String', # String!
            # The link to which the sensor is attached.
            'linkName': 'String', # String
            # The name of the attached sensor. Unique within a body.
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            'referenceAttachedSensorName': 'String', # String
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Sensor geometry, including camera intrinsics and more.
            'sensorGeometry': 'SensorGeometry', # SensorGeometry
            'sensorMaker': 'String', # String
            'sensorModel': 'String', # String
            # The transform from the link's frame to the sensor.
            'transform': 'Float', # [Float!]
            'type': 'String', # String
        },

        # A sensor that is attached to a robot, e.g. a camera or a force sensor.
        'AttachedSensorInput': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The ID of the attached sensor. Unique within a body.
            'id': 'String', # String
            # The link to which the sensor is attached.
            'linkName': 'String', # String
            # The name of the attached sensor. Unique within a body.
            'name': 'String', # String
            'referenceAttachedSensorName': 'String', # String
            # Sensor geometry, including camera intrinsics and more.
            'sensorGeometry': 'SensorGeometryInput', # SensorGeometryInput
            'sensorMaker': 'String', # String
            'sensorModel': 'String', # String
            # The transform from the link's frame to the sensor.
            'transform': 'Float', # [Float!]
            'type': 'String', # String
        },

        # The attributes of an object
        'Attributes': {
            # Half the size of the axis-aligned bounding box, in each dimension. For a crate of size 1 m x 1 m x 2 m, this vector would be [0.5, 0.5, 1.0]
            'aabbHalfExtents': 'Float', # [Float!]
            'barcodeScanningGain': 'Float', # Float
            'barcodes': 'String', # [String!]
            'disabledReferenceObjectPKs': 'String', # [String!]
            'graspModelInfo': 'GraspModelInfo', # GraspModelInfo
            # Scores how a gripper's suction cups are performing.
            'gripperSuctionCupsPerformances': 'GripperSuctionCupsPerformance', # [GripperSuctionCupsPerformance!]
            # The mass in kg
            'mass': 'Float', # Float
            'materialType': 'String', # String
            'modelName': 'String', # String
            # parameters related to robot library objects
            'objectCategory': 'String', # String
            'objectDescription': 'Any', # Any
            'objectPackingId': 'String', # String
            'objectType': 'String', # String
            'referenceObjectPKs': 'String', # [String!]
            'transferSpeedMult': 'Float', # Float
            'vendorName': 'String', # String
        },

        # Parameters controlling same item automatic packing computation.
        'AutoPackFormationComputationParameters': {
            # Set to true to check packing2Dpatterns when computing same item pack formation. Packing patterns stored in /data/config/packing2dpatterns
            'allowBestPackingPattern': 'Boolean', # Boolean
            # mm (x,y,z), the maximum allowed size deviation of item size to allow using same packFormation as already computed.
            'maxPackItemSizeDeviation': 'Float', # [Float]
            # Set to true to skip MUJIN best effort same item packing and use only packing patterns stored in /data/config/packing2dpatterns
            'skipBestEffortSingleSKUPack': 'Boolean', # Boolean
            # Describes which target properties should be used for 2D pack formation caching. WARNING: if target hash matche, the pack formation will be used blindly and can cause not executable packs.
            'templateTargetHashProperties': 'TemplateTargetHashPropertiesSchema', # TemplateTargetHashPropertiesSchema
            # Set to true to enable automatic pack formation computation for same items.
            'use': 'Boolean', # Boolean
        },

        # Parameters controlling same item automatic packing computation.
        'AutoPackFormationComputationParametersInput': {
            # Set to true to check packing2Dpatterns when computing same item pack formation. Packing patterns stored in /data/config/packing2dpatterns
            'allowBestPackingPattern': 'Boolean', # Boolean
            # mm (x,y,z), the maximum allowed size deviation of item size to allow using same packFormation as already computed.
            'maxPackItemSizeDeviation': 'Float', # [Float]
            # Set to true to skip MUJIN best effort same item packing and use only packing patterns stored in /data/config/packing2dpatterns
            'skipBestEffortSingleSKUPack': 'Boolean', # Boolean
            # Describes which target properties should be used for 2D pack formation caching. WARNING: if target hash matche, the pack formation will be used blindly and can cause not executable packs.
            'templateTargetHashProperties': 'TemplateTargetHashPropertiesSchemaInput', # TemplateTargetHashPropertiesSchemaInput
            # Set to true to enable automatic pack formation computation for same items.
            'use': 'Boolean', # Boolean
        },

        # Describes the barcode scanners and how the robot computes the barcode scanning motion.
        'BarcodeScanningInfo': {
            # deg, The angle in degrees that the barcode has to make with respect to the scanner direction. Use this to avoid the scanner light shining too brightly on the surface.
            'barCodeScannerAngleOfIncidence': 'Float', # Float
            # The template string of regular expression to check scanned barcodes. If this string contains '%%(partType)s',  '%%(partLot)', '%%(expectedBarcode)s', they will be replaced with given information (i.e. orderExpectedBarcode sent from PLC) before being sent to a barcode reader device bridge.
            'barcodeCheckPatternBase': 'String', # String
            # The name of the IO signal to set regular expression for pattern matching.
            'barcodeCheckPatternIOName': 'String', # String
            # mm, extent barcode unpickable region this amount from the centroid
            'barcodeExtendRegion': 'Float', # Float
            # If True, then checks occlusion with the source cameras at barcode scanning poses.
            'checkCameraOcclusionAtScanBarcodes': 'Boolean', # Boolean
            # The default scanning pattern to use for all barcodes. The types are.
            # - **simplePassthrough** - just do one pass (fast)
            # - **rotatePassthrough** - rotate the barcode in front of scanner (slow)
            'defaultScanningPattern': 'String', # String
            # Force all barcodes to use this scanning pattern, regardless of what individual target's scanningPattern fields are. This should be only used for testing!
            'forceScanningPattern': 'String', # String
            # If robot had barcode scan failure this amount of times in a row, then stop cycle.
            'maxNumConsecutiveBarcodeScanFailures': 'Int', # Int
            # The number of barcode rotations to plan for with respect to the scanner. The higher the number, the more ways the barcode can get scanned, but planning becomes slower.
            'numBarCodeRotations': 'Int', # Int
            # sec, The max amount of time it takes to change the number of barcodes the scanner expects. The system will be dynamically setting the number of barcodes depending on the face it is scanning and before scanning happens (controlled through 'scannerSignalOutputDelay'), will be sending the barcode change signal. Value should not be too high since it can interfere with the next scan.
            'scannerBarCodeChangeMaxDuration': 'Float', # Float
            # Define all the barcode scanner cameras that can be used to scan.
            'scannerCameras': 'ScannerCameraInfo', # [ScannerCameraInfo]
            # The max speed the barcode can passthrough the scanner and still be detected.
            'scannerPassthroughSpeed': 'Float', # Float
            # sec, How much to delay the IO signal of the scanner from the ideal time that the system thinks the barcode will be in the center of the scanner. Communication and robot motion delays can cause slight differences in timing, which this parameter can account for.
            'scannerSignalOutputDelay': 'Float', # Float
            # sec, The amount of time to keep the barcode scanner signal to 1
            'scannerSignalOutputDuration': 'Float', # Float
            # Set to true to make the robot stop on barcode reading error.
            'stopOnBarcodeError': 'Boolean', # Boolean
            # sec, The amount of time to guarantee hold the signal to zero, this is to ensure scanner stops scanning
            'timeBufferForStopping': 'Float', # Float
            # Set to true to enable barcode scanning.
            'use': 'Boolean', # Boolean
            # Set to true to enable barcode pattern matching
            'useCheckBarCodeMatchPattern': 'Boolean', # Boolean
            # sec, The amount of time for the robot to stop in front of the scanner before moving on.
            'waitAtScanTime': 'Float', # Float
        },

        # Describes the barcode scanners and how the robot computes the barcode scanning motion.
        'BarcodeScanningInfoInput': {
            # deg, The angle in degrees that the barcode has to make with respect to the scanner direction. Use this to avoid the scanner light shining too brightly on the surface.
            'barCodeScannerAngleOfIncidence': 'Float', # Float
            # The template string of regular expression to check scanned barcodes. If this string contains '%%(partType)s',  '%%(partLot)', '%%(expectedBarcode)s', they will be replaced with given information (i.e. orderExpectedBarcode sent from PLC) before being sent to a barcode reader device bridge.
            'barcodeCheckPatternBase': 'String', # String
            # The name of the IO signal to set regular expression for pattern matching.
            'barcodeCheckPatternIOName': 'String', # String
            # mm, extent barcode unpickable region this amount from the centroid
            'barcodeExtendRegion': 'Float', # Float
            # If True, then checks occlusion with the source cameras at barcode scanning poses.
            'checkCameraOcclusionAtScanBarcodes': 'Boolean', # Boolean
            # The default scanning pattern to use for all barcodes. The types are.
            # - **simplePassthrough** - just do one pass (fast)
            # - **rotatePassthrough** - rotate the barcode in front of scanner (slow)
            'defaultScanningPattern': 'String', # String
            # Force all barcodes to use this scanning pattern, regardless of what individual target's scanningPattern fields are. This should be only used for testing!
            'forceScanningPattern': 'String', # String
            # If robot had barcode scan failure this amount of times in a row, then stop cycle.
            'maxNumConsecutiveBarcodeScanFailures': 'Int', # Int
            # The number of barcode rotations to plan for with respect to the scanner. The higher the number, the more ways the barcode can get scanned, but planning becomes slower.
            'numBarCodeRotations': 'Int', # Int
            # sec, The max amount of time it takes to change the number of barcodes the scanner expects. The system will be dynamically setting the number of barcodes depending on the face it is scanning and before scanning happens (controlled through 'scannerSignalOutputDelay'), will be sending the barcode change signal. Value should not be too high since it can interfere with the next scan.
            'scannerBarCodeChangeMaxDuration': 'Float', # Float
            # Define all the barcode scanner cameras that can be used to scan.
            'scannerCameras': 'ScannerCameraInfoInput', # [ScannerCameraInfoInput]
            # The max speed the barcode can passthrough the scanner and still be detected.
            'scannerPassthroughSpeed': 'Float', # Float
            # sec, How much to delay the IO signal of the scanner from the ideal time that the system thinks the barcode will be in the center of the scanner. Communication and robot motion delays can cause slight differences in timing, which this parameter can account for.
            'scannerSignalOutputDelay': 'Float', # Float
            # sec, The amount of time to keep the barcode scanner signal to 1
            'scannerSignalOutputDuration': 'Float', # Float
            # Set to true to make the robot stop on barcode reading error.
            'stopOnBarcodeError': 'Boolean', # Boolean
            # sec, The amount of time to guarantee hold the signal to zero, this is to ensure scanner stops scanning
            'timeBufferForStopping': 'Float', # Float
            # Set to true to enable barcode scanning.
            'use': 'Boolean', # Boolean
            # Set to true to enable barcode pattern matching
            'useCheckBarCodeMatchPattern': 'Boolean', # Boolean
            # sec, The amount of time for the robot to stop in front of the scanner before moving on.
            'waitAtScanTime': 'Float', # Float
        },

        'BinpickingDest': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Names of bodies which represent the collision obstacle for this destination. Should be disabled for collision checking when planning for this dest, and enabled when planning for other dest.
            'externalCollisionNames': 'String', # [String]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Name of the destination ik parameter robot will go to. should be in the format instobjectname/ikparamname
            'ikparamName': 'String', # String
            # If true, This destination is used as dropping in the source container, so should not be counted as a placed target
            'isDropInSource': 'Boolean', # Boolean
            # If true, This destination is used as drop off, so should not be counted as a placed target
            'isDropOff': 'Boolean', # Boolean
            # mm or degrees. Need to specify values for all joints.
            'jointvalues': 'Float', # [Float]
            'name': 'String', # String
            # Uri of the target which can be placed in this position
            'validContainerUri': 'String', # String
            'validGraspSetName': 'String', # String
            # Uri of the target which can be placed in this position
            'validTargetUri': 'String', # String
        },

        # Destination goal dictionary. If 'jointvalues' is specified ikparamnames will be ignored
        'BinpickingDestGoal': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Destinations
            'dests': 'BinpickingDest', # [BinpickingDest]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
        },

        # Destination goal dictionary. If 'jointvalues' is specified ikparamnames will be ignored
        'BinpickingDestGoalInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Destinations
            'dests': 'BinpickingDestInput', # [BinpickingDestInput]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
        },

        'BinpickingDestInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Names of bodies which represent the collision obstacle for this destination. Should be disabled for collision checking when planning for this dest, and enabled when planning for other dest.
            'externalCollisionNames': 'String', # [String]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Name of the destination ik parameter robot will go to. should be in the format instobjectname/ikparamname
            'ikparamName': 'String', # String
            # If true, This destination is used as dropping in the source container, so should not be counted as a placed target
            'isDropInSource': 'Boolean', # Boolean
            # If true, This destination is used as drop off, so should not be counted as a placed target
            'isDropOff': 'Boolean', # Boolean
            # mm or degrees. Need to specify values for all joints.
            'jointvalues': 'Float', # [Float]
            'name': 'String', # String
            # Uri of the target which can be placed in this position
            'validContainerUri': 'String', # String
            'validGraspSetName': 'String', # String
            # Uri of the target which can be placed in this position
            'validTargetUri': 'String', # String
        },

        # Different parameters to configure binpicking pick and place cycle.
        'BinpickingParameters': {
            # If true plans out of camera occlusion when a pick failed or robot had to stop and retry a pick (i.e. piece lost).
            'alwaysPlanOutOfOcclusion': 'Int', # Int
            # Absolute current thresholds that should not exceed by joints
            'approachCurrentExceedThresholds': 'Float', # [Float]
            # Check if any of the currents exceed the difference between the start current values (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Do the check after torqueCheckStartTime.
            'approachCurrentExceedThresholdsDelta': 'Float', # [Float]
            # Absolute force and torque thresholds that should not exceed. Unit is N for force, Nm for torque. A negative value means the component is disabled.
            'approachForceTorqueExceedThresholds': 'Float', # [Float]
            # Check if any of the force and torque exceed the difference between the values at start (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Unit is N for force, Nm for torque. A negative value means the component is disabled. Do the check after torqueCheckStartTime.
            'approachForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm, When the tool is close to container walls at a grasp position, how much to offset the approach away from the walls.
            'approachOffsetFromWalls': 'Float', # Float
            # mm. The distance between the approach point P1 where the linear (slow) approach motion starts and the grasp point P2 where the robot stops and the gripper opens/closes to grasp the target item. 
            # 
            # It is appropriate to set the value at least as deep as the gripper's usual grasp depth (how far it moves into or towards the item to grasp it).
            # 
            # Setting a low value can cause A) collisions with noisy detections in the bin, and/or B) slower planning, as the final motions towards the grasp pose can be very constrained and sampling in joint space is inefficient. By default, the motion to the approach point P1 is sampled in joint space.
            # 
            # Common values are 30-100 mm. Setting a value that is too high can cause pick candidates to be discarded, as the approach motion may collide with e.g. container walls or be out of the robot's reach.
            'approachoffset': 'Float', # Float
            # axis-aligned bounding box (AABB) will be created based on specified bodies. collision of AABB is checked only during start plan. AABB aligns to world frame. AABB is created not to collide with AABB of manipulator's geometry but its clearance against manipulator is controlled to be close in order to avoid collision against dynamic contents
            'atStartPlanDynamicContentsNames': 'String', # [String]
            # If true, will clamp the position of the tool to a range between the start and goal of the transfer plan, this will force the tool not to go too up or down when doing the transfer. Use 'toolPosConstraintPaddingXYZ' to pad the XYZ of each dimension for the tool.
            'automaticToolPosConstraintWhenGrabbing': 'Boolean', # Boolean
            # Describes the barcode scanners and how the robot computes the barcode scanning motion.
            'barcodeScanningInfo': 'BarcodeScanningInfo', # BarcodeScanningInfo
            # If True, then when doing occlusion checking, use the correct grabbed object to do occlusion checking. If object is small and completely covered by gripper, this can be set to False to get performance boost.
            'cameraOcclusionApplyGrabbedState': 'Boolean', # Boolean
            # mm, offset is used in detection of camera occlusion by the robot
            'cameraOcclusionOffset': 'Float', # Float
            # s, time offset to expand camera start and end camera capture times for occlusion detection.
            'cameraOcclusionPaddingTime': 'Float', # Float
            # s, time offset to expand camera end of camera capture times for occlusion detection. This is useful when uncertainty of occluding time has asymmetry on start and end. This has priority over cameraOcclusionPaddingTime
            'cameraOcclusionPaddingTimeEnd': 'Float', # Float
            # s, time offset to expand camera start of camera capture times for occlusion detection. This is useful when uncertainty of occluding time has asymmetry on start and end. This has priority over cameraOcclusionPaddingTime
            'cameraOcclusionPaddingTimeStart': 'Float', # Float
            # If True, then when doing occlusion checking, consider all the visible but disabled links in the check. This can be cables and other movable objects. If invisible objects do not affect occlusion status, set this to False to get performance boost.
            'cameraOcclusionUseLinkVisibility': 'Boolean', # Boolean
            # A list of planning infos for cameras that are attached to the robot.
            'cameraPlanningInfos': 'CameraPlanningInfo', # [CameraPlanningInfo]
            # If True, then allow robot to place back the part in the source when barcode scanning fails.
            'canPlaceInSourceOnBarcodeScanFail': 'Boolean', # Boolean
            # If True, then allow robot to place back the part in the source when robot has to recover.
            'canPlaceInSourceOnRecover': 'Boolean', # Boolean
            # If set to True, then allows planning to set isPickable flags to False to any targets it picks up and knows that it should not pick up again unless they get updated. If False, does not allow changing the isPickable flag. Set to True by default.
            'canSetIsPickable': 'Boolean', # Boolean
            # If True, then checks occlusion with the source cameras at mid dest.
            'checkCameraOcclusionAtMidDest': 'Boolean', # Boolean
            # mm, distance threshold (in mm) for the max distance of "end effector translation"-"tool translation" along the vector oriented toward the container opening (usually +z).
            'checkForEndEffectorLowerThanGraspDist': 'Float', # Float
            # If True, then check to make sure the pick container is empty when the order cycle finishes. If it is not empty, the cycle will finish with error code 'FinishedPickContainerNotEmpty'.
            # 
            # If this is set to True, it overrides computePickContainerEmptyOnFinish.
            'checkPickContainerEmptyOnFinish': 'Boolean', # Boolean
            # If True, then check to make sure the place container is empty upon arrival. Non-empty place container will trigger the error code FinishedPlaceContainerNotEmpty.
            'checkPlaceContainerEmptyOnArrival': 'Boolean', # Boolean
            # If True, then computes (from vision data) if the pick container is empty or not after the final pick from the pick container. This will take an extra snapshot with the camera, so can reduce cycle time and slow down the move-out of the pick container. The result ('isContainerEmpty') is added to the log and the robot will continue.
            # 
            # To stop with an error code when the container is non-empty after picking, set checkPickContainerEmptyOnFinish to True. It overrides this parameter.
            'computePickContainerEmptyOnFinish': 'Boolean', # Boolean
            # Constrain a direction on the tool to be within a certain angle with respect to a global direction.
            'constraintToolInfo': 'ConstraintToolInfo', # ConstraintToolInfo
            # Info of precondition io checked before starting or resuming cycle
            'cyclePreconditionIOInfo': 'CyclePreconditionIOInfo', # CyclePreconditionIOInfo
            # Max number of times to repeat the destikparamnames, 0 means infinite repeat
            'cycledests': 'Int', # Int
            'debuglevel': 'Int', # Int
            # If True, will delete all dynamic objects after finishing cycle (for cleaning up)
            'deleteDynamicObjectsAfterFinish': 'String', # String
            # 0: do not delete target after it is picked up until the next vision detection update changes the targets. 1: delete the target after it is picked up. Setting this to 1 allows the robot to pick up previously overlapped parts without waiting for a vision update, but it is also more dangerous since there can be parts below the picked up target that were previously getting occluded, and removing the picked up target might wrongly tell the robot that the below region is free space. If 2, then only consider the delete targets during grabbing the part, but still consider them during approach.
            'deleteTargetFromSourceContainer': 'Int', # Int
            # If True, then delete the target as soon as it is placed in the destination. This simulates machines or drop off locations which take the part as soon as the robot releases them.
            'deleteTargetWhenPlacedInDest': 'String', # String
            # If True, will delete the current targets after every pick and force re-detection of the parts. Used when robot has to stop and rescan every frame.
            'deleteTargetsEveryCycleSlowMode': 'Boolean', # Boolean
            # If True, when the piece is lost and robot has to recover, will remove the all detected targets from the scene and wait for new ones to come.
            'deleteTargetsOnPieceLost': 'Boolean', # Boolean
            # If True, during any recovery because of a failure to pick or move the robot, will remove the all detected targets from the scene and wait for new ones to come.
            'deleteTargetsOnRecovery': 'Boolean', # Boolean
            # If True and robot is initially occluding the container, then delete all the targets and wait for vision to repopulate
            'deletetargetonocclusion': 'Boolean', # Boolean
            # mm, When part is close to walls, how much to depart to get it out of the wall.
            'departOffsetFromWalls': 'Float', # Float
            # mm/s^2
            'destApproachAccel': 'Float', # Float
            # This array is used to compute scaling multiplier that scales dest approach acceleration and deceleration from target mass. Computed scaling multiplier will be saturated by 1.0. This is useful when mass validation is enabled and there is difficulty on computing accurate inertial force compensation.
            'destApproachAccelDecelScaleMultOnTargetMass': 'DestApproachAccelDecelScaleMultOnTargetMass', # [DestApproachAccelDecelScaleMultOnTargetMass]
            # Absolute current thresholds that should not exceed by joints during destination approach
            'destApproachCurrentExceedThresholds': 'Float', # [Float]
            # Check if any of the currents exceed the difference between the start current thresholds (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Do the check after torqueCheckStartTime.
            'destApproachCurrentExceedThresholdsDelta': 'Float', # [Float]
            # mm/s^2,
            'destApproachDecel': 'Float', # Float
            # Absolute force and torque thresholds that should not exceed during destination approach. Unit is N for force, Nm for torque. A negative value means the component is disabled.
            'destApproachForceTorqueExceedThresholds': 'Float', # [Float]
            # Check if any of the force and torque exceed the difference between the values at start (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Unit is N for force, Nm for torque. A negative value means the component is disabled. Do the check after torqueCheckStartTime.
            'destApproachForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm/s
            'destApproachSpeed': 'Float', # Float
            # destination approach speed mult on unknown-sized target. has to be greater than 0.01, less than or equal to 1.0
            'destApproachSpeedMultOnUnknownSize': 'Float', # Float
            # Describes the barcode scanning on the dest
            'destBarcodeScanningInfo': 'DestBarcodeScanningInfo', # DestBarcodeScanningInfo
            # mm/s^2,
            'destDepartAccel': 'Float', # Float
            # mm/s^2,
            'destDepartDecel': 'Float', # Float
            # If true then will attempt to merge dest depart with future approach trajectory to speed up robot logic
            'destDepartFutureCycleMerge': 'Boolean', # Boolean
            # mm/s
            'destDepartSpeed': 'Float', # Float
            # destination depart speed multiplier on unknown-sized target. has to be greater than 0.01, less than or equal to 1.0
            'destDepartSpeedMultOnUnknownSize': 'Float', # Float
            # deg, enabled if destcoordtype==target. an angle is used to filter destinations such that they only allow targets in the source container that are oriented around the container's up axis. The minimum rotation angle between the source and destination target poses (once they are normalized by the in-plane rotation) is thresholded by this value. if less than 0, then invalid. angle in degrees.
            'destFilterByTargetOrientationThresh': 'Float', # Float
            # Parameters used for computing target placement when 'destCoordType' is 'targetAABBAlignIk'
            'destTargetAABBAlignIkParameters': 'DestTargetAABBAlignIkParameters', # DestTargetAABBAlignIkParameters
            # Parameters used when placing a part at the destination when 'destCoordType' is targetAnyBottomFace.
            'destTargetAnyBottomFaceRotationParameters': 'DestTargetAnyBottomFaceRotationParameters', # DestTargetAnyBottomFaceRotationParameters
            # Parameters used when placing targets at the destination with 'destCoordType' being 'targetCorner'.
            'destTargetCornerParameters': 'DestTargetCornerParameters', # DestTargetCornerParameters
            # Parameters used when placing targets at the destination with 'destCoordType' being 'targetStack'.
            'destTargetStackParameters': 'DestTargetStackParameters', # DestTargetStackParameters
            # mm, if a target at the destination is in collision, then can jitter by this distance so that a new collision-free goal could be used instead. This is used when a destination point cloud is used to pack items.
            'destTargetValidationJitterDist': 'Float', # Float
            # mm (x,y,z)
            'destapproachoffsetdir': 'Float', # [Float]
            # if True then destapproachoffsetdir is in the tool coordinate system
            'destapproachoffsetintool': 'Boolean', # Boolean
            'destcontainername': 'String', # String
            # Coordinate system type of the destination. can be one of:
            # - 'tool' specifying the current tool,
            # - 'toolzntarget' specifying the point of the tool projected along the -z axis until the target boundary,
            # - 'target' specifying the original target coordinate system, or
            # - 'targetbottom' that offsets the target so its grasped bottom aligned with the ikparam, or
            # - 'targetAnyBottomFace' specifying that robot should put the target on its bottom face regardless of which grasp it makes. The center is aligned with the center of the target bounding box.
            # - 'targetAnyBottomFaceAlignedX' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the X axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceAlignedY' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the Y axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceXIsLongAxis' specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the longest side of the target with the X-axis of the goal. Will align so that the target X axis is always toward the X of the ikparam. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetCorner' - Align any corner of the target with the 6D coordinate system.
            # - 'targetStack' - stack targets on top of previously placed targets. Prioritize placement on lower stacks.
            # - 'targetAnyBottomBarCodeFace' - specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the registered known barcode faces to the barcode reader. if there are no known barcode faces, does the same as targetAnyBottomFaceXIsLongAxis. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetAABBAlignIk' - Align target's AABB with the dest ikparam
            'destcoordtype': 'String', # String
            # mm (x,y,z)
            'destdepartoffsetdir': 'Float', # [Float]
            # If true then destination depart offset is computed in the tool coordinate system
            'destdepartoffsetintool': 'Boolean', # Boolean
            # If > 0, then the detector come give old cached detection results back even though the sensor time stamp is updated. So this is the max time between a sensor timestamp and the result returned for that timestamp. Most detectors have this as 0 since they take only one sensor snapshot. Some detectors that need to do sensor fusion can be giving out old cached results.
            'detectionResultsMaxCacheTime': 'Float', # Float
            # If True, then any bodies that have been placed before to that location will be disabled and ignored during planning. This is used when a sensor is re-sensing the bodies and therefore will produce its own detected_ versions of the bodies.
            'disablePlacedTargetsInPickLocationWhenPlanning': 'Boolean', # Boolean
            # Parameters for measuring the height of a target object with a 1D distance sensor. Setting up these parameters will send timed IO values as the robot trajectory is executed.
            'distanceMeasurementInfo': 'DistanceMeasurementInfo', # DistanceMeasurementInfo
            # If False, the robot may try to shortcut the departing trajectory after grabbing a part to improve performance. If the clearance with other parts at grasping points is tight, this should be set to True.
            'doAccurateGraspDepart': 'Boolean', # Boolean
            # This parameter is only considered if isStopOnPieceLost is True. If this parameter is True and PieceLost occurs inside the source container, recovery is attempted. If PieceLost occurs outside the source container, the robot stops without recovering (since it is unclear where the piece fell).
            'doAutoRecoveryOnPieceLost': 'Boolean', # Boolean
            # If True, will try to recover after a robot execution error occurs.
            'doAutoRecoveryOnRobotExecutionError': 'Boolean', # Boolean
            # Parameters to define how to drop object to the destination.
            'dropInDestInfo': 'DropInDestInfo', # DropInDestInfo
            # Coordinate system type of the destination used for drop off. See description of destcoordtype for possible options
            'dropOffDestCoordType': 'String', # String
            # [0,1], Speed multiplier when robot is dropping a part off.
            'dropOffSpeedMult': 'Float', # Float
            # For destinations with isDropInSource set to True, try to lower the drop point so that it is [dropOffsetFromCollision] away from the top of the parts in the pick container.
            'dropOffsetFromCollision': 'Float', # Float
            # Multiplier for the target aabb to determine if safely dropped in dest container. the higher the value, the more safety there is in accidentally thinking that the part was dropped inside the container.
            'dropTargetInDestContainerBoxMult': 'Float', # Float
            # If target is inside the XY dest constraints, this controls what is the max height of the target (in terms of its multiples) where it is ok to drop the target because of torque limits/piece lost errors. in other words, the amount of z extents that could be outside of the dest and still success will be declared. The lower the value, the more conservative it is.
            'dropTargetInDestContainerZSafetyMult': 'Float', # Float
            # Multiplier for the target aabb to determine if safely dropped in source container. the higher the value, the more safety there is in accidentally thinking that the part was dropped inside the container. If robot is getting FinishedDropTargetFailure while object is still in container, then reduce this value.
            'dropTargetInSourceContainerBoxMult': 'Float', # Float
            # mm, maximum distance from the grasp trajectory start point to determine if the part safely dropped inside of the source container. If 'isStopOnPieceLost' is False, then recover regardless this parameter; if 'isStopOnPieceLost' is True and the part safely dropped then try to recover from PieceLost error.
            'dropTargetMaxDistanceThresold': 'Float', # Float
            # mm, maximum XY distance from the grasp trajectory start point to determine if the part safely dropped inside of the source container. If 'isStopOnPieceLost' is False, then recover regardless this parameter; if 'isStopOnPieceLost' is True and the part safely dropped then try to recover from PieceLost error.
            'dropTargetMaxDistanceXYThreshold': 'Float', # Float
            # Dynamic goals generator parameters. Used only if useDynamicGoals is True
            'dynamicGoalsGeneratorParameters': 'DynamicGoalsConfig', # DynamicGoalsConfig
            # deg/sec, robot is assumed to reach the commanded position when sum of absolute values of actual joint velocities is lower than this threshold. The smaller the value, the more accurate the robot will be, but will be slower.
            'encoderConvergenceSpeedThresh': 'Float', # Float
            'executethread': 'Boolean', # Boolean
            # The parameter is used to control how fast the robot decelerates when pausing due to an interlock or PieceLost problem.
            'executionConnectingTrajDecelMult': 'Float', # Float
            # The parameter is used to control how fast the robot moves backward and then stops when reversing due to torque limit error or position tracking error.
            'executionConnectingTrajReverseMult': 'Float', # Float
            # the parameter is used to make robot trajectory while grabbing not grabbing  a target smooth. Default is 1.0, a smaller value makes the trajectory smoother, but the trajectory is rejected more often and can possibly collide with obstacles.
            'executionFilterFactor': 'Float', # Float
            # the parameter is used to make robot trajectory while grabbing a target smooth. Default is 0.4, a smaller value makes the trajectory smoother, but the trajectory is rejected more often and can possibly collide with obstacles.
            'executionFilterFactorWhenGrabbing': 'Float', # Float
            # mm, recovery distance the robot tool should move in reverse of the trajectory from the detected collision/error position.
            'executionReverseRecoveryDistance': 'Float', # Float
            # Parameters for enabling and setting up execution verification that allows the robot to quickly stop when it is about to hit a part that is moved. This function is *highly recommend* to be used.
            'executionVerificationInfo': 'ExecutionVerificationInfo', # ExecutionVerificationInfo
            # If True, then allows to reset needContainer signals earlier while processing the last part.
            'fastNeedContainerReset': 'Boolean', # Boolean
            # deg/mm, how many deg/mm each joint has to be from the commanded position to declare that it is reached. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDefaultWorkspaceThreshold.
            'feedbackDefaultJointThreshold': 'Float', # Float
            # mm, how many mm the real tooltip position has to be from the commanded position to declare that it is reached. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDestJointThreshold.
            'feedbackDefaultWorkspaceThreshold': 'Float', # Float
            # deg/mm, how many deg/mm each joint has to be from the commanded dest (release) position to declare that it is in at the destination. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDestWorkspaceThreshold.
            'feedbackDestJointThreshold': 'Float', # Float
            # mm, how many mm the real tooltip position has to be from the commanded dest (release) position to declare that it is in at the destination. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDestJointThreshold.
            'feedbackDestWorkspaceThreshold': 'Float', # Float
            # deg/mm, how many deg/mm each joint has to be from the commanded grasp joint values to declare that it is at the grasp. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackGraspWorkspaceThreshold.
            'feedbackGraspJointThreshold': 'Float', # Float
            # mm, how many mm the real tooltip position has to be from commanded grasp position to declare that it is at the grasp. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackGraspJointThreshold.
            'feedbackGraspWorkspaceThreshold': 'Float', # Float
            # The mode to compute the final plan. if empty, do not do any final plan for each cycle, the robot stops after the dest depart. If 'cameraocclusion', then make sure robot is away from the camera occlusion.
            # If 'config', then plan for robot 'finalPlan' only if the robot is occluding the camera at the source.
            # If 'configIgnoreOcclusion', then always plan to robot 'finalPlan' position.
            'finalPlanMode': 'String', # String
            # the time to wait after a final plan, usually to allow system to rescan the environment
            'finalPlanWaitTime': 'Float', # Float
            # If not None, forces particular bodies to be picked up. forceTargetNamePattern has to match to targetnamepattern. initially introduced for picking from the buffer region. CANNOT be used with forcetargetname.
            'forceTargetNamePattern': 'String', # String
            # if True, then will only pick up targets that match exactly with the specified target uri
            'forceTargetUriCheck': 'Boolean', # Boolean
            # Parameters for state estimation features based on force torque sensor
            'forceTorqueBasedEstimatorParameters': 'ForceTorqueBasedEstimatorParameters', # ForceTorqueBasedEstimatorParameters
            # If not None, forces only one particular body to be picked up. forcetargetname has to match targetnamepattern
            'forcetargetname': 'String', # String
            # Project-Id-Version: PACKAGE VERSION
            # Report-Msgid-Bugs-To: 
            # PO-Revision-Date: 2015-07-17 11:57+0900
            # Last-Translator: Automatically generated
            # Language-Team: none
            # Language: en_US
            # MIME-Version: 1.0
            # Content-Type: text/plain; charset=UTF-8
            # Content-Transfer-Encoding: 8bit
            # Plural-Forms: nplurals=2; plural=(n != 1);
            'grabbedTargetValidationSignalsInfo': 'GrabbedTargetValidationSignalsInfo', # GrabbedTargetValidationSignalsInfo
            # mm/s^2
            'graspApproachAccel': 'Float', # Float
            # Parameters to move away from neighboring walls on departing. when these parameters are used to approaching, it computes movement that gets close to walls from the given distance.
            'graspApproachCollisionWallOffsetParameters': 'CollisionWallOffsetParameters', # CollisionWallOffsetParameters
            # mm/s^2
            'graspApproachDecel': 'Float', # Float
            # mm/s
            'graspApproachSpeed': 'Float', # Float
            # If True then always depart along graspDepartOffsetDir so that the bottom of the grabbed target is above any of the nearby obstacles within neighTargetThresh. It starts from graspDepartOffsetDir and adds more along its direction, so in the worst case, graspDepartOffsetDir will always be set.
            'graspDepartAboveNearbyObstacles': 'Boolean', # Boolean
            # mm, If graspDepartAboveNearbyObstacles is True, then always depart so that the bottom of the grabbed target is above any of the nearby obstacles within neighTargetThresh. From that point, graspDepartOffsetDir will be added to determine the final grasp depart offset.
            'graspDepartAboveNearbyObstaclesMaxDist': 'Float', # Float
            # mm/s^2,
            'graspDepartAccel': 'Float', # Float
            # This array is used to compute scaling multiplier that scales grasp depart acceleration and deceleration from target mass. Computed scaling multiplier will be saturated by 1.0. This is useful when mass validation is enabled and there is difficulty on computing accurate inertial force compensation.
            'graspDepartAccelDecelScaleMultOnTargetMass': 'GraspDepartAccelDecelScaleMultOnTargetMass', # [GraspDepartAccelDecelScaleMultOnTargetMass]
            # Parameters to move away from neighboring walls on departing. when these parameters are used to approaching, it computes movement that gets close to walls from the given distance.
            'graspDepartCollisionWallOffsetParameters': 'CollisionWallOffsetParameters', # CollisionWallOffsetParameters
            # Absolute joint motor current thresholds that should not be exceeded. If exceeded, then will return torque error
            'graspDepartCurrentExceedThresholds': 'Float', # [Float]
            # Check if difference between the start joint motor current values (at torqueCheckStartTime) and the current values exceed these thresholds. If they do, then will return torque error.
            'graspDepartCurrentExceedThresholdsDelta': 'Float', # [Float]
            # mm/s^2,
            'graspDepartDecel': 'Float', # Float
            # Absolute force and torque thresholds that should not be exceeded during grasp depart. Unit is N for force, Nm for torque.
            'graspDepartForceTorqueExceedThresholds': 'Float', # [Float]
            # Check if any of the force and torque exceed the difference between the values at start (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Unit is N for force, Nm for torque.
            'graspDepartForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm (x,y,z)
            'graspDepartOffsetDir': 'Float', # [Float]
            # mm, max distance to reverse the trajectory from the detected collision/error position when got torque error during grasp depart.
            'graspDepartReverseRecoveryDistance': 'Float', # Float
            # mm/s
            'graspDepartSpeed': 'Float', # Float
            # degrees, an angle is used to filter grasps such that they only allow approaches in the source container that are oriented around the container's up axis given this threshold. if less than 0, then invalid.
            'graspFilterByApproachOrientationThresh': 'Float', # Float
            # Multipliers for various grasp-goal pair costs.
            'graspGoalPairCostMultipliers': 'GraspGoalPairCostMultipliers', # GraspGoalPairCostMultipliers
            # mm, distance to penetrate when robot is grasping a tilted part
            'graspPenetrationOnTiltDist': 'Float', # Float
            # Multipliers for various grasp priority values.
            'graspPriorityMultipliers': 'GraspPriorityMultipliers', # GraspPriorityMultipliers
            # max time to spend on computing one grasp for one target. 0 means infinite
            'graspTimeLimit': 'Float', # Float
            # Name of the grasp set to use for picking
            'graspsetname': 'String', # String
            # If true, will ignore any dynamic obstacles when departing after grasping. By default this is False since it is safer for the parts that the robot will be picking up, valid grasps will be harder to find though.
            'ignoreDynamicObstaclesInGraspDepart': 'Boolean', # Boolean
            # If set to True, then can pick up any targets that match with targetnamepattern regardless of their isPickable flags. Set to False by default.
            'ignoreIsPickable': 'Boolean', # Boolean
            # If > 0, the timelimit in seconds to compute IK solutions for the highest priority targets. If IK solutions are computed for them, then start the grasp goal pairing right away to plan for it.
            'ikTimeLimitForHighestPriority': 'Float', # Float
            # mm, when the IK solution requires less DOF than the number of joints of the robot, have to sample the rest of the robot's prismatic axes with this sampling step.
            'iksolverfreeincprismatic': 'Float', # Float
            # rad, when the IK solution requires less DOF than the number of joints of the robot, have to sample the rest of the robot's revolute axes with this sampling step. defines the granularity of the free joint search in radians, the smaller the value, the longer planning takes. sometimes we need to decrease this number to allow ik to succeed. for example, when the free joint is the base joint, a small angle results in big displacement in the end effector.
            'iksolverfreeincrev': 'Float', # Float
            # the timelimit in seconds to compute IK solutions until system starts the planning. If no IK solution are computed by this time, then system will wait until at least one pair is computed, or everything is exhausted.
            'iktimelimit': 'Float', # Float
            # Specifies how to check condition of detected targets at the beginning of cycle. Number of detected targets and scanned barcode on detection time can be checked.
            'initialDetectionValidationInfo': 'InitialDetectionValidationInfo', # InitialDetectionValidationInfo
            # If True, then moves the robot out of camera occlusion before starting the cycle.
            'initialMoveRobotOufOfCameraOcclusion': 'Boolean', # Boolean
            # Properties about drop off location
            'inspectionFailDropOffInfo': 'InspectionFailDropOffInfo', # InspectionFailDropOffInfo
            # List of information specifying conditions for when to do an intermediate cycle for target re-grabbing. Conditions for intermediate cycle can very, which is why there is a list of them.
            'intermediateCycles': 'IntermediateCycleInfo', # [IntermediateCycleInfo]
            # If True stops the cycle execution if the robot has controller error and raise an error
            'isStopOnControllerError': 'Boolean', # Boolean
            # If True stops the cycle execution if the gripper fails to move fingers to a designated position
            'isStopOnGripperPositionNotReached': 'Boolean', # Boolean
            # If True stops the cycle execution if mass/center of mass validation reports mismatch. If False, cycle continues after mass mismatch only when robot can safely drop back an item to source.
            'isStopOnObjectMassPropertiesMismatch': 'Boolean', # Boolean
            # If True and doAutoRecoveryOnPieceLost is False, stops the cycle execution if the piece is lost and raises an error. If doAutoRecoveryOnPieceLost is true and the piece was lost inside the source container (= the part most likely fell back inside), cycle execution continues.
            'isStopOnPieceLost': 'Boolean', # Boolean
            # If True, stops the cycle execution if a robot execution error occurs and raise an error
            'isStopOnRobotExecutionError': 'Boolean', # Boolean
            # If True stops the cycle execution if the torque limits exceeded and raise an error
            'isStopOnTorqueLimitsError': 'Boolean', # Boolean
            # If True, then stops the cycle execution if the torque limits exceeded outside of the source container. This usually when in mid-air, or at the destination, or somewhere during an intermediate cycle.
            'isStopOnTorqueLimitsErrorOutsidePickLocation': 'Boolean', # Boolean
            # Names of ITL programs to run every cycle on specific events
            'itlProgramNamesOnEvent': 'ITLExecutionInfo', # [ITLExecutionInfo]
            # Parameters dealing with jittering the robot out of collisions.
            'jittererParameters': 'JittererParameters', # JittererParameters
            # Parameters for configuring just-in-time tool change planning feature
            'justInTimeToolChangePlanning': 'JustInTimeToolChangePlanningParameters', # JustInTimeToolChangePlanningParameters
            # Describes the label printer and how the robot computes the label placing motion.
            'labelPlacingInfo': 'LabelPlacingInfo', # LabelPlacingInfo
            # mm, When using 5D destination for target, this describes the axis in the local target coordinate system that should align with the global direction from the ikparam.
            'localTargetDir': 'Float', # [Float]
            # mm, how much to pad the external location collision region for the robot to pause before interlock occurs.
            'locationInterlockSafetyXYZ': 'Float', # [Float]
            # seconds, if the workpiece failed to be picked up, then continue ignoring the workpiece for this many seconds.
            'logFailedTargetTimeout': 'Float', # Float
            # if > 0, then will only accept dest transfer plans (from source to dest container) that are faster than this limit.
            'maxAcceptedDestPlanTrajTime': 'Float', # Float
            # if > 0, then will only accept finish plans (for dest to finish) that are faster than this limit.
            'maxAcceptedFinishTrajTime': 'Float', # Float
            # Out of this many camera ik params that have ik solutions, will pick the one that gives solutions closest to the corresponding approach/depart configs.
            'maxConsideredCameraIkSolutions': 'Int', # Int
            # sometimes the dest trajectory planning can fail because of a bad pair of grasps and targets. this controls how many failures are tolerated before system fails.
            'maxDestFailuresForTargetGrasp': 'Int', # Int
            # The maximum IK solutions to have per destination before system gives up and tries something else. If 0, then compute all solutions
            'maxDestIkSolutions': 'Int', # Int
            # max number of times final plan can be ignored
            'maxFinalPlanIgnoreCount': 'Int', # Int
            # minimum number of targets to have before can start to ignore the final plan mode
            'maxFinalPlanIgnoreMinTargets': 'Int', # Int
            # The maximum IK solutions to have per target before system gives up and tries something else. If 0, then compute all solutions
            'maxGraspIkSolutions': 'Int', # Int
            # max grasp solutions allowed per grasp. If 0, then infinite
            'maxGraspIkSolutionsPerGrasp': 'Int', # Int
            # sometimes the grasp approach/depart can fail if the target is still in collision with other objects, in that if the number of total failures for the target exceeds this threshold, should invalidate the target from consideration.
            'maxLinearFailuresForTarget': 'Int', # Int
            # sometimes the grasp approach/depart can fail if the target is still in collision with other objects, in that case all grasp departs will fail
            'maxLinearFailuresForTargetGrasp': 'Int', # Int
            # if robot had cycle failures for amount of times in a row, then stop cycle
            'maxNumConsecutiveCycleFailures': 'Int', # Int
            # if robot had PieceLost for amount of times in a row, then stop cycle
            'maxNumConsecutivePieceLost': 'Int', # Int
            # if robot had execution verification failures for amount of times in a row, then stop cycle
            'maxNumConsecutiveVerificationFailures': 'Int', # Int
            # max number of planning iterations to fail until the system gives up
            'maxNumPlanningFailedIterations': 'Int', # Int
            # The max cycles to queue ahead for planning
            'maxPlanningCyclesToQueue': 'Int', # Int
            # sometimes the start trajectory planning can fail because the target itself is in a corner or underneath other parts, and it shouldn't be picked up this cycle. This controls how many times a target failed to plan the start trajectory and then invalidates the target.
            'maxStartFailuresForTarget': 'Int', # Int
            # sometimes the start trajectory planning can fail because of a bad pair of grasps and targets. this controls how many failures are tolerated before system fails.
            'maxStartFailuresForTargetGrasp': 'Int', # Int
            # The amount of countdown time (in seconds.) until the target, which previously failed, is clear from a penalty. This parameter is used in conjunction with targetPriorityMultipliers/failureCountdownMult.
            'maxTimeForDecrease': 'Float', # Float
            # the percentage of current to limit from maximum when grasp approaching. if 1, then disable
            'maxTorqueMultForApproach': 'Float', # Float
            # the percentage of current to limit from max when dest approaching. if 1, then disable
            'maxTorqueMultForDestApproach': 'Float', # Float
            # sometimes transferring the target can fail because the target itself is in a corner or underneath other parts, and it shouldn't be picked up this cycle. This counts how many times a target failed to plan the tranfer trajectory and then invalidates the target.
            'maxTransferFailuresForTarget': 'Int', # Int
            # coordinate system type of the mid-destination controlled by [midDestIkparamNames]. can be one of:
            #  - 'tool' specifying the current tool,
            # - 'target' specifying the original target coordinate system.
            'midDestCoordType': 'String', # String
            # Names of the mid dest params to go to
            'midDestIkparamNames': 'String', # [String]
            # seconds, The speed to pass through the mid-dest.
            'midDestPassthroughVelocity': 'Float', # Float
            # seconds, The time to wait at the middest
            'midDestWaitTime': 'Float', # Float
            # The minimum accepted combined transferSpeedMult. Reject everything else. Some grasps might have really slow speeds, this forces the robot to reject those grasps
            'minAcceptedTransferSpeedMult': 'Float', # Float
            # controls the percentage of the grasp depart trajectory that the robot needs to minimally achieve in order to move on. This would be used when grasp depart has to be big sometimes, but not always. By default it is 1. The lower value means the robot will end the depart earlier and start the transfer motion.
            'minGraspDepartCompleteRatio': 'Float', # Float
            # Specifying the minimum transferSpeedMult ratio in [0,1]. If the resolved transferSpeedMult is less than this, but greater than minAcceptedTransferSpeedMult, then set the transferSpeedMult to this value. When there are multiple grasps with different transferSpeedMult
            'minTransferSpeedMult': 'Float', # Float
            # parameters that are used with planning for minimum viable region
            'minViableRegionPlanParameters': 'MinViableRegionPlanParameters', # MinViableRegionPlanParameters
            # Parameters used for linear movement like grasp approach, grasp depart, etc.
            'moveStraightParams': 'MoveStraightParameters', # MoveStraightParameters
            # Parameters used for linear movement when have to do dynamic replanning during execution. The parameters should be more loose than moveStraightParameters since the robot might be very close to thresholds and fail.
            'moveStraightParamsOnReplan': 'MoveStraightParameters', # MoveStraightParameters
            # if True then will use 'midDestIkparamNames' to move to middest
            'moveToMidDest': 'Boolean', # Boolean
            # If 1, then robot will place a part in the destination after picking up. If false, then robot will stop the cycle after picking up.
            'movetodestination': 'Int', # Int
            # mm. A threshold to avoid picking multiple items close to one another.
            # 
            # When using the same vision result to pick multiple items, objects which are closer to previous target objects than this threshold will not be considered. This means that all objects in a radius neighTargetThresh around picks will be discarded from the grasp candidates until a newer detection result is received. The threshold represents the area in which objects may have been moved by the picking actions, so that the vision result would not be reliable anymore.
            # 
            # The distance is calculated between the object poses. It does not consider the object's mesh or shape.
            # 
            # This parameter should be chosen depending on the type of object, the gripper and the vision system. For large object size and detection noise, a larger value will be appropriate. A reasonable value may be 0.5-2x the object's extent (the maximum dimension).
            'neighTargetThresh': 'Float', # Float
            # mm. A threshold to avoid picking targets close to another target whose pick-place execution resulted in a torque limit error. 
            # 
            # See the neighTargetThresh parameter for a detailed explanation. This parameter works the same way, but it only applies when the pick-place execution caused a torque limit error.
            # 
            # A reasonable value may be 1-3x the object's extent.
            # 
            # This parameter has no effect if it is smaller than neighTargetThresh.
            'neighTargetThreshForTorqueError': 'Float', # Float
            # when a slave finishes the planning of the order cycle, will use this uri to notify another slave of the current state of the environment. Format is tcp://localhost:11000/?slaverequestid=XXX&username=YYY&otheroption&ZZZ
            'notifyStateSlaveZMQUri': 'String', # String
            # The number of parts to place in the destination. picked up failures do not count. If 0, then will continue going until cycledests and destikparamnames have been all exhausted. Otherwise will only pick up these parts and stop the pick and place loop.
            'numTargetsToPlace': 'Int', # Int
            # Number of threads to be used for planning
            'numThreads': 'Int', # Int
            # Parameters to check object mass properties. If enabled, object mass properties will be checked dynamically while executing pick and place cycle. Force/Torque sensor is required to use this feature.
            'objectMassPropertiesCheckingInfo': 'ObjectMassPropertiesCheckingInfo', # ObjectMassPropertiesCheckingInfo
            # Describes some binpicking parameters which have to be applied for the specific objectType.
            'objectTypeDynamicParametersMap': 'ObjectTypeDynamicParameters', # ObjectTypeDynamicParameters
            # Specify a default pack formation name when running the Order Cycle.
            'orderPackFormationName': 'String', # String
            # Parameters controlling the packing behaviors and algorithms for startPackFormationComputation command.
            'packFormationParameters': 'PackFormationParameters', # PackFormationParameters
            # Parameters for robot path planning.
            'pathPlannerParameters': 'PathPlannerParameters', # PathPlannerParameters
            # Describes the pick location and properties about it to initialize the cycle.
            'pickLocationInfo': 'PickLocationInfo', # PickLocationInfo
            # Describes the place locations and properties about them to initialize the cycle.
            'placeLocationInfos': 'PlaceLocationInfo', # [PlaceLocationInfo]
            # mm, x,y,z. How much padding the robot needs to consider for lastly placed target.
            'placedTargetExtraPadding': 'Float', # [Float]
            # The prefix of all placed target names during the cycle
            'placedTargetPrefix': 'String', # String
            # What translation (distance) range target remains after placing to the destination. mm, x,y,z. For example, this is useful when the destination is a conveyor and the conveyor will move placed target for certain range and need to protect target on that range.
            'placedTargetRemainingTranslationRange': 'Float', # [Float]
            # Controls how planning for destinations work. Can control which planning stages get planned for so that user can test various aspects of the plan.
            # - None - then do not plan for any dest, and stop after the robot does a grasp depart
            # - All - plan for everything
            'planToDestMode': 'String', # String
            # Controls the scheduling of internal grasp/dest planning into worker threads.
            'planningSchedulingMode': 'String', # String
            # Post cycle execution and conveyor parameters.
            'postCycleExecution': 'PostCycleExecutionConfigurations', # PostCycleExecutionConfigurations
            # Describes where to place predicted target before detection results.
            'predictDetectionInfo': 'PredictDetectionInfo', # PredictDetectionInfo
            # Info structure for maintaining grasp parameters for random box picking. Used when picking up randomized boxes (targetIsRandomBox is True).
            'randomBoxInfo': 'RandomBoxInfo', # RandomBoxInfo
            # Speed multiplier when recovering from torque or piece-lost errors.
            'recoverySpeedMult': 'Float', # Float
            # Configuration of restricting label orientation of placed items. labelerDirection has to be defined for restriction to be applied.
            'restrictLabelOrientationInfo': 'RestrictLabelOrientationInfo', # RestrictLabelOrientationInfo
            # mm or degrees. Need to specify values for all joints.
            'robotCycleStartPosition': 'Float', # [Float]
            # mm or degrees. Need to specify values for all joints.
            'robotFinishPosition': 'Float', # [Float]
            # mm/s^2,
            'robotRecoveryDepartAccel': 'Float', # Float
            # mm (x,y,z)
            'robotRecoveryDepartOffsetDir': 'Float', # [Float]
            # If true then robotRecoveryination depart offset is computed in the tool coordinate system
            'robotRecoveryDepartOffsetInTool': 'Boolean', # Boolean
            # mm/s
            'robotRecoveryDepartSpeed': 'Float', # Float
            # mm or degrees. Need to specify values for all joints.
            'robotRecoveryPosition': 'Float', # [Float]
            # Save trajectory logs which will be concatenated and scene file to reproduce the results. When this feature is enabled, the system can slow down a little since it is storing data.
            'saveConcatenateTrajectoryLog': 'Boolean', # Boolean
            # 0 or 1
            'saveDynamicGoalGeneratorState': 'Int', # Int
            # If set to 1 and logging level is info or higher, saves state of the _dynamicGoalsGenerator to the disk.
            'saveDynamicGoalGeneratorStateFailed': 'Int', # Int
            # If logging level is info or higher, saves state of the _dynamicGoalsGenerator to the disk if pack following switched to random packing mode.
            'saveDynamicGoalGeneratorStateOnRandomMode': 'Boolean', # Boolean
            # if 1, then saves the environment state for every plan.
            'saveEnvState': 'Int', # Int
            # Save logs related to filtering in planning. When this feature is enabled, the system can slow down a little since it is storing data.
            'saveFilterTrajectoryLog': 'Boolean', # Boolean
            # if true, then saves the environment whenever recovery occurs while robot is grabbing (GrabRecovery).
            'saveGrabRecoveryScene': 'Boolean', # Boolean
            # If 1, saves the packing state when computing pack formation.
            'savePackingState': 'Int', # Int
            # if true, then saves the environment whenever recovery from piece lost or other cancellation occurs.
            'saveRecoveryScene': 'Boolean', # Boolean
            # Save logs from each trajectory the robot executes with data including the encoder values of the robot, the current/torque values, and specific IO signal values. When this feature is enabled, the system can slow down a little since it is storing data. Some UI functions that display data need this feature to be enabled so that the correct data can be displayed.
            'saveRobotFeedbackLog': 'Boolean', # Boolean
            # if 1, then saves the environment state showing robot execution verification failure.
            'saveVerificationScene': 'Int', # Int
            # 0 or 1
            'savetrajectorylog': 'Int', # Int
            # a dictionary specifying what kind of destinations can be skipped during destination validation process
            'skipCollidingDestsInfo': 'SkipCollidingDestsInfo', # SkipCollidingDestsInfo
            # Parameters dealing with getting smoother paths for the robot planning.
            'smootherParameters': 'SmoothingParameters', # SmoothingParameters
            # value multiplied by the rotational angle between the source and dest target orientations and added to the final cost of considering the particular grasp/goal pair. 0 if doesn't matter. By default it is 0 so not to penalize the orientations
            'sourceDestTargetOrientationPenalty': 'Float', # Float
            # Dynamic goals generator parameters. Used only if useDynamicGoals is True
            'sourceDynamicGoalsGeneratorParametersOverwrite': 'DynamicGoalsConfig', # DynamicGoalsConfig
            # list of cameras names for doing detection inside the source container. Each camera name is in the format of kinbody_name/attached_sensor_name. Overwritten by first layer value!
            'sourcecameranames': 'String', # [String]
            'sourcecontainername': 'String', # String
            # Describes the order of targets to be picked up. Currently available strategies are
            # 'axis'
            # 'containerLocalAxis'
            # 'name'
            # 'type'
            'strictPickOrdering': 'StrictPickOrdering', # StrictPickOrdering
            # sec, max time to spend on computing grasps for one target. 0 means infinite
            'targetGraspTimeLimit': 'Float', # Float
            # if True, then using randomized box picking which means vision will send results with the box sizes in it
            'targetIsRandomBox': 'Boolean', # Boolean
            # mm, The padding to add to the target when initially transferring the target outside of the source container to its next position (can be dest, middest, or scan position). cannot be defined (have positive value) with fTargetMinSafetyHeightForInitialTransfer
            'targetMinBottomPaddingForInitialTransfer': 'Float', # Float
            # Describes how overlapped regions in targets should be processed.
            'targetOverlapConstraintInfo': 'TargetOverlapConstraintInfo', # TargetOverlapConstraintInfo
            # name of the inverse kinematic parameter of the target to feet destination goal. Valid ONLY if destcoordtype=='targetplaceik', if not defined ik parameter name '_placed' will be used
            'targetPlaceIkParamName': 'String', # String
            # Apply this translation offset to all targets. Usually used to signify that targets drop a little because of the way gripper is designed or how far robot drops part from floor. mm, x,y,z
            'targetPlaceTranslationOffset': 'Float', # [Float]
            # The action to perform on the target after picking it successfully from the pick (source) container.
            # - setUnpickable - Do not delete target from the source container after it is picked up, the target is gonna be removed only after update from vision. Not deleting a target is safer, but could slow the cycle time
            # - moveDownSetUnpickable - Move the part down and set as unpickable
            # - delete - Completely delete the part from the pick (source) container, as soon as it's planned for pickup. 
            # - deleteButConsiderForApproachMove
            # - deleteNotifyBridge - notify the robotbridge that the target was deleted from the location
            'targetPostActionAfterPick': 'String', # String
            # How much to prioritize right-up objects in the container. The higher the value, the more object that will be prioritized with its axes facing in the up direction. By default it is 0.
            'targetPriorityForAngleMult': 'Float', # Float
            # the amount to multiple the confidence measure by. by default it is 1.
            'targetPriorityForConfidenceMult': 'Float', # Float
            # How much to prioritize the tool being close to its constraints (ie vertical). Multiplied by the angle from the constraint and subtracted from priority.
            'targetPriorityForConstraintToolDeviation': 'Float', # Float
            # how much to prioritize less tool rotation when the part is being grabbed. Multiply the angle (in radians) between the two rotations. By default is 0.5.
            'targetPriorityForGrabToolRotMult': 'Float', # Float
            # Multiplier for grasp center from target center of mass when subtracting from target priority. The higher this value, the more the grasp is penalized from being away from center.
            'targetPriorityForGraspDistMult': 'Float', # Float
            # Multiplier for grasp priority when adding to target priority.
            'targetPriorityForGraspPriorityMult': 'Float', # Float
            # how much to prioritize objects on -X in the container. The higher the value, the more will be prioritized.
            'targetPriorityForNegativeXMult': 'Float', # Float
            # how much to prioritize objects on -Y in the container. The higher the value, the more will be prioritized.
            'targetPriorityForNegativeYMult': 'Float', # Float
            # How much to prioritize objects that are not being overlapped by other objects. The multiplier is for the overlap ratio computed dynamically, which is in [0,1].
            'targetPriorityForNonOverlappedMult': 'Float', # Float
            # How much to prioritize objects that have distance (translational distance) from the closest previously picked target.
            'targetPriorityForPrevPickedTargetsDistMult': 'Float', # Float
            # how much to prioritize number of uncertain corners of the target object. negative value prioritizes the target has less uncertain corners.
            'targetPriorityForUncertainCornerMult': 'Float', # Float
            # how much to prioritize +X position of the objects in the container. positive value prioritizes items with higher global X value.
            'targetPriorityForXMult': 'Float', # Float
            # how much to prioritize objects based on distance from center of container.
            'targetPriorityForXYCenterDist': 'Float', # Float
            # How much to discretize priorities using XYZ in order to avoid small noise from affecting the priority computation directly. For example, if this parameter is set to 20, then height of two targets that are 801 and 815, both get considered the same priority.
            'targetPriorityForXYZDiscretization': 'Float', # Float
            # how much to prioritize +Y position of the objects in the container. positive value prioritizes items with higher global Y value.
            'targetPriorityForYMult': 'Float', # Float
            # how much to prioritize top most objects in the container. The higher the value, the more will be prioritized.
            'targetPriorityForZMult': 'Float', # Float
            # Multipliers and other related quantities for various target priority values.
            'targetPriorityMultipliers': 'TargetPriorityMultipliers', # TargetPriorityMultipliers
            # Depending on how the gripper overlaps with the target object, it can exert different suction forces on it. This is a multiplier on the force (N) for a target's grasp priority.
            'targetPrioritySuctionForceMult': 'Float', # Float
            # This is a multiplier on the transferSpeedMult (TSM) for a target's grasp priority.
            'targetPriorityTransferSpeedMult': 'Float', # Float
            # mm, threshold for maximum target thickness which can be trapped by disabled suction cup for items with objectType not 'bag' and 'twosidedpackage' items. Items with objectType 'bag' and 'twosidedpackage' will ignore such a parameter and will be considered for trapping. TODO: in the future compute from size of suction cups.
            'targetThicknessThreshForTrapping': 'Float', # Float
            # threshold between expected target position from destinations with the planned target position after robot grabbed and transferred it. If the planned position of the target is within this threshold then assume that the plan is successful. Smaller the value more accurate the placement is, but fail more frequently. Default is 0.01
            'targetdestikthresh': 'Float', # Float
            # mm, environment clearacence applied to grabbed target
            'targetenvclearance': 'Float', # Float
            # supports regular expressions (i.e. detected_\d+)
            'targetnamepattern': 'String', # String
            # Optional URI to use for every target. if randomized box picking, then leave empty
            'targeturi': 'String', # String
            # mm (x,y,z)
            'toolPosConstraintPaddingXYZ': 'Float', # [Float]
            # Allows specifying limits on the speed and acceleration of the manipulator.
            'toolSpeedAccelInfo': 'ToolSpeedAccelInfo', # ToolSpeedAccelInfo
            # mm, when gravity compensation is enabled, how many mm offset the robot could get from its commanded position before declaring a torque limits error
            'torqueDistThresh': 'Float', # Float
            # Specifies the transfer speed mult ratio in [0,1] to reduce speed when grabbing an object. This is a global setting applied
            'transferSpeedMult': 'Float', # Float
            # An array of the transfer speed multipliers for different weights. If the partType's weight is between the weights in this array, the transfer speed multiplier (transferSpeedMult) is interpolated linearly.
            'transferSpeedMultPerWeight': 'TransferSpeedMultPerWeight', # [TransferSpeedMultPerWeight]
            # If True, update the height of the object depending on the distance sensor measurement.
            'updateHeightWithMeasuredValue': 'Boolean', # Boolean
            # If True, update mass depending on the dynamic measurement of force torque sensor.
            'updateMassWithMeasuredValue': 'Boolean', # Boolean
            # If True, then use barcode regions as unpickable regions for grasp sets.
            'useBarcodeUnpickableRegions': 'Boolean', # Boolean
            # If True, then will decrease target environment clearance for objects which are bigger than source container inner region.
            'useDecreaseTargetEnvClearanceBigObjects': 'Boolean', # Boolean
            # If True, then use destination goals even if they are in collision with the environment. Otherwise prune all dest goals that are in collision. During runtime, this will make sure that robot does not place a part in collision with other parts.
            'useDestGoalsInCollision': 'Boolean', # Boolean
            # to use dynamic goals generation to define position of the items in the destcontainername
            'useDynamicGoals': 'Boolean', # Boolean
            # To use queueing to speed up robot execution, 0 to not use queueing (use for debugging since it is simpler)
            'useExecutionQueueing': 'Int', # Int
            # Use KZ filter in FilterRobotTrajectory related functions.
            'useKZFilter': 'Boolean', # Boolean
            # If True, robot will wait for dest prohibited PLC signal to go to OFF at the grasp before starting the part transfer operation. This feature ensures that the robot doesn't do any interlocking in the middle that could have the part fly out of the hand, or maybe the robot doesn't have enough time to stop interlocking (if a big robot).
            'waitForDestProhibitedAtGrasp': 'Boolean', # Boolean
            # If True, then will wait for new vision detection results for waitForSupplyTimeout after the initial pick. If False, will quit the cycle with FinishedNoMoreTargets after robot is done picking up everything that is detected, robot will not wait for vision results. This parameter is used in cases where speed is important and robot shouldn't waste time trying to pickup the last targets in the container.
            'waitForDetectionAfterInitialPick': 'Boolean', # Boolean
            # Wait for all location to become unprohibited.
            'waitForLocationUnprohibited': 'Boolean', # Boolean
            # If True, robot will wait for source prohibited PLC signal to go to OFF after placing a part at the dest before going home or doing other recovery tasks. This feature ensures that the robot doesn't do any interlocking in the middle that could have the robot decelerating fast and stopping (especially for big robots). By default this is False.
            'waitForSourceProhibitedAtDest': 'Boolean', # Boolean
            # Wait for another slave's finish code to trigger this slave's computation
            'waitForStateSlaveTrigger': 'Boolean', # Boolean
            # sec, how long to wait before stopping the pick and place thread when container is not empty, but nothing is registered. possibly change this depending on the detection recognition time
            'waitForSupplyTimeout': 'Float', # Float
            # sec, how long to wait for the initial vision results to come before starting pick and place
            'waitUpdateStampTimeout': 'Float', # Float
            # Information on controlling ykk external devices
            'ykkControlInfo': 'YKKControlInfo', # YKKControlInfo
        },

        # Different parameters to configure binpicking pick and place cycle.
        'BinpickingParametersInput': {
            # If true plans out of camera occlusion when a pick failed or robot had to stop and retry a pick (i.e. piece lost).
            'alwaysPlanOutOfOcclusion': 'Int', # Int
            # Absolute current thresholds that should not exceed by joints
            'approachCurrentExceedThresholds': 'Float', # [Float]
            # Check if any of the currents exceed the difference between the start current values (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Do the check after torqueCheckStartTime.
            'approachCurrentExceedThresholdsDelta': 'Float', # [Float]
            # Absolute force and torque thresholds that should not exceed. Unit is N for force, Nm for torque. A negative value means the component is disabled.
            'approachForceTorqueExceedThresholds': 'Float', # [Float]
            # Check if any of the force and torque exceed the difference between the values at start (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Unit is N for force, Nm for torque. A negative value means the component is disabled. Do the check after torqueCheckStartTime.
            'approachForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm, When the tool is close to container walls at a grasp position, how much to offset the approach away from the walls.
            'approachOffsetFromWalls': 'Float', # Float
            # mm. The distance between the approach point P1 where the linear (slow) approach motion starts and the grasp point P2 where the robot stops and the gripper opens/closes to grasp the target item. 
            # 
            # It is appropriate to set the value at least as deep as the gripper's usual grasp depth (how far it moves into or towards the item to grasp it).
            # 
            # Setting a low value can cause A) collisions with noisy detections in the bin, and/or B) slower planning, as the final motions towards the grasp pose can be very constrained and sampling in joint space is inefficient. By default, the motion to the approach point P1 is sampled in joint space.
            # 
            # Common values are 30-100 mm. Setting a value that is too high can cause pick candidates to be discarded, as the approach motion may collide with e.g. container walls or be out of the robot's reach.
            'approachoffset': 'Float', # Float
            # axis-aligned bounding box (AABB) will be created based on specified bodies. collision of AABB is checked only during start plan. AABB aligns to world frame. AABB is created not to collide with AABB of manipulator's geometry but its clearance against manipulator is controlled to be close in order to avoid collision against dynamic contents
            'atStartPlanDynamicContentsNames': 'String', # [String]
            # If true, will clamp the position of the tool to a range between the start and goal of the transfer plan, this will force the tool not to go too up or down when doing the transfer. Use 'toolPosConstraintPaddingXYZ' to pad the XYZ of each dimension for the tool.
            'automaticToolPosConstraintWhenGrabbing': 'Boolean', # Boolean
            # Describes the barcode scanners and how the robot computes the barcode scanning motion.
            'barcodeScanningInfo': 'BarcodeScanningInfoInput', # BarcodeScanningInfoInput
            # If True, then when doing occlusion checking, use the correct grabbed object to do occlusion checking. If object is small and completely covered by gripper, this can be set to False to get performance boost.
            'cameraOcclusionApplyGrabbedState': 'Boolean', # Boolean
            # mm, offset is used in detection of camera occlusion by the robot
            'cameraOcclusionOffset': 'Float', # Float
            # s, time offset to expand camera start and end camera capture times for occlusion detection.
            'cameraOcclusionPaddingTime': 'Float', # Float
            # s, time offset to expand camera end of camera capture times for occlusion detection. This is useful when uncertainty of occluding time has asymmetry on start and end. This has priority over cameraOcclusionPaddingTime
            'cameraOcclusionPaddingTimeEnd': 'Float', # Float
            # s, time offset to expand camera start of camera capture times for occlusion detection. This is useful when uncertainty of occluding time has asymmetry on start and end. This has priority over cameraOcclusionPaddingTime
            'cameraOcclusionPaddingTimeStart': 'Float', # Float
            # If True, then when doing occlusion checking, consider all the visible but disabled links in the check. This can be cables and other movable objects. If invisible objects do not affect occlusion status, set this to False to get performance boost.
            'cameraOcclusionUseLinkVisibility': 'Boolean', # Boolean
            # A list of planning infos for cameras that are attached to the robot.
            'cameraPlanningInfos': 'CameraPlanningInfoInput', # [CameraPlanningInfoInput]
            # If True, then allow robot to place back the part in the source when barcode scanning fails.
            'canPlaceInSourceOnBarcodeScanFail': 'Boolean', # Boolean
            # If True, then allow robot to place back the part in the source when robot has to recover.
            'canPlaceInSourceOnRecover': 'Boolean', # Boolean
            # If set to True, then allows planning to set isPickable flags to False to any targets it picks up and knows that it should not pick up again unless they get updated. If False, does not allow changing the isPickable flag. Set to True by default.
            'canSetIsPickable': 'Boolean', # Boolean
            # If True, then checks occlusion with the source cameras at mid dest.
            'checkCameraOcclusionAtMidDest': 'Boolean', # Boolean
            # mm, distance threshold (in mm) for the max distance of "end effector translation"-"tool translation" along the vector oriented toward the container opening (usually +z).
            'checkForEndEffectorLowerThanGraspDist': 'Float', # Float
            # If True, then check to make sure the pick container is empty when the order cycle finishes. If it is not empty, the cycle will finish with error code 'FinishedPickContainerNotEmpty'.
            # 
            # If this is set to True, it overrides computePickContainerEmptyOnFinish.
            'checkPickContainerEmptyOnFinish': 'Boolean', # Boolean
            # If True, then check to make sure the place container is empty upon arrival. Non-empty place container will trigger the error code FinishedPlaceContainerNotEmpty.
            'checkPlaceContainerEmptyOnArrival': 'Boolean', # Boolean
            # If True, then computes (from vision data) if the pick container is empty or not after the final pick from the pick container. This will take an extra snapshot with the camera, so can reduce cycle time and slow down the move-out of the pick container. The result ('isContainerEmpty') is added to the log and the robot will continue.
            # 
            # To stop with an error code when the container is non-empty after picking, set checkPickContainerEmptyOnFinish to True. It overrides this parameter.
            'computePickContainerEmptyOnFinish': 'Boolean', # Boolean
            # Constrain a direction on the tool to be within a certain angle with respect to a global direction.
            'constraintToolInfo': 'ConstraintToolInfoInput', # ConstraintToolInfoInput
            # Info of precondition io checked before starting or resuming cycle
            'cyclePreconditionIOInfo': 'CyclePreconditionIOInfoInput', # CyclePreconditionIOInfoInput
            # Max number of times to repeat the destikparamnames, 0 means infinite repeat
            'cycledests': 'Int', # Int
            'debuglevel': 'Int', # Int
            # If True, will delete all dynamic objects after finishing cycle (for cleaning up)
            'deleteDynamicObjectsAfterFinish': 'String', # String
            # 0: do not delete target after it is picked up until the next vision detection update changes the targets. 1: delete the target after it is picked up. Setting this to 1 allows the robot to pick up previously overlapped parts without waiting for a vision update, but it is also more dangerous since there can be parts below the picked up target that were previously getting occluded, and removing the picked up target might wrongly tell the robot that the below region is free space. If 2, then only consider the delete targets during grabbing the part, but still consider them during approach.
            'deleteTargetFromSourceContainer': 'Int', # Int
            # If True, then delete the target as soon as it is placed in the destination. This simulates machines or drop off locations which take the part as soon as the robot releases them.
            'deleteTargetWhenPlacedInDest': 'String', # String
            # If True, will delete the current targets after every pick and force re-detection of the parts. Used when robot has to stop and rescan every frame.
            'deleteTargetsEveryCycleSlowMode': 'Boolean', # Boolean
            # If True, when the piece is lost and robot has to recover, will remove the all detected targets from the scene and wait for new ones to come.
            'deleteTargetsOnPieceLost': 'Boolean', # Boolean
            # If True, during any recovery because of a failure to pick or move the robot, will remove the all detected targets from the scene and wait for new ones to come.
            'deleteTargetsOnRecovery': 'Boolean', # Boolean
            # If True and robot is initially occluding the container, then delete all the targets and wait for vision to repopulate
            'deletetargetonocclusion': 'Boolean', # Boolean
            # mm, When part is close to walls, how much to depart to get it out of the wall.
            'departOffsetFromWalls': 'Float', # Float
            # mm/s^2
            'destApproachAccel': 'Float', # Float
            # This array is used to compute scaling multiplier that scales dest approach acceleration and deceleration from target mass. Computed scaling multiplier will be saturated by 1.0. This is useful when mass validation is enabled and there is difficulty on computing accurate inertial force compensation.
            'destApproachAccelDecelScaleMultOnTargetMass': 'DestApproachAccelDecelScaleMultOnTargetMassInput', # [DestApproachAccelDecelScaleMultOnTargetMassInput]
            # Absolute current thresholds that should not exceed by joints during destination approach
            'destApproachCurrentExceedThresholds': 'Float', # [Float]
            # Check if any of the currents exceed the difference between the start current thresholds (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Do the check after torqueCheckStartTime.
            'destApproachCurrentExceedThresholdsDelta': 'Float', # [Float]
            # mm/s^2,
            'destApproachDecel': 'Float', # Float
            # Absolute force and torque thresholds that should not exceed during destination approach. Unit is N for force, Nm for torque. A negative value means the component is disabled.
            'destApproachForceTorqueExceedThresholds': 'Float', # [Float]
            # Check if any of the force and torque exceed the difference between the values at start (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Unit is N for force, Nm for torque. A negative value means the component is disabled. Do the check after torqueCheckStartTime.
            'destApproachForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm/s
            'destApproachSpeed': 'Float', # Float
            # destination approach speed mult on unknown-sized target. has to be greater than 0.01, less than or equal to 1.0
            'destApproachSpeedMultOnUnknownSize': 'Float', # Float
            # Describes the barcode scanning on the dest
            'destBarcodeScanningInfo': 'DestBarcodeScanningInfoInput', # DestBarcodeScanningInfoInput
            # mm/s^2,
            'destDepartAccel': 'Float', # Float
            # mm/s^2,
            'destDepartDecel': 'Float', # Float
            # If true then will attempt to merge dest depart with future approach trajectory to speed up robot logic
            'destDepartFutureCycleMerge': 'Boolean', # Boolean
            # mm/s
            'destDepartSpeed': 'Float', # Float
            # destination depart speed multiplier on unknown-sized target. has to be greater than 0.01, less than or equal to 1.0
            'destDepartSpeedMultOnUnknownSize': 'Float', # Float
            # deg, enabled if destcoordtype==target. an angle is used to filter destinations such that they only allow targets in the source container that are oriented around the container's up axis. The minimum rotation angle between the source and destination target poses (once they are normalized by the in-plane rotation) is thresholded by this value. if less than 0, then invalid. angle in degrees.
            'destFilterByTargetOrientationThresh': 'Float', # Float
            # Parameters used for computing target placement when 'destCoordType' is 'targetAABBAlignIk'
            'destTargetAABBAlignIkParameters': 'DestTargetAABBAlignIkParametersInput', # DestTargetAABBAlignIkParametersInput
            # Parameters used when placing a part at the destination when 'destCoordType' is targetAnyBottomFace.
            'destTargetAnyBottomFaceRotationParameters': 'DestTargetAnyBottomFaceRotationParametersInput', # DestTargetAnyBottomFaceRotationParametersInput
            # Parameters used when placing targets at the destination with 'destCoordType' being 'targetCorner'.
            'destTargetCornerParameters': 'DestTargetCornerParametersInput', # DestTargetCornerParametersInput
            # Parameters used when placing targets at the destination with 'destCoordType' being 'targetStack'.
            'destTargetStackParameters': 'DestTargetStackParametersInput', # DestTargetStackParametersInput
            # mm, if a target at the destination is in collision, then can jitter by this distance so that a new collision-free goal could be used instead. This is used when a destination point cloud is used to pack items.
            'destTargetValidationJitterDist': 'Float', # Float
            # mm (x,y,z)
            'destapproachoffsetdir': 'Float', # [Float]
            # if True then destapproachoffsetdir is in the tool coordinate system
            'destapproachoffsetintool': 'Boolean', # Boolean
            'destcontainername': 'String', # String
            # Coordinate system type of the destination. can be one of:
            # - 'tool' specifying the current tool,
            # - 'toolzntarget' specifying the point of the tool projected along the -z axis until the target boundary,
            # - 'target' specifying the original target coordinate system, or
            # - 'targetbottom' that offsets the target so its grasped bottom aligned with the ikparam, or
            # - 'targetAnyBottomFace' specifying that robot should put the target on its bottom face regardless of which grasp it makes. The center is aligned with the center of the target bounding box.
            # - 'targetAnyBottomFaceAlignedX' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the X axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceAlignedY' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the Y axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceXIsLongAxis' specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the longest side of the target with the X-axis of the goal. Will align so that the target X axis is always toward the X of the ikparam. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetCorner' - Align any corner of the target with the 6D coordinate system.
            # - 'targetStack' - stack targets on top of previously placed targets. Prioritize placement on lower stacks.
            # - 'targetAnyBottomBarCodeFace' - specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the registered known barcode faces to the barcode reader. if there are no known barcode faces, does the same as targetAnyBottomFaceXIsLongAxis. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetAABBAlignIk' - Align target's AABB with the dest ikparam
            'destcoordtype': 'String', # String
            # mm (x,y,z)
            'destdepartoffsetdir': 'Float', # [Float]
            # If true then destination depart offset is computed in the tool coordinate system
            'destdepartoffsetintool': 'Boolean', # Boolean
            # If > 0, then the detector come give old cached detection results back even though the sensor time stamp is updated. So this is the max time between a sensor timestamp and the result returned for that timestamp. Most detectors have this as 0 since they take only one sensor snapshot. Some detectors that need to do sensor fusion can be giving out old cached results.
            'detectionResultsMaxCacheTime': 'Float', # Float
            # If True, then any bodies that have been placed before to that location will be disabled and ignored during planning. This is used when a sensor is re-sensing the bodies and therefore will produce its own detected_ versions of the bodies.
            'disablePlacedTargetsInPickLocationWhenPlanning': 'Boolean', # Boolean
            # Parameters for measuring the height of a target object with a 1D distance sensor. Setting up these parameters will send timed IO values as the robot trajectory is executed.
            'distanceMeasurementInfo': 'DistanceMeasurementInfoInput', # DistanceMeasurementInfoInput
            # If False, the robot may try to shortcut the departing trajectory after grabbing a part to improve performance. If the clearance with other parts at grasping points is tight, this should be set to True.
            'doAccurateGraspDepart': 'Boolean', # Boolean
            # This parameter is only considered if isStopOnPieceLost is True. If this parameter is True and PieceLost occurs inside the source container, recovery is attempted. If PieceLost occurs outside the source container, the robot stops without recovering (since it is unclear where the piece fell).
            'doAutoRecoveryOnPieceLost': 'Boolean', # Boolean
            # If True, will try to recover after a robot execution error occurs.
            'doAutoRecoveryOnRobotExecutionError': 'Boolean', # Boolean
            # Parameters to define how to drop object to the destination.
            'dropInDestInfo': 'DropInDestInfoInput', # DropInDestInfoInput
            # Coordinate system type of the destination used for drop off. See description of destcoordtype for possible options
            'dropOffDestCoordType': 'String', # String
            # [0,1], Speed multiplier when robot is dropping a part off.
            'dropOffSpeedMult': 'Float', # Float
            # For destinations with isDropInSource set to True, try to lower the drop point so that it is [dropOffsetFromCollision] away from the top of the parts in the pick container.
            'dropOffsetFromCollision': 'Float', # Float
            # Multiplier for the target aabb to determine if safely dropped in dest container. the higher the value, the more safety there is in accidentally thinking that the part was dropped inside the container.
            'dropTargetInDestContainerBoxMult': 'Float', # Float
            # If target is inside the XY dest constraints, this controls what is the max height of the target (in terms of its multiples) where it is ok to drop the target because of torque limits/piece lost errors. in other words, the amount of z extents that could be outside of the dest and still success will be declared. The lower the value, the more conservative it is.
            'dropTargetInDestContainerZSafetyMult': 'Float', # Float
            # Multiplier for the target aabb to determine if safely dropped in source container. the higher the value, the more safety there is in accidentally thinking that the part was dropped inside the container. If robot is getting FinishedDropTargetFailure while object is still in container, then reduce this value.
            'dropTargetInSourceContainerBoxMult': 'Float', # Float
            # mm, maximum distance from the grasp trajectory start point to determine if the part safely dropped inside of the source container. If 'isStopOnPieceLost' is False, then recover regardless this parameter; if 'isStopOnPieceLost' is True and the part safely dropped then try to recover from PieceLost error.
            'dropTargetMaxDistanceThresold': 'Float', # Float
            # mm, maximum XY distance from the grasp trajectory start point to determine if the part safely dropped inside of the source container. If 'isStopOnPieceLost' is False, then recover regardless this parameter; if 'isStopOnPieceLost' is True and the part safely dropped then try to recover from PieceLost error.
            'dropTargetMaxDistanceXYThreshold': 'Float', # Float
            # Dynamic goals generator parameters. Used only if useDynamicGoals is True
            'dynamicGoalsGeneratorParameters': 'DynamicGoalsConfigInput', # DynamicGoalsConfigInput
            # deg/sec, robot is assumed to reach the commanded position when sum of absolute values of actual joint velocities is lower than this threshold. The smaller the value, the more accurate the robot will be, but will be slower.
            'encoderConvergenceSpeedThresh': 'Float', # Float
            'executethread': 'Boolean', # Boolean
            # The parameter is used to control how fast the robot decelerates when pausing due to an interlock or PieceLost problem.
            'executionConnectingTrajDecelMult': 'Float', # Float
            # The parameter is used to control how fast the robot moves backward and then stops when reversing due to torque limit error or position tracking error.
            'executionConnectingTrajReverseMult': 'Float', # Float
            # the parameter is used to make robot trajectory while grabbing not grabbing  a target smooth. Default is 1.0, a smaller value makes the trajectory smoother, but the trajectory is rejected more often and can possibly collide with obstacles.
            'executionFilterFactor': 'Float', # Float
            # the parameter is used to make robot trajectory while grabbing a target smooth. Default is 0.4, a smaller value makes the trajectory smoother, but the trajectory is rejected more often and can possibly collide with obstacles.
            'executionFilterFactorWhenGrabbing': 'Float', # Float
            # mm, recovery distance the robot tool should move in reverse of the trajectory from the detected collision/error position.
            'executionReverseRecoveryDistance': 'Float', # Float
            # Parameters for enabling and setting up execution verification that allows the robot to quickly stop when it is about to hit a part that is moved. This function is *highly recommend* to be used.
            'executionVerificationInfo': 'ExecutionVerificationInfoInput', # ExecutionVerificationInfoInput
            # If True, then allows to reset needContainer signals earlier while processing the last part.
            'fastNeedContainerReset': 'Boolean', # Boolean
            # deg/mm, how many deg/mm each joint has to be from the commanded position to declare that it is reached. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDefaultWorkspaceThreshold.
            'feedbackDefaultJointThreshold': 'Float', # Float
            # mm, how many mm the real tooltip position has to be from the commanded position to declare that it is reached. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDestJointThreshold.
            'feedbackDefaultWorkspaceThreshold': 'Float', # Float
            # deg/mm, how many deg/mm each joint has to be from the commanded dest (release) position to declare that it is in at the destination. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDestWorkspaceThreshold.
            'feedbackDestJointThreshold': 'Float', # Float
            # mm, how many mm the real tooltip position has to be from the commanded dest (release) position to declare that it is in at the destination. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackDestJointThreshold.
            'feedbackDestWorkspaceThreshold': 'Float', # Float
            # deg/mm, how many deg/mm each joint has to be from the commanded grasp joint values to declare that it is at the grasp. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackGraspWorkspaceThreshold.
            'feedbackGraspJointThreshold': 'Float', # Float
            # mm, how many mm the real tooltip position has to be from commanded grasp position to declare that it is at the grasp. The smaller the value, the more accurate the robot will be, but will be slower. Used with feedbackGraspJointThreshold.
            'feedbackGraspWorkspaceThreshold': 'Float', # Float
            # The mode to compute the final plan. if empty, do not do any final plan for each cycle, the robot stops after the dest depart. If 'cameraocclusion', then make sure robot is away from the camera occlusion.
            # If 'config', then plan for robot 'finalPlan' only if the robot is occluding the camera at the source.
            # If 'configIgnoreOcclusion', then always plan to robot 'finalPlan' position.
            'finalPlanMode': 'String', # String
            # the time to wait after a final plan, usually to allow system to rescan the environment
            'finalPlanWaitTime': 'Float', # Float
            # If not None, forces particular bodies to be picked up. forceTargetNamePattern has to match to targetnamepattern. initially introduced for picking from the buffer region. CANNOT be used with forcetargetname.
            'forceTargetNamePattern': 'String', # String
            # if True, then will only pick up targets that match exactly with the specified target uri
            'forceTargetUriCheck': 'Boolean', # Boolean
            # Parameters for state estimation features based on force torque sensor
            'forceTorqueBasedEstimatorParameters': 'ForceTorqueBasedEstimatorParametersInput', # ForceTorqueBasedEstimatorParametersInput
            # If not None, forces only one particular body to be picked up. forcetargetname has to match targetnamepattern
            'forcetargetname': 'String', # String
            # Project-Id-Version: PACKAGE VERSION
            # Report-Msgid-Bugs-To: 
            # PO-Revision-Date: 2015-07-17 11:57+0900
            # Last-Translator: Automatically generated
            # Language-Team: none
            # Language: en_US
            # MIME-Version: 1.0
            # Content-Type: text/plain; charset=UTF-8
            # Content-Transfer-Encoding: 8bit
            # Plural-Forms: nplurals=2; plural=(n != 1);
            'grabbedTargetValidationSignalsInfo': 'GrabbedTargetValidationSignalsInfoInput', # GrabbedTargetValidationSignalsInfoInput
            # mm/s^2
            'graspApproachAccel': 'Float', # Float
            # Parameters to move away from neighboring walls on departing. when these parameters are used to approaching, it computes movement that gets close to walls from the given distance.
            'graspApproachCollisionWallOffsetParameters': 'CollisionWallOffsetParametersInput', # CollisionWallOffsetParametersInput
            # mm/s^2
            'graspApproachDecel': 'Float', # Float
            # mm/s
            'graspApproachSpeed': 'Float', # Float
            # If True then always depart along graspDepartOffsetDir so that the bottom of the grabbed target is above any of the nearby obstacles within neighTargetThresh. It starts from graspDepartOffsetDir and adds more along its direction, so in the worst case, graspDepartOffsetDir will always be set.
            'graspDepartAboveNearbyObstacles': 'Boolean', # Boolean
            # mm, If graspDepartAboveNearbyObstacles is True, then always depart so that the bottom of the grabbed target is above any of the nearby obstacles within neighTargetThresh. From that point, graspDepartOffsetDir will be added to determine the final grasp depart offset.
            'graspDepartAboveNearbyObstaclesMaxDist': 'Float', # Float
            # mm/s^2,
            'graspDepartAccel': 'Float', # Float
            # This array is used to compute scaling multiplier that scales grasp depart acceleration and deceleration from target mass. Computed scaling multiplier will be saturated by 1.0. This is useful when mass validation is enabled and there is difficulty on computing accurate inertial force compensation.
            'graspDepartAccelDecelScaleMultOnTargetMass': 'GraspDepartAccelDecelScaleMultOnTargetMassInput', # [GraspDepartAccelDecelScaleMultOnTargetMassInput]
            # Parameters to move away from neighboring walls on departing. when these parameters are used to approaching, it computes movement that gets close to walls from the given distance.
            'graspDepartCollisionWallOffsetParameters': 'CollisionWallOffsetParametersInput', # CollisionWallOffsetParametersInput
            # Absolute joint motor current thresholds that should not be exceeded. If exceeded, then will return torque error
            'graspDepartCurrentExceedThresholds': 'Float', # [Float]
            # Check if difference between the start joint motor current values (at torqueCheckStartTime) and the current values exceed these thresholds. If they do, then will return torque error.
            'graspDepartCurrentExceedThresholdsDelta': 'Float', # [Float]
            # mm/s^2,
            'graspDepartDecel': 'Float', # Float
            # Absolute force and torque thresholds that should not be exceeded during grasp depart. Unit is N for force, Nm for torque.
            'graspDepartForceTorqueExceedThresholds': 'Float', # [Float]
            # Check if any of the force and torque exceed the difference between the values at start (at torqueCheckStartTime) and the current ones. If they do, then will return torque error. Unit is N for force, Nm for torque.
            'graspDepartForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm (x,y,z)
            'graspDepartOffsetDir': 'Float', # [Float]
            # mm, max distance to reverse the trajectory from the detected collision/error position when got torque error during grasp depart.
            'graspDepartReverseRecoveryDistance': 'Float', # Float
            # mm/s
            'graspDepartSpeed': 'Float', # Float
            # degrees, an angle is used to filter grasps such that they only allow approaches in the source container that are oriented around the container's up axis given this threshold. if less than 0, then invalid.
            'graspFilterByApproachOrientationThresh': 'Float', # Float
            # Multipliers for various grasp-goal pair costs.
            'graspGoalPairCostMultipliers': 'GraspGoalPairCostMultipliersInput', # GraspGoalPairCostMultipliersInput
            # mm, distance to penetrate when robot is grasping a tilted part
            'graspPenetrationOnTiltDist': 'Float', # Float
            # Multipliers for various grasp priority values.
            'graspPriorityMultipliers': 'GraspPriorityMultipliersInput', # GraspPriorityMultipliersInput
            # max time to spend on computing one grasp for one target. 0 means infinite
            'graspTimeLimit': 'Float', # Float
            # Name of the grasp set to use for picking
            'graspsetname': 'String', # String
            # If true, will ignore any dynamic obstacles when departing after grasping. By default this is False since it is safer for the parts that the robot will be picking up, valid grasps will be harder to find though.
            'ignoreDynamicObstaclesInGraspDepart': 'Boolean', # Boolean
            # If set to True, then can pick up any targets that match with targetnamepattern regardless of their isPickable flags. Set to False by default.
            'ignoreIsPickable': 'Boolean', # Boolean
            # If > 0, the timelimit in seconds to compute IK solutions for the highest priority targets. If IK solutions are computed for them, then start the grasp goal pairing right away to plan for it.
            'ikTimeLimitForHighestPriority': 'Float', # Float
            # mm, when the IK solution requires less DOF than the number of joints of the robot, have to sample the rest of the robot's prismatic axes with this sampling step.
            'iksolverfreeincprismatic': 'Float', # Float
            # rad, when the IK solution requires less DOF than the number of joints of the robot, have to sample the rest of the robot's revolute axes with this sampling step. defines the granularity of the free joint search in radians, the smaller the value, the longer planning takes. sometimes we need to decrease this number to allow ik to succeed. for example, when the free joint is the base joint, a small angle results in big displacement in the end effector.
            'iksolverfreeincrev': 'Float', # Float
            # the timelimit in seconds to compute IK solutions until system starts the planning. If no IK solution are computed by this time, then system will wait until at least one pair is computed, or everything is exhausted.
            'iktimelimit': 'Float', # Float
            # Specifies how to check condition of detected targets at the beginning of cycle. Number of detected targets and scanned barcode on detection time can be checked.
            'initialDetectionValidationInfo': 'InitialDetectionValidationInfoInput', # InitialDetectionValidationInfoInput
            # If True, then moves the robot out of camera occlusion before starting the cycle.
            'initialMoveRobotOufOfCameraOcclusion': 'Boolean', # Boolean
            # Properties about drop off location
            'inspectionFailDropOffInfo': 'InspectionFailDropOffInfoInput', # InspectionFailDropOffInfoInput
            # List of information specifying conditions for when to do an intermediate cycle for target re-grabbing. Conditions for intermediate cycle can very, which is why there is a list of them.
            'intermediateCycles': 'IntermediateCycleInfoInput', # [IntermediateCycleInfoInput]
            # If True stops the cycle execution if the robot has controller error and raise an error
            'isStopOnControllerError': 'Boolean', # Boolean
            # If True stops the cycle execution if the gripper fails to move fingers to a designated position
            'isStopOnGripperPositionNotReached': 'Boolean', # Boolean
            # If True stops the cycle execution if mass/center of mass validation reports mismatch. If False, cycle continues after mass mismatch only when robot can safely drop back an item to source.
            'isStopOnObjectMassPropertiesMismatch': 'Boolean', # Boolean
            # If True and doAutoRecoveryOnPieceLost is False, stops the cycle execution if the piece is lost and raises an error. If doAutoRecoveryOnPieceLost is true and the piece was lost inside the source container (= the part most likely fell back inside), cycle execution continues.
            'isStopOnPieceLost': 'Boolean', # Boolean
            # If True, stops the cycle execution if a robot execution error occurs and raise an error
            'isStopOnRobotExecutionError': 'Boolean', # Boolean
            # If True stops the cycle execution if the torque limits exceeded and raise an error
            'isStopOnTorqueLimitsError': 'Boolean', # Boolean
            # If True, then stops the cycle execution if the torque limits exceeded outside of the source container. This usually when in mid-air, or at the destination, or somewhere during an intermediate cycle.
            'isStopOnTorqueLimitsErrorOutsidePickLocation': 'Boolean', # Boolean
            # Names of ITL programs to run every cycle on specific events
            'itlProgramNamesOnEvent': 'ITLExecutionInfoInput', # [ITLExecutionInfoInput]
            # Parameters dealing with jittering the robot out of collisions.
            'jittererParameters': 'JittererParametersInput', # JittererParametersInput
            # Parameters for configuring just-in-time tool change planning feature
            'justInTimeToolChangePlanning': 'JustInTimeToolChangePlanningParametersInput', # JustInTimeToolChangePlanningParametersInput
            # Describes the label printer and how the robot computes the label placing motion.
            'labelPlacingInfo': 'LabelPlacingInfoInput', # LabelPlacingInfoInput
            # mm, When using 5D destination for target, this describes the axis in the local target coordinate system that should align with the global direction from the ikparam.
            'localTargetDir': 'Float', # [Float]
            # mm, how much to pad the external location collision region for the robot to pause before interlock occurs.
            'locationInterlockSafetyXYZ': 'Float', # [Float]
            # seconds, if the workpiece failed to be picked up, then continue ignoring the workpiece for this many seconds.
            'logFailedTargetTimeout': 'Float', # Float
            # if > 0, then will only accept dest transfer plans (from source to dest container) that are faster than this limit.
            'maxAcceptedDestPlanTrajTime': 'Float', # Float
            # if > 0, then will only accept finish plans (for dest to finish) that are faster than this limit.
            'maxAcceptedFinishTrajTime': 'Float', # Float
            # Out of this many camera ik params that have ik solutions, will pick the one that gives solutions closest to the corresponding approach/depart configs.
            'maxConsideredCameraIkSolutions': 'Int', # Int
            # sometimes the dest trajectory planning can fail because of a bad pair of grasps and targets. this controls how many failures are tolerated before system fails.
            'maxDestFailuresForTargetGrasp': 'Int', # Int
            # The maximum IK solutions to have per destination before system gives up and tries something else. If 0, then compute all solutions
            'maxDestIkSolutions': 'Int', # Int
            # max number of times final plan can be ignored
            'maxFinalPlanIgnoreCount': 'Int', # Int
            # minimum number of targets to have before can start to ignore the final plan mode
            'maxFinalPlanIgnoreMinTargets': 'Int', # Int
            # The maximum IK solutions to have per target before system gives up and tries something else. If 0, then compute all solutions
            'maxGraspIkSolutions': 'Int', # Int
            # max grasp solutions allowed per grasp. If 0, then infinite
            'maxGraspIkSolutionsPerGrasp': 'Int', # Int
            # sometimes the grasp approach/depart can fail if the target is still in collision with other objects, in that if the number of total failures for the target exceeds this threshold, should invalidate the target from consideration.
            'maxLinearFailuresForTarget': 'Int', # Int
            # sometimes the grasp approach/depart can fail if the target is still in collision with other objects, in that case all grasp departs will fail
            'maxLinearFailuresForTargetGrasp': 'Int', # Int
            # if robot had cycle failures for amount of times in a row, then stop cycle
            'maxNumConsecutiveCycleFailures': 'Int', # Int
            # if robot had PieceLost for amount of times in a row, then stop cycle
            'maxNumConsecutivePieceLost': 'Int', # Int
            # if robot had execution verification failures for amount of times in a row, then stop cycle
            'maxNumConsecutiveVerificationFailures': 'Int', # Int
            # max number of planning iterations to fail until the system gives up
            'maxNumPlanningFailedIterations': 'Int', # Int
            # The max cycles to queue ahead for planning
            'maxPlanningCyclesToQueue': 'Int', # Int
            # sometimes the start trajectory planning can fail because the target itself is in a corner or underneath other parts, and it shouldn't be picked up this cycle. This controls how many times a target failed to plan the start trajectory and then invalidates the target.
            'maxStartFailuresForTarget': 'Int', # Int
            # sometimes the start trajectory planning can fail because of a bad pair of grasps and targets. this controls how many failures are tolerated before system fails.
            'maxStartFailuresForTargetGrasp': 'Int', # Int
            # The amount of countdown time (in seconds.) until the target, which previously failed, is clear from a penalty. This parameter is used in conjunction with targetPriorityMultipliers/failureCountdownMult.
            'maxTimeForDecrease': 'Float', # Float
            # the percentage of current to limit from maximum when grasp approaching. if 1, then disable
            'maxTorqueMultForApproach': 'Float', # Float
            # the percentage of current to limit from max when dest approaching. if 1, then disable
            'maxTorqueMultForDestApproach': 'Float', # Float
            # sometimes transferring the target can fail because the target itself is in a corner or underneath other parts, and it shouldn't be picked up this cycle. This counts how many times a target failed to plan the tranfer trajectory and then invalidates the target.
            'maxTransferFailuresForTarget': 'Int', # Int
            # coordinate system type of the mid-destination controlled by [midDestIkparamNames]. can be one of:
            #  - 'tool' specifying the current tool,
            # - 'target' specifying the original target coordinate system.
            'midDestCoordType': 'String', # String
            # Names of the mid dest params to go to
            'midDestIkparamNames': 'String', # [String]
            # seconds, The speed to pass through the mid-dest.
            'midDestPassthroughVelocity': 'Float', # Float
            # seconds, The time to wait at the middest
            'midDestWaitTime': 'Float', # Float
            # The minimum accepted combined transferSpeedMult. Reject everything else. Some grasps might have really slow speeds, this forces the robot to reject those grasps
            'minAcceptedTransferSpeedMult': 'Float', # Float
            # controls the percentage of the grasp depart trajectory that the robot needs to minimally achieve in order to move on. This would be used when grasp depart has to be big sometimes, but not always. By default it is 1. The lower value means the robot will end the depart earlier and start the transfer motion.
            'minGraspDepartCompleteRatio': 'Float', # Float
            # Specifying the minimum transferSpeedMult ratio in [0,1]. If the resolved transferSpeedMult is less than this, but greater than minAcceptedTransferSpeedMult, then set the transferSpeedMult to this value. When there are multiple grasps with different transferSpeedMult
            'minTransferSpeedMult': 'Float', # Float
            # parameters that are used with planning for minimum viable region
            'minViableRegionPlanParameters': 'MinViableRegionPlanParametersInput', # MinViableRegionPlanParametersInput
            # Parameters used for linear movement like grasp approach, grasp depart, etc.
            'moveStraightParams': 'MoveStraightParametersInput', # MoveStraightParametersInput
            # Parameters used for linear movement when have to do dynamic replanning during execution. The parameters should be more loose than moveStraightParameters since the robot might be very close to thresholds and fail.
            'moveStraightParamsOnReplan': 'MoveStraightParametersInput', # MoveStraightParametersInput
            # if True then will use 'midDestIkparamNames' to move to middest
            'moveToMidDest': 'Boolean', # Boolean
            # If 1, then robot will place a part in the destination after picking up. If false, then robot will stop the cycle after picking up.
            'movetodestination': 'Int', # Int
            # mm. A threshold to avoid picking multiple items close to one another.
            # 
            # When using the same vision result to pick multiple items, objects which are closer to previous target objects than this threshold will not be considered. This means that all objects in a radius neighTargetThresh around picks will be discarded from the grasp candidates until a newer detection result is received. The threshold represents the area in which objects may have been moved by the picking actions, so that the vision result would not be reliable anymore.
            # 
            # The distance is calculated between the object poses. It does not consider the object's mesh or shape.
            # 
            # This parameter should be chosen depending on the type of object, the gripper and the vision system. For large object size and detection noise, a larger value will be appropriate. A reasonable value may be 0.5-2x the object's extent (the maximum dimension).
            'neighTargetThresh': 'Float', # Float
            # mm. A threshold to avoid picking targets close to another target whose pick-place execution resulted in a torque limit error. 
            # 
            # See the neighTargetThresh parameter for a detailed explanation. This parameter works the same way, but it only applies when the pick-place execution caused a torque limit error.
            # 
            # A reasonable value may be 1-3x the object's extent.
            # 
            # This parameter has no effect if it is smaller than neighTargetThresh.
            'neighTargetThreshForTorqueError': 'Float', # Float
            # when a slave finishes the planning of the order cycle, will use this uri to notify another slave of the current state of the environment. Format is tcp://localhost:11000/?slaverequestid=XXX&username=YYY&otheroption&ZZZ
            'notifyStateSlaveZMQUri': 'String', # String
            # The number of parts to place in the destination. picked up failures do not count. If 0, then will continue going until cycledests and destikparamnames have been all exhausted. Otherwise will only pick up these parts and stop the pick and place loop.
            'numTargetsToPlace': 'Int', # Int
            # Number of threads to be used for planning
            'numThreads': 'Int', # Int
            # Parameters to check object mass properties. If enabled, object mass properties will be checked dynamically while executing pick and place cycle. Force/Torque sensor is required to use this feature.
            'objectMassPropertiesCheckingInfo': 'ObjectMassPropertiesCheckingInfoInput', # ObjectMassPropertiesCheckingInfoInput
            # Describes some binpicking parameters which have to be applied for the specific objectType.
            'objectTypeDynamicParametersMap': 'ObjectTypeDynamicParametersInput', # ObjectTypeDynamicParametersInput
            # Specify a default pack formation name when running the Order Cycle.
            'orderPackFormationName': 'String', # String
            # Parameters controlling the packing behaviors and algorithms for startPackFormationComputation command.
            'packFormationParameters': 'PackFormationParametersInput', # PackFormationParametersInput
            # Parameters for robot path planning.
            'pathPlannerParameters': 'PathPlannerParametersInput', # PathPlannerParametersInput
            # Describes the pick location and properties about it to initialize the cycle.
            'pickLocationInfo': 'PickLocationInfoInput', # PickLocationInfoInput
            # Describes the place locations and properties about them to initialize the cycle.
            'placeLocationInfos': 'PlaceLocationInfoInput', # [PlaceLocationInfoInput]
            # mm, x,y,z. How much padding the robot needs to consider for lastly placed target.
            'placedTargetExtraPadding': 'Float', # [Float]
            # The prefix of all placed target names during the cycle
            'placedTargetPrefix': 'String', # String
            # What translation (distance) range target remains after placing to the destination. mm, x,y,z. For example, this is useful when the destination is a conveyor and the conveyor will move placed target for certain range and need to protect target on that range.
            'placedTargetRemainingTranslationRange': 'Float', # [Float]
            # Controls how planning for destinations work. Can control which planning stages get planned for so that user can test various aspects of the plan.
            # - None - then do not plan for any dest, and stop after the robot does a grasp depart
            # - All - plan for everything
            'planToDestMode': 'String', # String
            # Controls the scheduling of internal grasp/dest planning into worker threads.
            'planningSchedulingMode': 'String', # String
            # Post cycle execution and conveyor parameters.
            'postCycleExecution': 'PostCycleExecutionConfigurationsInput', # PostCycleExecutionConfigurationsInput
            # Describes where to place predicted target before detection results.
            'predictDetectionInfo': 'PredictDetectionInfoInput', # PredictDetectionInfoInput
            # Info structure for maintaining grasp parameters for random box picking. Used when picking up randomized boxes (targetIsRandomBox is True).
            'randomBoxInfo': 'RandomBoxInfoInput', # RandomBoxInfoInput
            # Speed multiplier when recovering from torque or piece-lost errors.
            'recoverySpeedMult': 'Float', # Float
            # Configuration of restricting label orientation of placed items. labelerDirection has to be defined for restriction to be applied.
            'restrictLabelOrientationInfo': 'RestrictLabelOrientationInfoInput', # RestrictLabelOrientationInfoInput
            # mm or degrees. Need to specify values for all joints.
            'robotCycleStartPosition': 'Float', # [Float]
            # mm or degrees. Need to specify values for all joints.
            'robotFinishPosition': 'Float', # [Float]
            # mm/s^2,
            'robotRecoveryDepartAccel': 'Float', # Float
            # mm (x,y,z)
            'robotRecoveryDepartOffsetDir': 'Float', # [Float]
            # If true then robotRecoveryination depart offset is computed in the tool coordinate system
            'robotRecoveryDepartOffsetInTool': 'Boolean', # Boolean
            # mm/s
            'robotRecoveryDepartSpeed': 'Float', # Float
            # mm or degrees. Need to specify values for all joints.
            'robotRecoveryPosition': 'Float', # [Float]
            # Save trajectory logs which will be concatenated and scene file to reproduce the results. When this feature is enabled, the system can slow down a little since it is storing data.
            'saveConcatenateTrajectoryLog': 'Boolean', # Boolean
            # 0 or 1
            'saveDynamicGoalGeneratorState': 'Int', # Int
            # If set to 1 and logging level is info or higher, saves state of the _dynamicGoalsGenerator to the disk.
            'saveDynamicGoalGeneratorStateFailed': 'Int', # Int
            # If logging level is info or higher, saves state of the _dynamicGoalsGenerator to the disk if pack following switched to random packing mode.
            'saveDynamicGoalGeneratorStateOnRandomMode': 'Boolean', # Boolean
            # if 1, then saves the environment state for every plan.
            'saveEnvState': 'Int', # Int
            # Save logs related to filtering in planning. When this feature is enabled, the system can slow down a little since it is storing data.
            'saveFilterTrajectoryLog': 'Boolean', # Boolean
            # if true, then saves the environment whenever recovery occurs while robot is grabbing (GrabRecovery).
            'saveGrabRecoveryScene': 'Boolean', # Boolean
            # If 1, saves the packing state when computing pack formation.
            'savePackingState': 'Int', # Int
            # if true, then saves the environment whenever recovery from piece lost or other cancellation occurs.
            'saveRecoveryScene': 'Boolean', # Boolean
            # Save logs from each trajectory the robot executes with data including the encoder values of the robot, the current/torque values, and specific IO signal values. When this feature is enabled, the system can slow down a little since it is storing data. Some UI functions that display data need this feature to be enabled so that the correct data can be displayed.
            'saveRobotFeedbackLog': 'Boolean', # Boolean
            # if 1, then saves the environment state showing robot execution verification failure.
            'saveVerificationScene': 'Int', # Int
            # 0 or 1
            'savetrajectorylog': 'Int', # Int
            # a dictionary specifying what kind of destinations can be skipped during destination validation process
            'skipCollidingDestsInfo': 'SkipCollidingDestsInfoInput', # SkipCollidingDestsInfoInput
            # Parameters dealing with getting smoother paths for the robot planning.
            'smootherParameters': 'SmoothingParametersInput', # SmoothingParametersInput
            # value multiplied by the rotational angle between the source and dest target orientations and added to the final cost of considering the particular grasp/goal pair. 0 if doesn't matter. By default it is 0 so not to penalize the orientations
            'sourceDestTargetOrientationPenalty': 'Float', # Float
            # Dynamic goals generator parameters. Used only if useDynamicGoals is True
            'sourceDynamicGoalsGeneratorParametersOverwrite': 'DynamicGoalsConfigInput', # DynamicGoalsConfigInput
            # list of cameras names for doing detection inside the source container. Each camera name is in the format of kinbody_name/attached_sensor_name. Overwritten by first layer value!
            'sourcecameranames': 'String', # [String]
            'sourcecontainername': 'String', # String
            # Describes the order of targets to be picked up. Currently available strategies are
            # 'axis'
            # 'containerLocalAxis'
            # 'name'
            # 'type'
            'strictPickOrdering': 'StrictPickOrderingInput', # StrictPickOrderingInput
            # sec, max time to spend on computing grasps for one target. 0 means infinite
            'targetGraspTimeLimit': 'Float', # Float
            # if True, then using randomized box picking which means vision will send results with the box sizes in it
            'targetIsRandomBox': 'Boolean', # Boolean
            # mm, The padding to add to the target when initially transferring the target outside of the source container to its next position (can be dest, middest, or scan position). cannot be defined (have positive value) with fTargetMinSafetyHeightForInitialTransfer
            'targetMinBottomPaddingForInitialTransfer': 'Float', # Float
            # Describes how overlapped regions in targets should be processed.
            'targetOverlapConstraintInfo': 'TargetOverlapConstraintInfoInput', # TargetOverlapConstraintInfoInput
            # name of the inverse kinematic parameter of the target to feet destination goal. Valid ONLY if destcoordtype=='targetplaceik', if not defined ik parameter name '_placed' will be used
            'targetPlaceIkParamName': 'String', # String
            # Apply this translation offset to all targets. Usually used to signify that targets drop a little because of the way gripper is designed or how far robot drops part from floor. mm, x,y,z
            'targetPlaceTranslationOffset': 'Float', # [Float]
            # The action to perform on the target after picking it successfully from the pick (source) container.
            # - setUnpickable - Do not delete target from the source container after it is picked up, the target is gonna be removed only after update from vision. Not deleting a target is safer, but could slow the cycle time
            # - moveDownSetUnpickable - Move the part down and set as unpickable
            # - delete - Completely delete the part from the pick (source) container, as soon as it's planned for pickup. 
            # - deleteButConsiderForApproachMove
            # - deleteNotifyBridge - notify the robotbridge that the target was deleted from the location
            'targetPostActionAfterPick': 'String', # String
            # How much to prioritize right-up objects in the container. The higher the value, the more object that will be prioritized with its axes facing in the up direction. By default it is 0.
            'targetPriorityForAngleMult': 'Float', # Float
            # the amount to multiple the confidence measure by. by default it is 1.
            'targetPriorityForConfidenceMult': 'Float', # Float
            # How much to prioritize the tool being close to its constraints (ie vertical). Multiplied by the angle from the constraint and subtracted from priority.
            'targetPriorityForConstraintToolDeviation': 'Float', # Float
            # how much to prioritize less tool rotation when the part is being grabbed. Multiply the angle (in radians) between the two rotations. By default is 0.5.
            'targetPriorityForGrabToolRotMult': 'Float', # Float
            # Multiplier for grasp center from target center of mass when subtracting from target priority. The higher this value, the more the grasp is penalized from being away from center.
            'targetPriorityForGraspDistMult': 'Float', # Float
            # Multiplier for grasp priority when adding to target priority.
            'targetPriorityForGraspPriorityMult': 'Float', # Float
            # how much to prioritize objects on -X in the container. The higher the value, the more will be prioritized.
            'targetPriorityForNegativeXMult': 'Float', # Float
            # how much to prioritize objects on -Y in the container. The higher the value, the more will be prioritized.
            'targetPriorityForNegativeYMult': 'Float', # Float
            # How much to prioritize objects that are not being overlapped by other objects. The multiplier is for the overlap ratio computed dynamically, which is in [0,1].
            'targetPriorityForNonOverlappedMult': 'Float', # Float
            # How much to prioritize objects that have distance (translational distance) from the closest previously picked target.
            'targetPriorityForPrevPickedTargetsDistMult': 'Float', # Float
            # how much to prioritize number of uncertain corners of the target object. negative value prioritizes the target has less uncertain corners.
            'targetPriorityForUncertainCornerMult': 'Float', # Float
            # how much to prioritize +X position of the objects in the container. positive value prioritizes items with higher global X value.
            'targetPriorityForXMult': 'Float', # Float
            # how much to prioritize objects based on distance from center of container.
            'targetPriorityForXYCenterDist': 'Float', # Float
            # How much to discretize priorities using XYZ in order to avoid small noise from affecting the priority computation directly. For example, if this parameter is set to 20, then height of two targets that are 801 and 815, both get considered the same priority.
            'targetPriorityForXYZDiscretization': 'Float', # Float
            # how much to prioritize +Y position of the objects in the container. positive value prioritizes items with higher global Y value.
            'targetPriorityForYMult': 'Float', # Float
            # how much to prioritize top most objects in the container. The higher the value, the more will be prioritized.
            'targetPriorityForZMult': 'Float', # Float
            # Multipliers and other related quantities for various target priority values.
            'targetPriorityMultipliers': 'TargetPriorityMultipliersInput', # TargetPriorityMultipliersInput
            # Depending on how the gripper overlaps with the target object, it can exert different suction forces on it. This is a multiplier on the force (N) for a target's grasp priority.
            'targetPrioritySuctionForceMult': 'Float', # Float
            # This is a multiplier on the transferSpeedMult (TSM) for a target's grasp priority.
            'targetPriorityTransferSpeedMult': 'Float', # Float
            # mm, threshold for maximum target thickness which can be trapped by disabled suction cup for items with objectType not 'bag' and 'twosidedpackage' items. Items with objectType 'bag' and 'twosidedpackage' will ignore such a parameter and will be considered for trapping. TODO: in the future compute from size of suction cups.
            'targetThicknessThreshForTrapping': 'Float', # Float
            # threshold between expected target position from destinations with the planned target position after robot grabbed and transferred it. If the planned position of the target is within this threshold then assume that the plan is successful. Smaller the value more accurate the placement is, but fail more frequently. Default is 0.01
            'targetdestikthresh': 'Float', # Float
            # mm, environment clearacence applied to grabbed target
            'targetenvclearance': 'Float', # Float
            # supports regular expressions (i.e. detected_\d+)
            'targetnamepattern': 'String', # String
            # Optional URI to use for every target. if randomized box picking, then leave empty
            'targeturi': 'String', # String
            # mm (x,y,z)
            'toolPosConstraintPaddingXYZ': 'Float', # [Float]
            # Allows specifying limits on the speed and acceleration of the manipulator.
            'toolSpeedAccelInfo': 'ToolSpeedAccelInfoInput', # ToolSpeedAccelInfoInput
            # mm, when gravity compensation is enabled, how many mm offset the robot could get from its commanded position before declaring a torque limits error
            'torqueDistThresh': 'Float', # Float
            # Specifies the transfer speed mult ratio in [0,1] to reduce speed when grabbing an object. This is a global setting applied
            'transferSpeedMult': 'Float', # Float
            # An array of the transfer speed multipliers for different weights. If the partType's weight is between the weights in this array, the transfer speed multiplier (transferSpeedMult) is interpolated linearly.
            'transferSpeedMultPerWeight': 'TransferSpeedMultPerWeightInput', # [TransferSpeedMultPerWeightInput]
            # If True, update the height of the object depending on the distance sensor measurement.
            'updateHeightWithMeasuredValue': 'Boolean', # Boolean
            # If True, update mass depending on the dynamic measurement of force torque sensor.
            'updateMassWithMeasuredValue': 'Boolean', # Boolean
            # If True, then use barcode regions as unpickable regions for grasp sets.
            'useBarcodeUnpickableRegions': 'Boolean', # Boolean
            # If True, then will decrease target environment clearance for objects which are bigger than source container inner region.
            'useDecreaseTargetEnvClearanceBigObjects': 'Boolean', # Boolean
            # If True, then use destination goals even if they are in collision with the environment. Otherwise prune all dest goals that are in collision. During runtime, this will make sure that robot does not place a part in collision with other parts.
            'useDestGoalsInCollision': 'Boolean', # Boolean
            # to use dynamic goals generation to define position of the items in the destcontainername
            'useDynamicGoals': 'Boolean', # Boolean
            # To use queueing to speed up robot execution, 0 to not use queueing (use for debugging since it is simpler)
            'useExecutionQueueing': 'Int', # Int
            # Use KZ filter in FilterRobotTrajectory related functions.
            'useKZFilter': 'Boolean', # Boolean
            # If True, robot will wait for dest prohibited PLC signal to go to OFF at the grasp before starting the part transfer operation. This feature ensures that the robot doesn't do any interlocking in the middle that could have the part fly out of the hand, or maybe the robot doesn't have enough time to stop interlocking (if a big robot).
            'waitForDestProhibitedAtGrasp': 'Boolean', # Boolean
            # If True, then will wait for new vision detection results for waitForSupplyTimeout after the initial pick. If False, will quit the cycle with FinishedNoMoreTargets after robot is done picking up everything that is detected, robot will not wait for vision results. This parameter is used in cases where speed is important and robot shouldn't waste time trying to pickup the last targets in the container.
            'waitForDetectionAfterInitialPick': 'Boolean', # Boolean
            # Wait for all location to become unprohibited.
            'waitForLocationUnprohibited': 'Boolean', # Boolean
            # If True, robot will wait for source prohibited PLC signal to go to OFF after placing a part at the dest before going home or doing other recovery tasks. This feature ensures that the robot doesn't do any interlocking in the middle that could have the robot decelerating fast and stopping (especially for big robots). By default this is False.
            'waitForSourceProhibitedAtDest': 'Boolean', # Boolean
            # Wait for another slave's finish code to trigger this slave's computation
            'waitForStateSlaveTrigger': 'Boolean', # Boolean
            # sec, how long to wait before stopping the pick and place thread when container is not empty, but nothing is registered. possibly change this depending on the detection recognition time
            'waitForSupplyTimeout': 'Float', # Float
            # sec, how long to wait for the initial vision results to come before starting pick and place
            'waitUpdateStampTimeout': 'Float', # Float
            # Information on controlling ykk external devices
            'ykkControlInfo': 'YKKControlInfoInput', # YKKControlInfoInput
        },

        # Blob of data, belonging to an environment. Blobs are usually support files and images.
        'Blob': {
            # Content type of the blob.
            'contentType': 'String', # String
            # Timestamp when the blob was created.
            'createdAt': 'DateTime', # DateTime
            # The globally unique ID of the blob.
            'id': 'String', # String!
            # Timestamp when the blob was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Size of the blob in bytes
            'size': 'Int', # Int
        },

        # Blob of data, belonging to an environment. Blobs are usually support files and images.
        'BlobInput': {
            # Content type of the blob.
            'contentType': 'String', # String
            # The globally unique ID of the blob.
            'id': 'String', # String
        },

        # An OpenRAVE body in an environment. Can also describe a robot (a body with multiple links and joints)
        'Body': {
            # A list of attached sensors (e.g. cameras, force sensors, light curtains...)
            'attachedSensors': 'AttachedSensor', # [AttachedSensor!]
            # Summarized collision enable state for all links in the body. One of "enabled", "disabled", "partial", "inapplicable". Not saved in file, only used by API to set all link collision enable states at once. Cannot be set to "partial" or "inapplicable",
            'collisionEnableState': 'String', # String
            # Bodies that are connected to this one
            'connectedBodies': 'ConnectedBody', # [ConnectedBody!]
            'createdAt': 'DateTime', # DateTime
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The values of the body's joints.
            'dofValues': 'DOFValue', # [DOFValue!]
            # Grabbed items
            'grabbed': 'Grabbed', # [Grabbed!]
            # A list of possible grippers
            'gripperInfos': 'GripperInfo', # [GripperInfo!]
            # The ID of this body. Unique within an environment.
            'id': 'String', # String!
            # interfaceType, e.g. GenericRobot
            'interfaceType': 'String', # String
            # Whether the body is a kinBody or a robot
            'isRobot': 'Boolean', # Boolean
            # The joints that make up the body. One joint connects to one link.
            'joints': 'Joint', # [Joint!]
            # The links that are part of the body. Each link is connected to one joint.
            'links': 'Link', # [Link!]
            'modifiedAt': 'DateTime', # DateTime
            # The name of this body. Unique within an environment.
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Parameters of an OpenRAVE body.
            'readableInterfaces': 'ReadableInterfaces', # ReadableInterfaces
            # The "parent" of this body. Fields that are undefined in this body will be taken from the parent (recursively).
            'referenceUri': 'String', # String
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
            'tools': 'Tool', # [Tool!]
            # The transform from the parent (the world).
            'transform': 'Float', # [Float!]
            # Summarized visibility state for all geometries in the body. One of "visible", "invisible", "partial", "inapplicable". Not saved in file, only used by API to set all geometries visibility at once. Cannot be set to "partial" or "inapplicable".
            'visibilityState': 'String', # String
        },

        # An OpenRAVE body in an environment. Can also describe a robot (a body with multiple links and joints)
        'BodyInput': {
            # A list of attached sensors (e.g. cameras, force sensors, light curtains...)
            'attachedSensors': 'AttachedSensorInput', # [AttachedSensorInput!]
            # Summarized collision enable state for all links in the body. One of "enabled", "disabled", "partial", "inapplicable". Not saved in file, only used by API to set all link collision enable states at once. Cannot be set to "partial" or "inapplicable",
            'collisionEnableState': 'String', # String
            # Bodies that are connected to this one
            'connectedBodies': 'ConnectedBodyInput', # [ConnectedBodyInput!]
            'createdAt': 'DateTime', # DateTime
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The values of the body's joints.
            'dofValues': 'DOFValueInput', # [DOFValueInput!]
            # Grabbed items
            'grabbed': 'GrabbedInput', # [GrabbedInput!]
            # A list of possible grippers
            'gripperInfos': 'GripperInfoInput', # [GripperInfoInput!]
            # The ID of this body. Unique within an environment.
            'id': 'String', # String
            # interfaceType, e.g. GenericRobot
            'interfaceType': 'String', # String
            # Whether the body is a kinBody or a robot
            'isRobot': 'Boolean', # Boolean
            # The joints that make up the body. One joint connects to one link.
            'joints': 'JointInput', # [JointInput!]
            # The links that are part of the body. Each link is connected to one joint.
            'links': 'LinkInput', # [LinkInput!]
            'modifiedAt': 'DateTime', # DateTime
            # The name of this body. Unique within an environment.
            'name': 'String', # String
            # Parameters of an OpenRAVE body.
            'readableInterfaces': 'ReadableInterfacesInput', # ReadableInterfacesInput
            # The "parent" of this body. Fields that are undefined in this body will be taken from the parent (recursively).
            'referenceUri': 'String', # String
            # Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
            'tools': 'ToolInput', # [ToolInput!]
            # The transform from the parent (the world).
            'transform': 'Float', # [Float!]
            # Summarized visibility state for all geometries in the body. One of "visible", "invisible", "partial", "inapplicable". Not saved in file, only used by API to set all geometries visibility at once. Cannot be set to "partial" or "inapplicable".
            'visibilityState': 'String', # String
        },

        # Parameters of an OpenRAVE 'Body'
        'BodyParameters': {
            'allowedPlacementOrientations': 'Int', # Int
            'barcodeScanningGain': 'Float', # Float
            'barcodes': 'String', # [String!]
            'bottomBoxDistSensorThresh': 'Float', # Float
            'disabledReferenceObjectPKs': 'String', # [String!]
            'distSensorMismatchReplanThresh': 'Float', # Float
            'graspModelInfo': 'GraspModelInfo', # GraspModelInfo
            # Represents a set of IKParams at which an object may be grasped.
            'graspSets': 'GraspSet', # [GraspSet!]
            # Scores how a gripper's suction cups are performing.
            'gripperSuctionCupsPerformances': 'GripperSuctionCupsPerformance', # [GripperSuctionCupsPerformance!]
            # Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
            'ikParams': 'IKParameterization', # [IKParameterization!]
            'knownBarCodeFaces': 'Int', # Int
            'materialType': 'String', # String
            'minSuctionForce': 'Float', # Float
            'minViableRegionSize2D': 'Float', # [Float!]
            'modelName': 'String', # String
            # parameters related to robot library objects
            'objectCategory': 'String', # String
            'objectDescription': 'Any', # Any
            'objectPackingId': 'String', # String
            'objectType': 'String', # String
            'packingOrderPriority': 'Int', # Int
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # A robot configuration defined via joint values.
            'positionConfigurations': 'PositionConfiguration', # [PositionConfiguration!]
            'referenceObjectPKs': 'String', # [String!]
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            'totalNumBarCodes': 'Int', # Int
            'transferSpeedMult': 'Float', # Float
            'vendorName': 'String', # String
        },

        # Parameters of an OpenRAVE 'Body'
        'BodyParametersInput': {
            'allowedPlacementOrientations': 'Int', # Int
            'barcodeScanningGain': 'Float', # Float
            'barcodes': 'String', # [String!]
            'bottomBoxDistSensorThresh': 'Float', # Float
            'disabledReferenceObjectPKs': 'String', # [String!]
            'distSensorMismatchReplanThresh': 'Float', # Float
            'graspModelInfo': 'GraspModelInfoInput', # GraspModelInfoInput
            # Represents a set of IKParams at which an object may be grasped.
            'graspSets': 'GraspSetInput', # [GraspSetInput!]
            # Scores how a gripper's suction cups are performing.
            'gripperSuctionCupsPerformances': 'GripperSuctionCupsPerformanceInput', # [GripperSuctionCupsPerformanceInput!]
            # Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
            'ikParams': 'IKParameterizationInput', # [IKParameterizationInput!]
            'knownBarCodeFaces': 'Int', # Int
            'materialType': 'String', # String
            'minSuctionForce': 'Float', # Float
            'minViableRegionSize2D': 'Float', # [Float!]
            'modelName': 'String', # String
            # parameters related to robot library objects
            'objectCategory': 'String', # String
            'objectDescription': 'Any', # Any
            'objectPackingId': 'String', # String
            'objectType': 'String', # String
            'packingOrderPriority': 'Int', # Int
            # A robot configuration defined via joint values.
            'positionConfigurations': 'PositionConfigurationInput', # [PositionConfigurationInput!]
            'referenceObjectPKs': 'String', # [String!]
            'totalNumBarCodes': 'Int', # Int
            'transferSpeedMult': 'Float', # Float
            'vendorName': 'String', # String
        },

        # Configuration of Keyence CV-X.
        'CVXSensorConfiguration': {
            # The port number of control socket of CV-X. This is only used for debug.
            'controlPort': 'Int', # Int
            # The port number of data socket of CV-X. This is only used for debug.
            'dataPort': 'Int', # Int
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The execution number used in CV-X.
            'execNo': 'Int', # Int
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The maximum number of detection results. The value cannot be greater than one defined in the program in CV-X.
            'maxNumResults': 'Int', # Int
            # The program number used in CV-X.
            'programNo': 'Int', # Int
            # The SD card number used in CV-X. 1 or 2 is valid SD card number.
            'sdCardNo': 'Int', # Int
            # The IP address of CV-X.
            'serverIp': 'String', # String
            # The port number of Non-Procedural command interface of CV-X.
            'serverPort': 'Int', # Int
            # The tool id used in CV-X.
            'toolId': 'Int', # Int
        },

        # Configuration of Keyence CV-X.
        'CVXSensorConfigurationInput': {
            # The port number of control socket of CV-X. This is only used for debug.
            'controlPort': 'Int', # Int
            # The port number of data socket of CV-X. This is only used for debug.
            'dataPort': 'Int', # Int
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The execution number used in CV-X.
            'execNo': 'Int', # Int
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The maximum number of detection results. The value cannot be greater than one defined in the program in CV-X.
            'maxNumResults': 'Int', # Int
            # The program number used in CV-X.
            'programNo': 'Int', # Int
            # The SD card number used in CV-X. 1 or 2 is valid SD card number.
            'sdCardNo': 'Int', # Int
            # The IP address of CV-X.
            'serverIp': 'String', # String
            # The port number of Non-Procedural command interface of CV-X.
            'serverPort': 'Int', # Int
            # The tool id used in CV-X.
            'toolId': 'Int', # Int
        },

        # The parameter of a calibration board. Calibration boards are used to determine the position of a camera relative to the robot.
        'CalibrationBoardParameters': {
            'bigDotDiameterDistanceRatio': 'Float', # Float
            'dotColor': 'Float', # [Float!]
            'dotDiameterDistanceRatio': 'Float', # Float
            'dotsDistanceX': 'Float', # Float
            'dotsDistanceY': 'Float', # Float
            'numDotsX': 'Int', # Int
            'numDotsY': 'Int', # Int
            'patternName': 'String', # String
        },

        # The parameter of a calibration board. Calibration boards are used to determine the position of a camera relative to the robot.
        'CalibrationBoardParametersInput': {
            'bigDotDiameterDistanceRatio': 'Float', # Float
            'dotColor': 'Float', # [Float!]
            'dotDiameterDistanceRatio': 'Float', # Float
            'dotsDistanceX': 'Float', # Float
            'dotsDistanceY': 'Float', # Float
            'numDotsX': 'Int', # Int
            'numDotsY': 'Int', # Int
            'patternName': 'String', # String
        },

        # The intrinsic parameters of the camera.
        'CameraIntrinsics': {
            'cx': 'Float', # Float!
            'cy': 'Float', # Float!
            'distortionCoeffs': 'Float', # [Float!]!
            'distortionModel': 'String', # String!
            'focalLength': 'Float', # Float!
            # The focal length in X direction
            'fx': 'Float', # Float!
            # The focal length in Y direction
            'fy': 'Float', # Float!
        },

        # The intrinsic parameters of the camera.
        'CameraIntrinsicsInput': {
            'cx': 'Float', # Float!
            'cy': 'Float', # Float!
            'distortionCoeffs': 'Float', # [Float!]!
            'distortionModel': 'String', # String!
            'focalLength': 'Float', # Float!
            # The focal length in X direction
            'fx': 'Float', # Float!
            # The focal length in Y direction
            'fy': 'Float', # Float!
        },

        # A set of planning parameters for cameras that are attached to the robot.
        'CameraPlanningInfo': {
            # The IkParam Z component is adjusted so that it is equivalent to the highest item in the location. Items include detected targets, placed targets, point clouds, and other static obstacles associated with the 'location'.
            'adjustIkParamZUsingHighestItem': 'Boolean', # Boolean
            # Name of the manipulator that is the in-hand camera.
            'cameraManipName': 'String', # String
            # If True, will check the containerValidTimeStamp of the location and see if the results are newer than the location's containerValidTimeStampMS. If there are no results yet or they are not set, will skip the camera planning phase. If initialBeforePlanning or onPlanningIdle, then set to True by default.
            'checkContainerValidTimeStamp': 'Boolean', # Boolean
            # If True, will check whether the pyramid between the origin of the end-effector and the target object has any dynamic obstacles or other detected objects in it. If there are, then the entire target is not visiblt. So reject the grasp. Used only when planningTriggerTiming is inCyclePerTarget. False by default.
            'checkGraspVisibility': 'Boolean', # Boolean
            # When checking visibility for the region between end effector origin and target object, indicates how far the base of the visibility pyramid is from the actual target (distance measured perpendicular to the surface of the target) in x and y directions. unit: mm. Used only when planningTriggerTiming is inCyclePerTarget.
            'clearanceXYForGraspVisibilityFilter': 'Float', # Float
            # When checking visibility for the region between end effector origin and target object, indicates how far the base of the visibility pyramid is from the actual target (distance measured perpendicular to the surface of the target) in the z direction. unit: mm.
            'clearanceZForGraspVisibilityFilter': 'Float', # Float
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Type of detection trigger to send to vision when the robot has moved to that camera position.
            # - detection - regular object detection is called
            # - phase1Detection - regular object detection with 'phase1Detection' specified
            # - phase2Detection - regular object detection with 'phase2Detection' specified
            # - pointCloudObstacle - just gather and send the point cloud data to planning
            'detectionTriggerType': 'String', # String
            # Name of the graspset that contains ikparams for cameramanip to capture snapshots of target/source/dest.
            'graspsetname': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Name of the ikparameter that represents the snapping position.
            'ikParamName': 'String', # String
            # Name of the object to get the specified ikparameter from.
            'instobjectname': 'String', # String
            # Parameters for generating a connecting trajectory, which is a trajectory segment connecting the current robot values (which may be the result of the robot stopping due to io sensors) with the initial robot values of the next trajectory to be executed.
            'mergeTrajectoryParameters': 'MergeTrajectoryParameters', # MergeTrajectoryParameters
            # The trigger within the planning cycle of the camera detection.
            # - inCyclePerTarget - Camera planning is for each target. ikPraamName is for each target.
            # - inCyclePerContainer - Planning happens to instobjectname/ikParamName during the planning cycle before the robot goes to that location.
            # - initialBeforePlanning - Parameters for planning with in-hand camera for initial detection phase, before starting pick and place cycle (ie, when new container arrives)
            # - onPlanningIdle - Camera goes to this location when there are no good picking candidates left and the planning thread is idle.
            'planningTriggerTiming': 'String', # String
            # s, timeout to wait for fine-detection results to be sent to the planning side.
            'timeoutWaitForFineDetectionResult': 'Float', # Float
            # s, timeout to wait for response from vision manager on trigger.
            'timeoutWaitForTrigger': 'Float', # Float
            # The location names that the planning is set for.
            'triggerLocationNames': 'String', # [String]
            # Indicate whether to use planning with camera in hand
            'use': 'Boolean', # Boolean
        },

        # A set of planning parameters for cameras that are attached to the robot.
        'CameraPlanningInfoInput': {
            # The IkParam Z component is adjusted so that it is equivalent to the highest item in the location. Items include detected targets, placed targets, point clouds, and other static obstacles associated with the 'location'.
            'adjustIkParamZUsingHighestItem': 'Boolean', # Boolean
            # Name of the manipulator that is the in-hand camera.
            'cameraManipName': 'String', # String
            # If True, will check the containerValidTimeStamp of the location and see if the results are newer than the location's containerValidTimeStampMS. If there are no results yet or they are not set, will skip the camera planning phase. If initialBeforePlanning or onPlanningIdle, then set to True by default.
            'checkContainerValidTimeStamp': 'Boolean', # Boolean
            # If True, will check whether the pyramid between the origin of the end-effector and the target object has any dynamic obstacles or other detected objects in it. If there are, then the entire target is not visiblt. So reject the grasp. Used only when planningTriggerTiming is inCyclePerTarget. False by default.
            'checkGraspVisibility': 'Boolean', # Boolean
            # When checking visibility for the region between end effector origin and target object, indicates how far the base of the visibility pyramid is from the actual target (distance measured perpendicular to the surface of the target) in x and y directions. unit: mm. Used only when planningTriggerTiming is inCyclePerTarget.
            'clearanceXYForGraspVisibilityFilter': 'Float', # Float
            # When checking visibility for the region between end effector origin and target object, indicates how far the base of the visibility pyramid is from the actual target (distance measured perpendicular to the surface of the target) in the z direction. unit: mm.
            'clearanceZForGraspVisibilityFilter': 'Float', # Float
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Type of detection trigger to send to vision when the robot has moved to that camera position.
            # - detection - regular object detection is called
            # - phase1Detection - regular object detection with 'phase1Detection' specified
            # - phase2Detection - regular object detection with 'phase2Detection' specified
            # - pointCloudObstacle - just gather and send the point cloud data to planning
            'detectionTriggerType': 'String', # String
            # Name of the graspset that contains ikparams for cameramanip to capture snapshots of target/source/dest.
            'graspsetname': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Name of the ikparameter that represents the snapping position.
            'ikParamName': 'String', # String
            # Name of the object to get the specified ikparameter from.
            'instobjectname': 'String', # String
            # Parameters for generating a connecting trajectory, which is a trajectory segment connecting the current robot values (which may be the result of the robot stopping due to io sensors) with the initial robot values of the next trajectory to be executed.
            'mergeTrajectoryParameters': 'MergeTrajectoryParametersInput', # MergeTrajectoryParametersInput
            # The trigger within the planning cycle of the camera detection.
            # - inCyclePerTarget - Camera planning is for each target. ikPraamName is for each target.
            # - inCyclePerContainer - Planning happens to instobjectname/ikParamName during the planning cycle before the robot goes to that location.
            # - initialBeforePlanning - Parameters for planning with in-hand camera for initial detection phase, before starting pick and place cycle (ie, when new container arrives)
            # - onPlanningIdle - Camera goes to this location when there are no good picking candidates left and the planning thread is idle.
            'planningTriggerTiming': 'String', # String
            # s, timeout to wait for fine-detection results to be sent to the planning side.
            'timeoutWaitForFineDetectionResult': 'Float', # Float
            # s, timeout to wait for response from vision manager on trigger.
            'timeoutWaitForTrigger': 'Float', # Float
            # The location names that the planning is set for.
            'triggerLocationNames': 'String', # [String]
            # Indicate whether to use planning with camera in hand
            'use': 'Boolean', # Boolean
        },

        # Configuration of each Cognex barcode scanner.
        'CognexBarcodeScanner': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The IP address of Cognex sensor.
            'scannerIP': 'String', # String
            # The port number of Cognex sensor. The default port number is 23.
            'scannerPort': 'Int', # Int
        },

        # Configuration of each Cognex barcode scanner.
        'CognexBarcodeScannerInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The IP address of Cognex sensor.
            'scannerIP': 'String', # String
            # The port number of Cognex sensor. The default port number is 23.
            'scannerPort': 'Int', # Int
        },

        # Configuration of Cognex barcode scanner.
        'CognexSensorConfiguration': {
            # List of avilable Cognex sensors.
            'sensorList': 'CognexBarcodeScanner', # [CognexBarcodeScanner]
        },

        # Configuration of Cognex barcode scanner.
        'CognexSensorConfigurationInput': {
            # List of avilable Cognex sensors.
            'sensorList': 'CognexBarcodeScannerInput', # [CognexBarcodeScannerInput]
        },

        # Parameters to move away from neighboring walls on departing. when these parameters are used to approaching, it computes movement that gets close to walls from the given distance.
        'CollisionWallOffsetParameters': {
            # If True, planning will try vertical depart/approach when testing all walls is failed.
            'allowFallback': 'Boolean', # Boolean
            # Value in [0.001,0.999]. when checking for collisions of neighboring walls. Use this clearance to ignore noise and intersecting collisions. The higher the value, the more is ignored and grabbed box might slightly collide with other boxes when pulling out.
            'clearanceMult': 'Float', # Float
            # When departing, how much to test and move away from all walls including detected target objects and point clouds. This should be used for pallet picking.
            'stepLengthXY': 'Float', # Float
            # When testing testWallStepLengthXY, use this to increase the height of the target when checking collision.
            'stepLengthZ': 'Float', # Float
        },

        # Parameters to move away from neighboring walls on departing. when these parameters are used to approaching, it computes movement that gets close to walls from the given distance.
        'CollisionWallOffsetParametersInput': {
            # If True, planning will try vertical depart/approach when testing all walls is failed.
            'allowFallback': 'Boolean', # Boolean
            # Value in [0.001,0.999]. when checking for collisions of neighboring walls. Use this clearance to ignore noise and intersecting collisions. The higher the value, the more is ignored and grabbed box might slightly collide with other boxes when pulling out.
            'clearanceMult': 'Float', # Float
            # When departing, how much to test and move away from all walls including detected target objects and point clouds. This should be used for pallet picking.
            'stepLengthXY': 'Float', # Float
            # When testing testWallStepLengthXY, use this to increase the height of the target when checking collision.
            'stepLengthZ': 'Float', # Float
        },

        'Configuration': {
            # Last author who modified the configuration.
            'author': 'String', # String!
            # Timestamp when the configuration was created.
            'createdAt': 'DateTime', # DateTime
            # ID of the configuration.
            'id': 'String', # String!
            # Timestamp when the configuration was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # For linking the imported configuration file to a file in the configuration library that is part of the runtime image.
            'referenceFilename': 'String', # String
            # The ID of the parent configuration of this configuration. Fields that are undefined in this configuration will be taken from the parent (recursively).
            'referenceId': 'String', # String
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Latest revision id of the configuration.
            'revisionId': 'Int', # Int!
        },

        # A body that is connected to another.
        'ConnectedBody': {
            # Sensors that are attached to this connected body.
            'attachedSensors': 'AttachedSensor', # [AttachedSensor!]
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # GripperInfos that are part of this connected body.
            'gripperInfos': 'GripperInfo', # [GripperInfo!]
            # The ID of this connected body. Unique within an environment.
            'id': 'String', # String!
            # If False, this body will not be considered during collision checking.
            'isActive': 'Int', # Int
            # The joints that are part of this connected body
            'joints': 'Joint', # [Joint!]
            # The link to which the body is connected.
            'linkName': 'String', # String
            # The links that are part of this connected body
            'links': 'Link', # [Link!]
            # The name of this connected body. Unique within an environment.
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Tools that are part of this connected body.
            'tools': 'Tool', # [Tool!]
            # The transform from the link to the connected body.
            'transform': 'Float', # [Float!]
            # URI to the Environment that provides the original body to be connected.
            'uri': 'String', # String
        },

        # A body that is connected to another.
        'ConnectedBodyInput': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The ID of this connected body. Unique within an environment.
            'id': 'String', # String
            # If False, this body will not be considered during collision checking.
            'isActive': 'Int', # Int
            # The link to which the body is connected.
            'linkName': 'String', # String
            # The name of this connected body. Unique within an environment.
            'name': 'String', # String
            # The transform from the link to the connected body.
            'transform': 'Float', # [Float!]
            # URI to the Environment that provides the original body to be connected.
            'uri': 'String', # String
        },

        # Constrain a direction on the tool to be within a certain angle with respect to a global direction.
        'ConstraintToolInfo': {
            # deg, The constraint angle at the destination goal.
            'destDirectionAngle': 'Float', # Float
            # deg, The constraint angle when the robot is not grabbing a part and freely moving.
            'duringFreeMovementAngle': 'Float', # Float
            # deg, The constraint angle when the robot is grabbing a part.
            'duringGrabbingAngle': 'Float', # Float
            # deg, The constraint angle at the final position of the cycle, this is where the robot stops and also the (initial of the next cycle) of the robot.
            'finalDirectionAngle': 'Float', # Float
            # The global direction in that constraints where the tool direction with respect to the angle.
            'globalDirection': 'Float', # [Float]
            # deg, The constraint angle at the grasp.
            'graspDirectionAngle': 'Float', # Float
            # When a part is grasped, if it is violating constraint more than duringGrabbingAngle, then when departing the robot will slowly try to normalize the part to fit the constraint within this ratio. If ratio is 0, then robot will normalize the part until it's angle is 0. If ratio is 1, then robot will normalize part until its angle is duringGrabbingAngle.
            'graspNormalizeToZeroRatio': 'Float', # Float
            # Direction in the tool coordinate system and defines one of the vectors to do the cone constraints.
            'localToolDirection': 'Float', # [Float]
            # Set to true to enable tool constraints.
            'use': 'Boolean', # Boolean
        },

        # Constrain a direction on the tool to be within a certain angle with respect to a global direction.
        'ConstraintToolInfoInput': {
            # deg, The constraint angle at the destination goal.
            'destDirectionAngle': 'Float', # Float
            # deg, The constraint angle when the robot is not grabbing a part and freely moving.
            'duringFreeMovementAngle': 'Float', # Float
            # deg, The constraint angle when the robot is grabbing a part.
            'duringGrabbingAngle': 'Float', # Float
            # deg, The constraint angle at the final position of the cycle, this is where the robot stops and also the (initial of the next cycle) of the robot.
            'finalDirectionAngle': 'Float', # Float
            # The global direction in that constraints where the tool direction with respect to the angle.
            'globalDirection': 'Float', # [Float]
            # deg, The constraint angle at the grasp.
            'graspDirectionAngle': 'Float', # Float
            # When a part is grasped, if it is violating constraint more than duringGrabbingAngle, then when departing the robot will slowly try to normalize the part to fit the constraint within this ratio. If ratio is 0, then robot will normalize the part until it's angle is 0. If ratio is 1, then robot will normalize part until its angle is duringGrabbingAngle.
            'graspNormalizeToZeroRatio': 'Float', # Float
            # Direction in the tool coordinate system and defines one of the vectors to do the cone constraints.
            'localToolDirection': 'Float', # [Float]
            # Set to true to enable tool constraints.
            'use': 'Boolean', # Boolean
        },

        'ContainerInspectionConfiguration': {
            # Maximum rotation angle (of the container) allowed in order to pass container inspection.
            'maxAngleThreshold': 'Float', # Float
            # The minimum top layer coverage in order to pass container inspection.
            'topLayerPercentageRequired': 'Float', # Float
            # This is used for 'pure' container inspection systems.
            # If True, the point cloud data of the contents is not used
            # as collision data, and *only* container inspection is performed
            # (no robot motions).
            # 
            # This parameter should be False for picking systems that move a robot.
            'use': 'Boolean', # Boolean
        },

        'ContainerInspectionConfigurationInput': {
            # Maximum rotation angle (of the container) allowed in order to pass container inspection.
            'maxAngleThreshold': 'Float', # Float
            # The minimum top layer coverage in order to pass container inspection.
            'topLayerPercentageRequired': 'Float', # Float
            # This is used for 'pure' container inspection systems.
            # If True, the point cloud data of the contents is not used
            # as collision data, and *only* container inspection is performed
            # (no robot motions).
            # 
            # This parameter should be False for picking systems that move a robot.
            'use': 'Boolean', # Boolean
        },

        'ControllerSystemConfiguration': {
            # Last author who modified the configuration.
            'author': 'String', # String!
            # If True, then auto-generate the Inverse Kinematics whenever idle
            'autoGenerateIk': 'Boolean', # Boolean
            # Whether to automatically set the VOI (Volume of Interest) of a streamer based on the container.
            'autoSetSensorVOI': 'String', # String
            # List of available UI profiles
            'availableUIProfiles': 'String', # [String]
            # Different parameters to configure binpicking pick and place cycle.
            'binpickingparameters': 'BinpickingParameters', # BinpickingParameters
            # NOTE: Will not add calib params here. Assuming they will live elsewhere
            'calibration': 'Any', # Any
            # NOTE: Will not add calib params here. Assuming they will live elsewhere
            'calibrationParameters': 'Any', # Any
            # NOTE: Will not add calib params here. Assuming they will live elsewhere
            'calibrationVerificationParameters': 'Any', # Any
            # The home position of the UI viewer virtual camera. Defines the view of the simulated system on startup.
            'cameraHome': 'UserCameraHome', # UserCameraHome
            # If True, will check the IK (Inverse Kinematics) before starting the cycle
            'checkIkGeneration': 'Boolean', # Boolean
            # If True, then will do partial occlusion checking for the robot and camera and report the partial image to the detector. For now, this is only usable for the devanning detector.
            'checkPartialOcclusion': 'Boolean', # Boolean
            # Clear object set when source container changes.
            'clearObjectSetOnContainerChanged': 'Boolean', # Boolean
            # Clear object set when part type changes.
            'clearObjectSetOnPartTypeChanged': 'Boolean', # Boolean
            # Clear object set when cycle starts. Useful to show demo of auto-registration.
            'clearObjectSetOnStartCycle': 'Boolean', # Boolean
            # A dictionary of the locations in the current system. Key is containername, value is a dictionary of location parameters: "cameranames"
            'containerProperties': 'Any', # Any
            # The password to connect to the controller
            'controllerpassword': 'String', # String
            # The Mujin Controller URL, e.g. http://controller14
            'controllerurl': 'String', # String
            # The username to connect to the controller
            'controllerusername': 'String', # String
            # If True, creates an object set on start cycle if one does not exist.
            'createEmptyObjectSetOnStartCycle': 'Boolean', # Boolean
            # Timestamp when the configuration was created.
            'createdAt': 'DateTime', # DateTime
            # True if the robot should go to the tool position rather than joint values at the start of the cycle
            'cycleStartUseToolPose': 'Boolean', # Boolean
            # The default admin user's name
            'defaultAdminUsername': 'String', # String
            'destContainerEmptyOnChange': 'Boolean', # Boolean
            'destContainerInfo': 'Any', # [Any]
            # The name of the detector configuration.
            'detectorConfigurationName': 'String', # String
            # Keys of containerProperties, a list of candidates for the drop off location
            'dropOffLocationNames': 'String', # [String]
            # True, then enable externalCollisionIO
            'enableExternalCollision': 'Boolean', # Boolean
            # In mm. The distance that the robot will stay away from geometry and objects in the scene, unless it is picking them.
            'envclearance': 'Float', # Float
            # The fast detection mode for vision
            'fastDetectionMode': 'String', # String
            # If True, then the robot will add a finish position to the cycle even if "finish" is not present, unless "ignoreFinishPosition" is True in the order cycle command. "ignoreFinishPosition" overrides this parameter.
            'forceMoveToFinish': 'Boolean', # Boolean
            'forceRemoveObjectsOnStart': 'Any', # Any
            # ID of the configuration.
            'id': 'String', # String!
            # If True, then ignore the orderPartType coming from PLC when sending to planning and detector. This is used in cases like palletizing where the part is defined dynamically via the PLC signals
            'ignorePLCOrderTypeForPlanning': 'Boolean', # Boolean
            # True if the robot should ignore going to start position
            'ignoreStartPosition': 'Boolean', # Boolean
            # Image subscriber config
            'imagesubscriberConfiguration': 'Any', # Any
            'itlParameters': 'Any', # Any
            'itlProgramParameters': 'Any', # Any
            # The locale of the controller's user interface
            'locale': 'String', # String
            # Mapping from location index to location name
            'locationMapping': 'Any', # Any
            'maxConsecutivePackValidationErrors': 'Int', # Int
            # Maximum number of detection calls before quitting the loop. 0 means no limit.
            'maxNumObjectDetection': 'Int', # Int
            # Timestamp when the configuration was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # Defines whether to also move all available grippers when moving joints, even when gripper is not part of the currently selected tool.
            'moveAllGrippers': 'Boolean', # Boolean
            # Max acceleration when moving up after a pick.
            'moveDepartAccel': 'Float', # Float
            # In mm. Move up (against gravity) first before moving after picking
            'moveDepartOffsetAwayFromGravity': 'Float', # Float
            # The maximum jitter distance for a link
            'moveMaxJitterLinkDist': 'Float', # Float
            # The current limit ratio for each DOF (degree of freedom) of the robot. Length needs to match the number of robot DOFs.
            'moveToObjectCurrentLimitRatios': 'Float', # [Float]
            # Gripper values to move to when moving to the object.
            'moveToObjectGripperValues': 'Float', # [Float]
            # Name of the robot tool to use for getting close to objects
            'moveToObjectToolName': 'String', # String
            # pk (primary key) of the planning result of the "putting back" ITL program
            'movebackPlanningResultPk': 'String', # String
            # Type of the moveback program.
            'movebackProgramType': 'String', # String
            'movebackReverseChuck': 'Boolean', # Boolean
            # Maximum number of pieces in a single order before triggering moving back
            'movebackThreshold': 'Int', # Int
            # Network interface settings
            'networkInterfaceSettings': 'NetworkInterfaceSettings', # [NetworkInterfaceSettings]
            # If empty, uses the mujin controller URL
            'ntpServer': 'String', # String
            # Local stratum for the NTP Server
            'ntpStratum': 'Int', # Int
            # Goal position.
            'objectMoveSurfaceLocation': 'String', # String
            # in mm.
            'objectMoveSurfaceOffset': 'Float', # Float
            # List of (regular expression and pattern, uri) to use to substitute the container URIs depending on the container id codes
            'orderIDtoContainerURI': 'String', # [String]
            # Information about conversions for communicating with the PLC
            'plcConversionInfo': 'Any', # Any
            # Post cycle execution and conveyor parameters.
            'postCycleExecution': 'PostCycleExecutionConfigurations', # PostCycleExecutionConfigurations
            # If not empty, then the system gets configured to use a preparation cycle. If "nochange", then robot picks and places from the same sets of containers that it was prepared for. If "changeToDefaultPickIgnorePlace" then robot will always pick up from the sourcecontainername and place in the destcontainername as specified in binpicking parameters. If "nochangeIgnorePlace" then will pick up from same source container as prepared and ignore the dest container preparation since there is no dest preparation camera.
            'preparationCycleMode': 'String', # String
            'preparationDestContainername': 'Any', # Any
            'preparationSourceContainerName': 'Any', # Any
            'preparePlanForSameSourceContainer': 'Any', # Any
            'productionCycleInfo': 'Any', # Any
            'putPartsBackGripperValues': 'Any', # Any
            # For linking the imported configuration file to a file in the configuration library that is part of the runtime image.
            'referenceFilename': 'String', # String
            # The ID of the parent configuration of this configuration. Fields that are undefined in this configuration will be taken from the parent (recursively).
            'referenceId': 'String', # String
            'registrationbottomcolorcameranames': 'Any', # Any
            # password for logging into the mujin registration cell
            'registrationpassword': 'String', # String
            'registrationsidecolorcameranames': 'Any', # Any
            'registrationsystem': 'Any', # Any
            'registrationtopcameranames': 'Any', # Any
            'registrationtopcolorcameranames': 'Any', # Any
            # Mujin registration cell URL, e.g. http://controller14. If not set, the motion controller is used.
            'registrationurl': 'String', # String
            # username for logging into the mujin registration cell
            'registrationusername': 'String', # String
            # If True, then UI is in lock mode, disconnected from robotbridge
            'requestLockMode': 'Boolean', # Boolean
            # An optional list of (name, value) IOs to set when cycle just starts
            'resetControllerIOOnStartCycle': 'Any', # Any
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Latest revision id of the configuration.
            'revisionId': 'Int', # Int!
            # Settings for Robot Jogging
            'robotJogParameters': 'UserRobotJogParameters', # UserRobotJogParameters
            # Modifies the acceleration that the robot will move with.
            'robotaccelmult': 'Float', # Float
            # Name of the robot to use
            'robotname': 'String', # String
            # Modifies the speed that the robot will move at.
            'robotspeed': 'Float', # Float
            # URI of the scene file to load on the Mujin controller. e.g. mujin:/test.mujin.dae
            'sceneuri': 'String', # String
            # A list of target names to pick, from targetinfos dictionary
            'selectedtargetnames': 'String', # [String]
            # Define sensor streamer configuration.
            'sensorStreamerConfigs': 'SensorStreamerConfiguration', # [SensorStreamerConfiguration]
            'setIOOnResetErrorOrClear': 'Any', # Any
            # An optional list of (name, value) IOs to set when the cycle stops
            'setIOOnStopCycle': 'Any', # Any
            'sourceContainerInfo': 'Any', # Any
            'stopCycleOnError': 'Any', # Any
            # A list of finish codes for system to assume cycle is successful. Used to trigger backing up vision log. If None, never backing up.
            'successfulFinishCodeList': 'String', # [String]
            # A mapping from targetname to targetinfo. targetname is the base name of the target that points to the CAD model and detection configuration files.
            'targetinfos': 'Any', # Any
            # TODO
            'thirdPartySensorConfiguration': 'Any', # Any
            'timeOutForFailedParts': 'Float', # Float
            # If this is set, the object set will be cleared if more time has elapsed since the last registration.
            'timeToClearObjectSet': 'Float', # Float
            # The time zone of the controller
            'timezone': 'String', # String
            # Name of currently selected tool
            'toolname': 'String', # String
            'toolnameOrg': 'String', # String
            # The step size of Tweak Jogging
            'tweakstepsize': 'Float', # Float
            # The UI that should be displayed.
            'ui': 'String', # String
            # The current UI profile
            'uiProfile': 'String', # String
            # The unit of the length measurements used in the system.
            'unit': 'String', # String
            'useBackAndForth': 'Boolean', # Boolean
            'useDemoScenario': 'Boolean', # Boolean
            'useDestCameraObstacles': 'Boolean', # Boolean
            'useLayoutData': 'Boolean', # Boolean
            'usePutPartsBack': 'Boolean', # Boolean
            'useRegistration': 'Boolean', # Boolean
            # Configurable UI controls, do not affect how production system manager works
            'userInterface': 'UserInterfaceOptions', # UserInterfaceOptions
            # The password to switch usermode
            'usermodepassword': 'String', # String
            # A list of users
            'users': 'UserInfo', # [UserInfo]
            'verifPossibleContainers': 'Any', # Any
            # Vision Manager Configurations
            'visionManagerConfiguration': 'VisionManagerConfiguration', # VisionManagerConfiguration
            # Hostname of the vision manager running object recognition
            'visionManagerHost': 'String', # String
            # The password to communicate with vision
            'visionManagerPassword': 'String', # String
            'visionManagerPort': 'Int', # Int
            # The username to communicate with vision
            'visionManagerUserName': 'String', # String
        },

        'ControllerSystemConfigurationInput': {
            # If True, then auto-generate the Inverse Kinematics whenever idle
            'autoGenerateIk': 'Boolean', # Boolean
            # Whether to automatically set the VOI (Volume of Interest) of a streamer based on the container.
            'autoSetSensorVOI': 'String', # String
            # List of available UI profiles
            'availableUIProfiles': 'String', # [String]
            # Different parameters to configure binpicking pick and place cycle.
            'binpickingparameters': 'BinpickingParametersInput', # BinpickingParametersInput
            # NOTE: Will not add calib params here. Assuming they will live elsewhere
            'calibration': 'Any', # Any
            # NOTE: Will not add calib params here. Assuming they will live elsewhere
            'calibrationParameters': 'Any', # Any
            # NOTE: Will not add calib params here. Assuming they will live elsewhere
            'calibrationVerificationParameters': 'Any', # Any
            # The home position of the UI viewer virtual camera. Defines the view of the simulated system on startup.
            'cameraHome': 'UserCameraHomeInput', # UserCameraHomeInput
            # If True, will check the IK (Inverse Kinematics) before starting the cycle
            'checkIkGeneration': 'Boolean', # Boolean
            # If True, then will do partial occlusion checking for the robot and camera and report the partial image to the detector. For now, this is only usable for the devanning detector.
            'checkPartialOcclusion': 'Boolean', # Boolean
            # Clear object set when source container changes.
            'clearObjectSetOnContainerChanged': 'Boolean', # Boolean
            # Clear object set when part type changes.
            'clearObjectSetOnPartTypeChanged': 'Boolean', # Boolean
            # Clear object set when cycle starts. Useful to show demo of auto-registration.
            'clearObjectSetOnStartCycle': 'Boolean', # Boolean
            # A dictionary of the locations in the current system. Key is containername, value is a dictionary of location parameters: "cameranames"
            'containerProperties': 'Any', # Any
            # The password to connect to the controller
            'controllerpassword': 'String', # String
            # The Mujin Controller URL, e.g. http://controller14
            'controllerurl': 'String', # String
            # The username to connect to the controller
            'controllerusername': 'String', # String
            # If True, creates an object set on start cycle if one does not exist.
            'createEmptyObjectSetOnStartCycle': 'Boolean', # Boolean
            # True if the robot should go to the tool position rather than joint values at the start of the cycle
            'cycleStartUseToolPose': 'Boolean', # Boolean
            # The default admin user's name
            'defaultAdminUsername': 'String', # String
            'destContainerEmptyOnChange': 'Boolean', # Boolean
            'destContainerInfo': 'Any', # [Any]
            # The name of the detector configuration.
            'detectorConfigurationName': 'String', # String
            # Keys of containerProperties, a list of candidates for the drop off location
            'dropOffLocationNames': 'String', # [String]
            # True, then enable externalCollisionIO
            'enableExternalCollision': 'Boolean', # Boolean
            # In mm. The distance that the robot will stay away from geometry and objects in the scene, unless it is picking them.
            'envclearance': 'Float', # Float
            # The fast detection mode for vision
            'fastDetectionMode': 'String', # String
            # If True, then the robot will add a finish position to the cycle even if "finish" is not present, unless "ignoreFinishPosition" is True in the order cycle command. "ignoreFinishPosition" overrides this parameter.
            'forceMoveToFinish': 'Boolean', # Boolean
            'forceRemoveObjectsOnStart': 'Any', # Any
            # ID of the configuration.
            'id': 'String', # String
            # If True, then ignore the orderPartType coming from PLC when sending to planning and detector. This is used in cases like palletizing where the part is defined dynamically via the PLC signals
            'ignorePLCOrderTypeForPlanning': 'Boolean', # Boolean
            # True if the robot should ignore going to start position
            'ignoreStartPosition': 'Boolean', # Boolean
            # Image subscriber config
            'imagesubscriberConfiguration': 'Any', # Any
            'itlParameters': 'Any', # Any
            'itlProgramParameters': 'Any', # Any
            # The locale of the controller's user interface
            'locale': 'String', # String
            # Mapping from location index to location name
            'locationMapping': 'Any', # Any
            'maxConsecutivePackValidationErrors': 'Int', # Int
            # Maximum number of detection calls before quitting the loop. 0 means no limit.
            'maxNumObjectDetection': 'Int', # Int
            # Defines whether to also move all available grippers when moving joints, even when gripper is not part of the currently selected tool.
            'moveAllGrippers': 'Boolean', # Boolean
            # Max acceleration when moving up after a pick.
            'moveDepartAccel': 'Float', # Float
            # In mm. Move up (against gravity) first before moving after picking
            'moveDepartOffsetAwayFromGravity': 'Float', # Float
            # The maximum jitter distance for a link
            'moveMaxJitterLinkDist': 'Float', # Float
            # The current limit ratio for each DOF (degree of freedom) of the robot. Length needs to match the number of robot DOFs.
            'moveToObjectCurrentLimitRatios': 'Float', # [Float]
            # Gripper values to move to when moving to the object.
            'moveToObjectGripperValues': 'Float', # [Float]
            # Name of the robot tool to use for getting close to objects
            'moveToObjectToolName': 'String', # String
            # pk (primary key) of the planning result of the "putting back" ITL program
            'movebackPlanningResultPk': 'String', # String
            # Type of the moveback program.
            'movebackProgramType': 'String', # String
            'movebackReverseChuck': 'Boolean', # Boolean
            # Maximum number of pieces in a single order before triggering moving back
            'movebackThreshold': 'Int', # Int
            # Network interface settings
            'networkInterfaceSettings': 'NetworkInterfaceSettingsInput', # [NetworkInterfaceSettingsInput]
            # If empty, uses the mujin controller URL
            'ntpServer': 'String', # String
            # Local stratum for the NTP Server
            'ntpStratum': 'Int', # Int
            # Goal position.
            'objectMoveSurfaceLocation': 'String', # String
            # in mm.
            'objectMoveSurfaceOffset': 'Float', # Float
            # List of (regular expression and pattern, uri) to use to substitute the container URIs depending on the container id codes
            'orderIDtoContainerURI': 'String', # [String]
            # Information about conversions for communicating with the PLC
            'plcConversionInfo': 'Any', # Any
            # Post cycle execution and conveyor parameters.
            'postCycleExecution': 'PostCycleExecutionConfigurationsInput', # PostCycleExecutionConfigurationsInput
            # If not empty, then the system gets configured to use a preparation cycle. If "nochange", then robot picks and places from the same sets of containers that it was prepared for. If "changeToDefaultPickIgnorePlace" then robot will always pick up from the sourcecontainername and place in the destcontainername as specified in binpicking parameters. If "nochangeIgnorePlace" then will pick up from same source container as prepared and ignore the dest container preparation since there is no dest preparation camera.
            'preparationCycleMode': 'String', # String
            'preparationDestContainername': 'Any', # Any
            'preparationSourceContainerName': 'Any', # Any
            'preparePlanForSameSourceContainer': 'Any', # Any
            'productionCycleInfo': 'Any', # Any
            'putPartsBackGripperValues': 'Any', # Any
            # For linking the imported configuration file to a file in the configuration library that is part of the runtime image.
            'referenceFilename': 'String', # String
            # The ID of the parent configuration of this configuration. Fields that are undefined in this configuration will be taken from the parent (recursively).
            'referenceId': 'String', # String
            'registrationbottomcolorcameranames': 'Any', # Any
            # password for logging into the mujin registration cell
            'registrationpassword': 'String', # String
            'registrationsidecolorcameranames': 'Any', # Any
            'registrationsystem': 'Any', # Any
            'registrationtopcameranames': 'Any', # Any
            'registrationtopcolorcameranames': 'Any', # Any
            # Mujin registration cell URL, e.g. http://controller14. If not set, the motion controller is used.
            'registrationurl': 'String', # String
            # username for logging into the mujin registration cell
            'registrationusername': 'String', # String
            # If True, then UI is in lock mode, disconnected from robotbridge
            'requestLockMode': 'Boolean', # Boolean
            # An optional list of (name, value) IOs to set when cycle just starts
            'resetControllerIOOnStartCycle': 'Any', # Any
            # Settings for Robot Jogging
            'robotJogParameters': 'UserRobotJogParametersInput', # UserRobotJogParametersInput
            # Modifies the acceleration that the robot will move with.
            'robotaccelmult': 'Float', # Float
            # Name of the robot to use
            'robotname': 'String', # String
            # Modifies the speed that the robot will move at.
            'robotspeed': 'Float', # Float
            # URI of the scene file to load on the Mujin controller. e.g. mujin:/test.mujin.dae
            'sceneuri': 'String', # String
            # A list of target names to pick, from targetinfos dictionary
            'selectedtargetnames': 'String', # [String]
            # Define sensor streamer configuration.
            'sensorStreamerConfigs': 'SensorStreamerConfigurationInput', # [SensorStreamerConfigurationInput]
            'setIOOnResetErrorOrClear': 'Any', # Any
            # An optional list of (name, value) IOs to set when the cycle stops
            'setIOOnStopCycle': 'Any', # Any
            'sourceContainerInfo': 'Any', # Any
            'stopCycleOnError': 'Any', # Any
            # A list of finish codes for system to assume cycle is successful. Used to trigger backing up vision log. If None, never backing up.
            'successfulFinishCodeList': 'String', # [String]
            # A mapping from targetname to targetinfo. targetname is the base name of the target that points to the CAD model and detection configuration files.
            'targetinfos': 'Any', # Any
            # TODO
            'thirdPartySensorConfiguration': 'Any', # Any
            'timeOutForFailedParts': 'Float', # Float
            # If this is set, the object set will be cleared if more time has elapsed since the last registration.
            'timeToClearObjectSet': 'Float', # Float
            # The time zone of the controller
            'timezone': 'String', # String
            # Name of currently selected tool
            'toolname': 'String', # String
            'toolnameOrg': 'String', # String
            # The step size of Tweak Jogging
            'tweakstepsize': 'Float', # Float
            # The UI that should be displayed.
            'ui': 'String', # String
            # The current UI profile
            'uiProfile': 'String', # String
            # The unit of the length measurements used in the system.
            'unit': 'String', # String
            'useBackAndForth': 'Boolean', # Boolean
            'useDemoScenario': 'Boolean', # Boolean
            'useDestCameraObstacles': 'Boolean', # Boolean
            'useLayoutData': 'Boolean', # Boolean
            'usePutPartsBack': 'Boolean', # Boolean
            'useRegistration': 'Boolean', # Boolean
            # Configurable UI controls, do not affect how production system manager works
            'userInterface': 'UserInterfaceOptionsInput', # UserInterfaceOptionsInput
            # The password to switch usermode
            'usermodepassword': 'String', # String
            # A list of users
            'users': 'UserInfoInput', # [UserInfoInput]
            'verifPossibleContainers': 'Any', # Any
            # Vision Manager Configurations
            'visionManagerConfiguration': 'VisionManagerConfigurationInput', # VisionManagerConfigurationInput
            # Hostname of the vision manager running object recognition
            'visionManagerHost': 'String', # String
            # The password to communicate with vision
            'visionManagerPassword': 'String', # String
            'visionManagerPort': 'Int', # Int
            # The username to communicate with vision
            'visionManagerUserName': 'String', # String
        },

        'CopyLinkAndJointReturnValue': {
            # Copied joint.
            'joint': 'Joint', # Joint!
            # Copied link.
            'link': 'Link', # Link!
        },

        'CreateLinkAndJointReturnValue': {
            # Created joint. If created a base link then no joint will be created.
            'joint': 'Joint', # Joint
            # Created link.
            'link': 'Link', # Link!
        },

        # Parameters to be overwritten for the plan from intermediate destination to the final destination.
        'CycleOverwriteParameters': {
            # mm. The distance between the approach point P1 where the linear (slow) approach motion starts and the grasp point P2 where the robot stops and the gripper opens/closes to grasp the target item. 
            # 
            # It is appropriate to set the value at least as deep as the gripper's usual grasp depth (how far it moves into or towards the item to grasp it).
            # 
            # Setting a low value can cause A) collisions with noisy detections in the bin, and/or B) slower planning, as the final motions towards the grasp pose can be very constrained and sampling in joint space is inefficient. By default, the motion to the approach point P1 is sampled in joint space.
            # 
            # Common values are 30-100 mm. Setting a value that is too high can cause pick candidates to be discarded, as the approach motion may collide with e.g. container walls or be out of the robot's reach.
            'approachoffset': 'Float', # Float
            # Parameters used when placing a part at the destination when 'destCoordType' is targetAnyBottomFace.
            'destTargetAnyBottomFaceRotationParameters': 'DestTargetAnyBottomFaceRotationParameters', # DestTargetAnyBottomFaceRotationParameters
            # mm (x,y,z)
            'destapproachoffsetdir': 'Float', # [Float]
            # Coordinate system type of the destination. can be one of:
            # - 'tool' specifying the current tool,
            # - 'toolzntarget' specifying the point of the tool projected along the -z axis until the target boundary,
            # - 'target' specifying the original target coordinate system, or
            # - 'targetbottom' that offsets the target so its grasped bottom aligned with the ikparam, or
            # - 'targetAnyBottomFace' specifying that robot should put the target on its bottom face regardless of which grasp it makes. The center is aligned with the center of the target bounding box.
            # - 'targetAnyBottomFaceAlignedX' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the X axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceAlignedY' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the Y axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceXIsLongAxis' specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the longest side of the target with the X-axis of the goal. Will align so that the target X axis is always toward the X of the ikparam. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetCorner' - Align any corner of the target with the 6D coordinate system.
            # - 'targetStack' - stack targets on top of previously placed targets. Prioritize placement on lower stacks.
            # - 'targetAnyBottomBarCodeFace' - specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the registered known barcode faces to the barcode reader. if there are no known barcode faces, does the same as targetAnyBottomFaceXIsLongAxis. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetAABBAlignIk' - Align target's AABB with the dest ikparam
            'destcoordtype': 'String', # String
            # mm (x,y,z)
            'destdepartoffsetdir': 'Float', # [Float]
            # Parameters to define how to drop object to the destination.
            'dropInDestInfo': 'DropInDestInfo', # DropInDestInfo
            # mm (x,y,z)
            'graspDepartOffsetDir': 'Float', # [Float]
            # name of the grasp set to be used to pick up a target from the intermediate destination
            'graspsetname': 'String', # String
        },

        # Parameters to be overwritten for for the plan from source container to intermediate position.
        'CycleOverwriteParametersInput': {
            # mm. The distance between the approach point P1 where the linear (slow) approach motion starts and the grasp point P2 where the robot stops and the gripper opens/closes to grasp the target item. 
            # 
            # It is appropriate to set the value at least as deep as the gripper's usual grasp depth (how far it moves into or towards the item to grasp it).
            # 
            # Setting a low value can cause A) collisions with noisy detections in the bin, and/or B) slower planning, as the final motions towards the grasp pose can be very constrained and sampling in joint space is inefficient. By default, the motion to the approach point P1 is sampled in joint space.
            # 
            # Common values are 30-100 mm. Setting a value that is too high can cause pick candidates to be discarded, as the approach motion may collide with e.g. container walls or be out of the robot's reach.
            'approachoffset': 'Float', # Float
            # Parameters used when placing a part at the destination when 'destCoordType' is targetAnyBottomFace.
            'destTargetAnyBottomFaceRotationParameters': 'DestTargetAnyBottomFaceRotationParametersInput', # DestTargetAnyBottomFaceRotationParametersInput
            # mm (x,y,z)
            'destapproachoffsetdir': 'Float', # [Float]
            # Coordinate system type of the destination. can be one of:
            # - 'tool' specifying the current tool,
            # - 'toolzntarget' specifying the point of the tool projected along the -z axis until the target boundary,
            # - 'target' specifying the original target coordinate system, or
            # - 'targetbottom' that offsets the target so its grasped bottom aligned with the ikparam, or
            # - 'targetAnyBottomFace' specifying that robot should put the target on its bottom face regardless of which grasp it makes. The center is aligned with the center of the target bounding box.
            # - 'targetAnyBottomFaceAlignedX' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the X axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceAlignedY' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the Y axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceXIsLongAxis' specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the longest side of the target with the X-axis of the goal. Will align so that the target X axis is always toward the X of the ikparam. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetCorner' - Align any corner of the target with the 6D coordinate system.
            # - 'targetStack' - stack targets on top of previously placed targets. Prioritize placement on lower stacks.
            # - 'targetAnyBottomBarCodeFace' - specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the registered known barcode faces to the barcode reader. if there are no known barcode faces, does the same as targetAnyBottomFaceXIsLongAxis. Use 'destTargetAnyBottomFaceRotationParameter.facePlaceEdge' to control which corner to align the box with.
            # - 'targetAABBAlignIk' - Align target's AABB with the dest ikparam
            'destcoordtype': 'String', # String
            # mm (x,y,z)
            'destdepartoffsetdir': 'Float', # [Float]
            # Parameters to define how to drop object to the destination.
            'dropInDestInfo': 'DropInDestInfoInput', # DropInDestInfoInput
            # mm (x,y,z)
            'graspDepartOffsetDir': 'Float', # [Float]
            # name of the grasp set to be used to pick up a target from the intermediate destination
            'graspsetname': 'String', # String
        },

        # Info of precondition io checked before starting or resuming cycle
        'CyclePreconditionIOInfo': {
            # List of pairs of IO name and value
            'ioNameValueList': 'IONameValueDefinition', # [IONameValueDefinition]
        },

        # Info of precondition io checked before starting or resuming cycle
        'CyclePreconditionIOInfoInput': {
            # List of pairs of IO name and value
            'ioNameValueList': 'IONameValueDefinitionInput', # [IONameValueDefinitionInput]
        },

        # The value of a degree of freedom (e.g. rotation, translation)
        'DOFValue': {
            'jointAxis': 'Int', # Int!
            'jointName': 'String', # String!
            'value': 'Float', # Float!
        },

        # The value of a degree of freedom (e.g. rotation, translation)
        'DOFValueInput': {
            'jointAxis': 'Int', # Int!
            'jointName': 'String', # String!
            'value': 'Float', # Float!
        },

        'DeleteLinkAndJointReturnValue': {
            # ID of the deleted joint, if any.
            'jointId': 'String', # String
        },

        # Array of the pair of scaling multiplier and mass.
        'DestApproachAccelDecelScaleMultOnTargetMass': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # kg, Specifies target mass.
            'mass': 'Float', # Float
            # Specifies the number by which the dest approach accel and decel is multiplied.
            'scale': 'Float', # Float
        },

        # Array of the pair of scaling multiplier and mass.
        'DestApproachAccelDecelScaleMultOnTargetMassInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # kg, Specifies target mass.
            'mass': 'Float', # Float
            # Specifies the number by which the dest approach accel and decel is multiplied.
            'scale': 'Float', # Float
        },

        # Describes the barcode scanning on the dest
        'DestBarcodeScanningInfo': {
            # Can be set when there is more than one barcode reader that cover multiple faces at a time.
            'additionalBarcodeReader': 'String', # String
            # The template string of regular expression to check scanned barcodes. If this string contains '%%(partType)s',  '%%(partLot)', '%%(expectedBarcode)s', they will be replaced with given information (i.e. orderExpectedBarcode sent from PLC) before being sent to a barcode reader device bridge.
            'barcodeCheckPatternBase': 'String', # String
            # The name of the IO signal to set regular expression for pattern matching.
            'barcodeCheckPatternIOName': 'String', # String
            # IO name to be used to get scanned barcode for registration.
            'barcodeInfoIOName': 'String', # String
            # Gain for capturing of barcode scanner.
            'barcodeScanningGain': 'Float', # Float
            # Angular acceleration [deg/s^2] on dest linear motion while robot is grabbing an item.
            'destApproachAngularAccel': 'Float', # Float
            # Angular speed [deg/s] on dest linear motion while robot is grabbing an item.
            'destApproachAngularSpeed': 'Float', # Float
            # Angular acceleration [deg/s^2] on dest linear motion while robot is not grabbing an item.
            'destDepartAngularAccel': 'Float', # Float
            # Angular speed [deg/s] on dest linear motion while robot is not grabbing an item.
            'destDepartAngularSpeed': 'Float', # Float
            # If true, force plan next pick with new barcode face when barcode was found by searching. This can make
            'forcePlanWithNewBarcodeFace': 'Boolean', # Boolean
            # Lifting up offset x, y, z [mm] before performing rotation for scanning other faces.
            'liftingUpOffsetForRotation': 'Float', # [Float]
            # Maximum number of barcodes to read.
            'maxNumBarCodes': 'Int', # Int
            # Minimum number of barcodes to read.
            'minNumBarCodes': 'Int', # Int
            # If true, robot does placement with the initial orientation when barcode reader gets no read on all faces.
            'returnToInitialPlacementOnNoRead': 'Boolean', # Boolean
            # If true, robot only scans barcodes on minimum viable regions (unregistered objects).
            'scanMinViableRegionOnly': 'Boolean', # Boolean
            # Maximum duration [sec] to change setting of barcode scanner.
            'scannerBarCodeChangeMaxDuration': 'Float', # Float
            # Output delay [sec] to start barcode scanning
            'scannerSignalOutputDelay': 'Float', # Float
            # Output duration for [sec] each barcode scanning. This duration should be longer than necessary time to decode barcode by the scanner
            'scannerSignalOutputDuration': 'Float', # Float
            # Output interval [sec] between starting time of each barcode scanning
            'scannerSignalOutputInterval': 'Float', # Float
            # If true, robot only searches barcodes on longer side faces.
            'skipShorterFaceScanning': 'Boolean', # Boolean
            # Total number of barcodes to read in a face
            'totalNumBarCodes': 'Int', # Int
            # IO name to be used to propagate signal to device
            'triggerIOName': 'String', # String
            # If true, scanned barcode will be registered to database.
            'updateBarcodeRegistration': 'Boolean', # Boolean
            # Set to true to enable dest barcode scanning.
            'use': 'Boolean', # Boolean
            # Set to true to enable barcode pattern matching
            'useCheckBarCodeMatchPattern': 'Boolean', # Boolean
        },

        # Describes the barcode scanning on the dest
        'DestBarcodeScanningInfoInput': {
            # Can be set when there is more than one barcode reader that cover multiple faces at a time.
            'additionalBarcodeReader': 'String', # String
            # The template string of regular expression to check scanned barcodes. If this string contains '%%(partType)s',  '%%(partLot)', '%%(expectedBarcode)s', they will be replaced with given information (i.e. orderExpectedBarcode sent from PLC) before being sent to a barcode reader device bridge.
            'barcodeCheckPatternBase': 'String', # String
            # The name of the IO signal to set regular expression for pattern matching.
            'barcodeCheckPatternIOName': 'String', # String
            # IO name to be used to get scanned barcode for registration.
            'barcodeInfoIOName': 'String', # String
            # Gain for capturing of barcode scanner.
            'barcodeScanningGain': 'Float', # Float
            # Angular acceleration [deg/s^2] on dest linear motion while robot is grabbing an item.
            'destApproachAngularAccel': 'Float', # Float
            # Angular speed [deg/s] on dest linear motion while robot is grabbing an item.
            'destApproachAngularSpeed': 'Float', # Float
            # Angular acceleration [deg/s^2] on dest linear motion while robot is not grabbing an item.
            'destDepartAngularAccel': 'Float', # Float
            # Angular speed [deg/s] on dest linear motion while robot is not grabbing an item.
            'destDepartAngularSpeed': 'Float', # Float
            # If true, force plan next pick with new barcode face when barcode was found by searching. This can make
            'forcePlanWithNewBarcodeFace': 'Boolean', # Boolean
            # Lifting up offset x, y, z [mm] before performing rotation for scanning other faces.
            'liftingUpOffsetForRotation': 'Float', # [Float]
            # Maximum number of barcodes to read.
            'maxNumBarCodes': 'Int', # Int
            # Minimum number of barcodes to read.
            'minNumBarCodes': 'Int', # Int
            # If true, robot does placement with the initial orientation when barcode reader gets no read on all faces.
            'returnToInitialPlacementOnNoRead': 'Boolean', # Boolean
            # If true, robot only scans barcodes on minimum viable regions (unregistered objects).
            'scanMinViableRegionOnly': 'Boolean', # Boolean
            # Maximum duration [sec] to change setting of barcode scanner.
            'scannerBarCodeChangeMaxDuration': 'Float', # Float
            # Output delay [sec] to start barcode scanning
            'scannerSignalOutputDelay': 'Float', # Float
            # Output duration for [sec] each barcode scanning. This duration should be longer than necessary time to decode barcode by the scanner
            'scannerSignalOutputDuration': 'Float', # Float
            # Output interval [sec] between starting time of each barcode scanning
            'scannerSignalOutputInterval': 'Float', # Float
            # If true, robot only searches barcodes on longer side faces.
            'skipShorterFaceScanning': 'Boolean', # Boolean
            # Total number of barcodes to read in a face
            'totalNumBarCodes': 'Int', # Int
            # IO name to be used to propagate signal to device
            'triggerIOName': 'String', # String
            # If true, scanned barcode will be registered to database.
            'updateBarcodeRegistration': 'Boolean', # Boolean
            # Set to true to enable dest barcode scanning.
            'use': 'Boolean', # Boolean
            # Set to true to enable barcode pattern matching
            'useCheckBarCodeMatchPattern': 'Boolean', # Boolean
        },

        # Parameters used for computing target placement when 'destCoordType' is 'targetAABBAlignIk'
        'DestTargetAABBAlignIkParameters': {
            # After adjusting the target pose according to boxLocalOffset and quatLocalOffset, check and align the longer side of the target with the X-axis of placeIkParam. Mutually exclusive with alignLongAxisToY and alignLongAxisToZ.
            'alignLongAxisToX': 'Boolean', # Boolean
            # After adjusting the target pose according to boxLocalOffset and quatLocalOffset, check and align the longer side of the target with the Y-axis of placeIkParam. Mutually exclusive with alignLongAxisToX and alignLongAxisToZ.
            'alignLongAxisToY': 'Boolean', # Boolean
            # After adjusting the target pose according to boxLocalOffset and quatLocalOffset, check and align the longer side of the target with the Z-axis of placeIkParam. Mutually exclusive with alignLongAxisToX and alignLongAxisToY.
            'alignLongAxisToZ': 'Boolean', # Boolean
            # A vector whose elements are drawn from {-1, 0, 1}. It determines translation offsets between the target and the placeIkParam.
            'boxLocalOffset': 'Int', # [Int]
            # mm, Used when one of alignLongAxisTo<Axis> is enabled. When the different of width and depth of the target is greater than this value, will align the longer axis to the specified axis of placeIkParam.
            'dimensionThreshold': 'Float', # Float
            # Indicates which axis of placeIkParam is the *up* direction. This axis will then be the rotation axis when rotating the target according to alignLongAxisTo<Axis> param.
            'globalUpAxisInPlace': 'String', # String
            # A quaternion determining the orientation of the target with respect to placeIkParam.
            'quatLocalOffset': 'Float', # [Float]
        },

        # Parameters used for computing target placement when 'destCoordType' is 'targetAABBAlignIk'
        'DestTargetAABBAlignIkParametersInput': {
            # After adjusting the target pose according to boxLocalOffset and quatLocalOffset, check and align the longer side of the target with the X-axis of placeIkParam. Mutually exclusive with alignLongAxisToY and alignLongAxisToZ.
            'alignLongAxisToX': 'Boolean', # Boolean
            # After adjusting the target pose according to boxLocalOffset and quatLocalOffset, check and align the longer side of the target with the Y-axis of placeIkParam. Mutually exclusive with alignLongAxisToX and alignLongAxisToZ.
            'alignLongAxisToY': 'Boolean', # Boolean
            # After adjusting the target pose according to boxLocalOffset and quatLocalOffset, check and align the longer side of the target with the Z-axis of placeIkParam. Mutually exclusive with alignLongAxisToX and alignLongAxisToY.
            'alignLongAxisToZ': 'Boolean', # Boolean
            # A vector whose elements are drawn from {-1, 0, 1}. It determines translation offsets between the target and the placeIkParam.
            'boxLocalOffset': 'Int', # [Int]
            # mm, Used when one of alignLongAxisTo<Axis> is enabled. When the different of width and depth of the target is greater than this value, will align the longer axis to the specified axis of placeIkParam.
            'dimensionThreshold': 'Float', # Float
            # Indicates which axis of placeIkParam is the *up* direction. This axis will then be the rotation axis when rotating the target according to alignLongAxisTo<Axis> param.
            'globalUpAxisInPlace': 'String', # String
            # A quaternion determining the orientation of the target with respect to placeIkParam.
            'quatLocalOffset': 'Float', # [Float]
        },

        # Parameters used when placing a part at the destination when 'destCoordType' is targetAnyBottomFace.
        'DestTargetAnyBottomFaceRotationParameters': {
            # Extra travel dist when destCoordType is 'bottomAnyTargetXXX'. This will essentially try to place the object into the ground. If there is a conveyor sensor, robot should be able to stop and release the object before crashing into the conveyor (used for placing objects with unknown height.
            'extraTravelDist': 'Float', # Float
            # A vector of [-1,0,1] of where to place the box when destcoordtype is one of targetAnyBottomFace types. By default this is (0,0,-1) the bottom center.
            'facePlaceEdge': 'Float', # [Float]
            # If false, never tilt a part when the part is grabbed with its +Z or -Z surface
            'isTiltAllowedOnGrabbingZSurface': 'Boolean', # Boolean
            # deg, Limit the range of rotation in Z axis of a square target pose at a destination relative to that at a source container in the world frame to [permissibleSquareTargetZRotationRangeMin, permissibleSquareTargetZRotationRangeMax]. This parameter has an effect only when a target is treated as square shaped on the basis of treatAsSquareTargetExtentsThreshold.
            'permissibleSquareTargetZRotationRangeMax': 'Float', # Float
            # deg, Limit the range of rotation in Z axis of a square target pose at a destination relative to that at a source container in the world frame to [permissibleSquareTargetZRotationRangeMin, permissibleSquareTargetZRotationRangeMax]. This parameter has an effect only when a target is treated as square shaped on the basis of treatAsSquareTargetExtentsThreshold.
            'permissibleSquareTargetZRotationRangeMin': 'Float', # Float
            # deg, Limit the range of rotation in Z axis of a target pose at a destination relative to that at a source container in the world frame to [permissibleTargetZRotationRangeMin, permissibleTargetZRotationRangeMax].
            'permissibleTargetZRotationRangeMax': 'Float', # Float
            # deg, Limit the range of rotation in Z axis of a target pose at a destination relative to that at a source container in the world frame to [permissibleTargetZRotationRangeMin, permissibleTargetZRotationRangeMax].
            'permissibleTargetZRotationRangeMin': 'Float', # Float
            # Which direction to orient a target in the destination
            'rotationHeadingXAxis': 'String', # String
            # Used when placing a part at the destination when 'destCoordType' is targetAnyBottomFaceXIsLongAxis. If one or more angles are given, then can try placing a tilted target so that it drops on its largest face side. Only do this if new top face will be larger area. By default it is empty.
            'tiltAngles': 'Float', # [Float]
            # Used when placing a part at the destination when 'destCoordType' is targetAnyBottomFaceXIsLongAxis. Used if tiltAngles is not empty to determine whether the part should be tilted or not depending on what face the robot grasps. The threshold is on tiltExtentsRatioThresh * min(extents[0], extents[1]) < extents[2].
            'tiltExtentsRatioThresh': 'Float', # Float
            # mm, Used when placing a part at the destination when 'destCoordType' is targetAnyBottomFaceXIsLongAxis. Used if tiltAngles is not empty to determine whether the part should be tilted or not depending on what face the robot grasps. The threshold is on min(extents[0], extents[1]) + fTargetBottomTiltExtentsThresh < extents[2].
            'tiltExtentsThresh': 'Float', # Float
            # Valid if fTargetBottomTiltAngle is > 0. If 0, tilts on long-edge both sides. If > 0, tilts on the positive side only, if < 0, tilts on the negative side only. (for moving conveyors).
            'tiltLongSide': 'Int', # Int
            # Valid if fTargetBottomTiltAngle is > 0. If 0, tilts on the short-edge both sides. If > 0, tilts on the positive side only, if < 0, tilts on the negative side only. (for moving conveyors).
            'tiltShortSide': 'Int', # Int
            # If true, always tilt a part when the part is grabbed with its smallest area surface
            'tiltTargetOnGrabbingSmallestSurface': 'Boolean', # Boolean
            # When a part is tilted for placement, the translation distance during tilting will be multiplied by this amount. If > 1.0, a part is dragged for the tilting direction. This is useful to prevent a sagging part from getting stuck between the ground and the tool.
            'tiltTranslationDistanceMult': 'Float', # Float
            # mm, If > 0, when the difference of X and Y target edge lengths is smaller than this, the target is treated as square shaped and all placement directions are considered without trying to align a longer edge to X axis of a destination.
            'treatAsSquareTargetExtentsThreshold': 'Float', # Float
            # Usually +Z of the target should match +Z of the dest coord. If +1, then also allow -Z of the target to match with +Z of the dest coord. If 0, then not allow -Z of the target to match with +Z of the dest coord. If -1, system will decide automatically.
            'useUpAxisFlip': 'Int', # Int
        },

        # Parameters used when placing a part at the destination when 'destCoordType' is targetAnyBottomFace.
        'DestTargetAnyBottomFaceRotationParametersInput': {
            # Extra travel dist when destCoordType is 'bottomAnyTargetXXX'. This will essentially try to place the object into the ground. If there is a conveyor sensor, robot should be able to stop and release the object before crashing into the conveyor (used for placing objects with unknown height.
            'extraTravelDist': 'Float', # Float
            # A vector of [-1,0,1] of where to place the box when destcoordtype is one of targetAnyBottomFace types. By default this is (0,0,-1) the bottom center.
            'facePlaceEdge': 'Float', # [Float]
            # If false, never tilt a part when the part is grabbed with its +Z or -Z surface
            'isTiltAllowedOnGrabbingZSurface': 'Boolean', # Boolean
            # deg, Limit the range of rotation in Z axis of a square target pose at a destination relative to that at a source container in the world frame to [permissibleSquareTargetZRotationRangeMin, permissibleSquareTargetZRotationRangeMax]. This parameter has an effect only when a target is treated as square shaped on the basis of treatAsSquareTargetExtentsThreshold.
            'permissibleSquareTargetZRotationRangeMax': 'Float', # Float
            # deg, Limit the range of rotation in Z axis of a square target pose at a destination relative to that at a source container in the world frame to [permissibleSquareTargetZRotationRangeMin, permissibleSquareTargetZRotationRangeMax]. This parameter has an effect only when a target is treated as square shaped on the basis of treatAsSquareTargetExtentsThreshold.
            'permissibleSquareTargetZRotationRangeMin': 'Float', # Float
            # deg, Limit the range of rotation in Z axis of a target pose at a destination relative to that at a source container in the world frame to [permissibleTargetZRotationRangeMin, permissibleTargetZRotationRangeMax].
            'permissibleTargetZRotationRangeMax': 'Float', # Float
            # deg, Limit the range of rotation in Z axis of a target pose at a destination relative to that at a source container in the world frame to [permissibleTargetZRotationRangeMin, permissibleTargetZRotationRangeMax].
            'permissibleTargetZRotationRangeMin': 'Float', # Float
            # Which direction to orient a target in the destination
            'rotationHeadingXAxis': 'String', # String
            # Used when placing a part at the destination when 'destCoordType' is targetAnyBottomFaceXIsLongAxis. If one or more angles are given, then can try placing a tilted target so that it drops on its largest face side. Only do this if new top face will be larger area. By default it is empty.
            'tiltAngles': 'Float', # [Float]
            # Used when placing a part at the destination when 'destCoordType' is targetAnyBottomFaceXIsLongAxis. Used if tiltAngles is not empty to determine whether the part should be tilted or not depending on what face the robot grasps. The threshold is on tiltExtentsRatioThresh * min(extents[0], extents[1]) < extents[2].
            'tiltExtentsRatioThresh': 'Float', # Float
            # mm, Used when placing a part at the destination when 'destCoordType' is targetAnyBottomFaceXIsLongAxis. Used if tiltAngles is not empty to determine whether the part should be tilted or not depending on what face the robot grasps. The threshold is on min(extents[0], extents[1]) + fTargetBottomTiltExtentsThresh < extents[2].
            'tiltExtentsThresh': 'Float', # Float
            # Valid if fTargetBottomTiltAngle is > 0. If 0, tilts on long-edge both sides. If > 0, tilts on the positive side only, if < 0, tilts on the negative side only. (for moving conveyors).
            'tiltLongSide': 'Int', # Int
            # Valid if fTargetBottomTiltAngle is > 0. If 0, tilts on the short-edge both sides. If > 0, tilts on the positive side only, if < 0, tilts on the negative side only. (for moving conveyors).
            'tiltShortSide': 'Int', # Int
            # If true, always tilt a part when the part is grabbed with its smallest area surface
            'tiltTargetOnGrabbingSmallestSurface': 'Boolean', # Boolean
            # When a part is tilted for placement, the translation distance during tilting will be multiplied by this amount. If > 1.0, a part is dragged for the tilting direction. This is useful to prevent a sagging part from getting stuck between the ground and the tool.
            'tiltTranslationDistanceMult': 'Float', # Float
            # mm, If > 0, when the difference of X and Y target edge lengths is smaller than this, the target is treated as square shaped and all placement directions are considered without trying to align a longer edge to X axis of a destination.
            'treatAsSquareTargetExtentsThreshold': 'Float', # Float
            # Usually +Z of the target should match +Z of the dest coord. If +1, then also allow -Z of the target to match with +Z of the dest coord. If 0, then not allow -Z of the target to match with +Z of the dest coord. If -1, system will decide automatically.
            'useUpAxisFlip': 'Int', # Int
        },

        # Parameters used when placing targets at the destination with 'destCoordType' being 'targetCorner'.
        'DestTargetCornerParameters': {
            # mm. A destination is filtered out if the distance between its ik parameter and the actual target's corner is bigger than this threshold. If we enable safety region, the actual target's corner will deviate from the destination ik parameter. If this threshold is negative, then invalid (not used).
            'destFilterByTargetCornerDistThresh': 'Float', # Float
            # mm. An extra travel distance to be added to destination approach/depart offsets.
            'travelDist': 'Float', # Float
        },

        # Parameters used when placing targets at the destination with 'destCoordType' being 'targetCorner'.
        'DestTargetCornerParametersInput': {
            # mm. A destination is filtered out if the distance between its ik parameter and the actual target's corner is bigger than this threshold. If we enable safety region, the actual target's corner will deviate from the destination ik parameter. If this threshold is negative, then invalid (not used).
            'destFilterByTargetCornerDistThresh': 'Float', # Float
            # mm. An extra travel distance to be added to destination approach/depart offsets.
            'travelDist': 'Float', # Float
        },

        # Parameters used when placing targets at the destination with 'destCoordType' being 'targetStack'.
        'DestTargetStackParameters': {
            # mm. How much to approach in X-/Y-directions during the final step when stacking a part.
            'destApproachOffsetByXY': 'Float', # Float
            # mm. How much to approach in Z-direction during the final step when stacking a part.
            'destApproachOffsetByZ': 'Float', # Float
            # deg. How much to angle the corner of the part towards while approaching the destination.
            'destApproachRotationAngle': 'Float', # Float
            # How much to penalize destinations on higher stacks. The higher the number, the more likely a target is put on a lower stack.
            'destHeightPenaltyMult': 'Float', # Float
            # mm. When placing the target onto another target, how much it sinks in its local Z when it is on top.
            'offsetDist': 'Float', # Float
            # mm. The limit on how high from the container bottom a stack of targets can be. If the limit is zero, then not using it.
            'stackHeightLimit': 'Float', # Float
        },

        # Parameters used when placing targets at the destination with 'destCoordType' being 'targetStack'.
        'DestTargetStackParametersInput': {
            # mm. How much to approach in X-/Y-directions during the final step when stacking a part.
            'destApproachOffsetByXY': 'Float', # Float
            # mm. How much to approach in Z-direction during the final step when stacking a part.
            'destApproachOffsetByZ': 'Float', # Float
            # deg. How much to angle the corner of the part towards while approaching the destination.
            'destApproachRotationAngle': 'Float', # Float
            # How much to penalize destinations on higher stacks. The higher the number, the more likely a target is put on a lower stack.
            'destHeightPenaltyMult': 'Float', # Float
            # mm. When placing the target onto another target, how much it sinks in its local Z when it is on top.
            'offsetDist': 'Float', # Float
            # mm. The limit on how high from the container bottom a stack of targets can be. If the limit is zero, then not using it.
            'stackHeightLimit': 'Float', # Float
        },

        'DeviceConfiguration': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Name of the device bridge to load
            'deviceBridgeType': 'String', # String
            # ID of the device
            'devicename': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Set to false to disable device.
            'use': 'Boolean', # Boolean
        },

        # Parameters for measuring the height of a target object with a 1D distance sensor. Setting up these parameters will send timed IO values as the robot trajectory is executed.
        'DistanceMeasurementInfo': {
            # Name of object in environment that represents this distance sensor
            'objectName': 'String', # String
            # The name of the IO to use to trigger the distance sensor capture.
            'triggerIOName': 'String', # String
            # sec, How much to delay the IO signal of the distance from the ideal time that the system thinks the barcode will be in the center of the sensor. Communication and robot motion delays can cause slight differences in timing, which this parameter can account for.
            'triggerOutputDelay': 'Float', # Float
            # sec, The amount of time to keep the distance sensor snapping new data
            'triggerOutputDuration': 'Float', # Float
            # Set to true to enable distance measurement info.
            'use': 'Boolean', # Boolean
        },

        # Parameters for measuring the height of a target object with a 1D distance sensor. Setting up these parameters will send timed IO values as the robot trajectory is executed.
        'DistanceMeasurementInfoInput': {
            # Name of object in environment that represents this distance sensor
            'objectName': 'String', # String
            # The name of the IO to use to trigger the distance sensor capture.
            'triggerIOName': 'String', # String
            # sec, How much to delay the IO signal of the distance from the ideal time that the system thinks the barcode will be in the center of the sensor. Communication and robot motion delays can cause slight differences in timing, which this parameter can account for.
            'triggerOutputDelay': 'Float', # Float
            # sec, The amount of time to keep the distance sensor snapping new data
            'triggerOutputDuration': 'Float', # Float
            # Set to true to enable distance measurement info.
            'use': 'Boolean', # Boolean
        },

        # Parameters to define how to drop object to the destination.
        'DropInDestInfo': {
            # Set to true to check if sensors are turned ON at the end of the trajectory.
            'atEndIOCheck': 'Boolean', # Boolean
            # Deceleration multiplier to start slowing down robot when sensors for deceleration defined in [ioSensors]  goes to ON.
            'decelMultAfterIOMatches': 'Float', # Float
            # mm/s, Deceleration speed to slow down to when robot gets when sensors for deceleration defined in [ioSensors]  goes to ON. If 0, then disabled. Overrides the decelMultAfterIOMatches multiplier.
            'decelSpeedAfterIOMatches': 'Float', # Float
            # Set to true, then if the sensor is being blocked, then the value specified by 'ioname' will be ON (true). If false, then blocking means 'ioname' value will be OFF (false)
            'expectedIOValueWhenBlocking': 'Boolean', # Boolean
            # Definition of sensors to trigger deceleration or stopping of robot.
            'ioSensors': 'TriggerDecelIOSensorDefinition', # [TriggerDecelIOSensorDefinition]
            # Parameters for generating a connecting trajectory, which is a trajectory segment connecting the current robot values (which may be the result of the robot stopping due to io sensors) with the initial robot values of the next trajectory to be executed.
            'mergeTrajectoryParameters': 'MergeTrajectoryParameters', # MergeTrajectoryParameters
            # If io signals defined in [ioSensors] are ON when robot picks up a part, robot will pause when they are ON and robot and grabbed target is not in sensible region of the sensors. This makes the system safe if there is a problem with the sensors.
            'pauseIfStopIOInitiallyON': 'Boolean', # Boolean
            # Seconds, this value determines how long robot will pause by [ioSensors] being ON when robot pics up a part. Valid only when pauseIfStopIOInitiallyON is true
            'pauseTimeOutDuration': 'Float', # Float
            # The body names for sensible region of ioSsensors
            'regionBodyNames': 'String', # [String]
            # Set to true to enable drop in dest info.
            'use': 'Boolean', # Boolean
        },

        # Parameters to define how to drop object to the destination.
        'DropInDestInfoInput': {
            # Set to true to check if sensors are turned ON at the end of the trajectory.
            'atEndIOCheck': 'Boolean', # Boolean
            # Deceleration multiplier to start slowing down robot when sensors for deceleration defined in [ioSensors]  goes to ON.
            'decelMultAfterIOMatches': 'Float', # Float
            # mm/s, Deceleration speed to slow down to when robot gets when sensors for deceleration defined in [ioSensors]  goes to ON. If 0, then disabled. Overrides the decelMultAfterIOMatches multiplier.
            'decelSpeedAfterIOMatches': 'Float', # Float
            # Set to true, then if the sensor is being blocked, then the value specified by 'ioname' will be ON (true). If false, then blocking means 'ioname' value will be OFF (false)
            'expectedIOValueWhenBlocking': 'Boolean', # Boolean
            # Definition of sensors to trigger deceleration or stopping of robot.
            'ioSensors': 'TriggerDecelIOSensorDefinitionInput', # [TriggerDecelIOSensorDefinitionInput]
            # Parameters for generating a connecting trajectory, which is a trajectory segment connecting the current robot values (which may be the result of the robot stopping due to io sensors) with the initial robot values of the next trajectory to be executed.
            'mergeTrajectoryParameters': 'MergeTrajectoryParametersInput', # MergeTrajectoryParametersInput
            # If io signals defined in [ioSensors] are ON when robot picks up a part, robot will pause when they are ON and robot and grabbed target is not in sensible region of the sensors. This makes the system safe if there is a problem with the sensors.
            'pauseIfStopIOInitiallyON': 'Boolean', # Boolean
            # Seconds, this value determines how long robot will pause by [ioSensors] being ON when robot pics up a part. Valid only when pauseIfStopIOInitiallyON is true
            'pauseTimeOutDuration': 'Float', # Float
            # The body names for sensible region of ioSsensors
            'regionBodyNames': 'String', # [String]
            # Set to true to enable drop in dest info.
            'use': 'Boolean', # Boolean
        },

        # Dynamic goals generator parameters. Used only if useDynamicGoals is True
        'DynamicGoalsConfig': {
            # mm, the discretization step size in XY. Smaller the step, placement more precise, but computation time increase quadratically
            'deltastepsize': 'Float', # Float
            # If true, create a depart enough so that tool clears the container wall.
            'departToClearContainerWall': 'Boolean', # Boolean
            # If true, create a depart enough so that tool clears the contents inside container.
            'departToClearContents': 'Boolean', # Boolean
            # mm, The minimum height to clear when departing. This is used to make sure robot can support multiple container heights going through it while departing with the maximum height.
            'departToClearMinHeight': 'Float', # Float
            # mm, The minimum height to clear when departing only for the last pick. This is used to make sure robot can support multiple container heights going through it while departing with the maximum height during the final pick.
            'departToClearMinHeightAtFinal': 'Float', # Float
            # deg, approach angle for diagonal dest approach around x and y axis (parallel to the floor of the container) in container coordinates, means how much deviate from placement position
            'destApproachAngle': 'Float', # Float
            # List of destination approach offset to force dynamic goal generator special final movement. Dynamic goal generator will generate destination goals for each of the force final offset if possible.
            'destApproachForceFinalOffsets': 'Float', # [[Float]]
            # The dest approach mode. Types are:
            # - **default**  - Robot tries to be safe while minimizing linear approach.
            # - **highestEdge** - Robot tries to approach highest edge first.
            'destApproachMode': 'String', # String
            # mm, distance for diagonal destination approach offset for x and y axis (parallel to the floor of the container) in container coordinates
            'destApproachOffsetByXY': 'Float', # Float
            # mm, distance to start moving linear on Z axis.
            'destApproachOffsetByZ': 'Float', # Float
            # Multiplier of how much to consider accumulated approach for tool to depart from placement.
            'destDepartAccumApproachDirMult': 'Float', # Float
            # mm, Extra distance for departing on z axis once part is released in container coordinates. The bigger it is, the more the longer the linear movement becomes.
            'destDepartOffsetByZ': 'Float', # Float
            # mm, Extra distance for departing on xy axis once part is placed near container wall. The bigger it is, the more the longer the linear movement becomes.
            'destDepartOffsetXYFromWall': 'Float', # Float
            # ratio, the part can be dropped from the part height multiplied by this ratio. 1.0 means, that the part can be dropped from the height of its size
            'destDropRatio': 'Float', # Float
            # mm, Distance from the surface to place a box the surface can be bottom of the container or another box. depth matrices are still initialized at 0, just that the ikparam where the tool goes is offset
            'dropOffsetZ': 'Float', # Float
            # The dynamic packing mode. Types are:
            # - **default**  - Default algorithm that packs first layer, then goes to second layer.
            # - **stacking** - Prioritize stacking objects on top of each other before filling the first layer.
            'dynamicPackingMode': 'String', # String
            # discrete gradient, threshold for magnitute of gradient depth map image for determining edges
            'edgedetectorThresh': 'Float', # Float
            # If true, then the dest container has no walls and dynamic goal generation can assume that the robot can approach through the virtual walls. This makes the generated goal easier.
            'ignoreContainerWalls': 'Boolean', # Boolean
            # The number of voxels to ensure that are empty around the object before trying to place it. The higher the number, the more conservative/safe the system chooses the goals.
            'intGoalsPackingClearance': 'Int', # Int
            # voxels, maximum jitter offset to be applied on the placed item to confirm that placement of the object is stable. That means that item will be moved by this amount from the placement positions to confirm stable placement
            'intJitterPlacementOffset': 'Int', # Int
            # voxels, applied only when packing is used. The computed package will be offset from the computed position for at maximum this parameter. When not set the package will move to the open face of the cage with 3 walls, to the open corner when cage has 2 walls as a corner and center pacakge if cage is a cart (walls are opposite sides).
            'intMaxPackageTranslationOffsetXY': 'Int', # [Int]
            # voxels, How many grids to stay away from walls. Used when there is point cloud noise along the walls.
            'intOffsetFromWallRange': 'Int', # Int
            # voxels, the maximum allowed offset for packing placement check if packing placement is not available. Used only for packing formation computation verification.
            'intPackingCheckGoalsOffset': 'Int', # Int
            # voxels, two adjacent sides of the target object should have supporting walls from the existing depth map. A region is supporting when its points are within this range from the sides of the target.
            'intSupportingWallRange': 'Int', # Int
            # The target will be grabbed by a tool when it is placed inside the container. By specifying the tool XY size, can assure that the target will not be placed too close to walls so that it is impossible for the tool to place.
            'intToolXYSize': 'Int', # [Int]
            # ratio, maximum jitter offset of the item's COM to be applied on the placed item to confirm that placement of the object is stable. That means that item will be moved by ratio*(size of the item) per each dimension from the placement positions to confirm stable placement
            'jitterCOMRatioOffset': 'Float', # Float
            # mm, If > 0, then the max distance the COM can be above the wall height. By default will constraint the target COM under the wall height (maxWallHeightOfContainer). If < 0, then need to have COM under. By default, this is very large.
            'maxDistOfCOMAboveWallHeight': 'Float', # Float
            # mm, the max height of any point on the target that can be placed in the container. Usually at the container top, but can be extended to be a little bit out. Used to filter out targets placed too high. If set to 0, use the height of the container
            'maxHeightOfTargetInContainer': 'Float', # Float
            # Used only when dynamicgoals following the pack. Maximum number of destination approaches to compute. 0 means compute as much as can find. More destination approaches computed makes planning slower, but increases success rate.
            'maxNumDestApproachesToCompute': 'Int', # Int
            # mm (x,y,z), maximum deviation of the part size. All packing items input size will add the maxPartFullSizeDeviation for the package computation to ensure that the real item can be packed safely in the planned position.
            'maxPartFullSizeDeviation': 'Float', # [Float]
            # mm, The max placement height of the bottom edge of the target.
            'maxPlacementHeightOfTarget': 'Float', # Float
            # mm, The maximum placement height of the bottom edge of the target above wall which is allowed. If negative then targets will be placed below the wall. Valid only if maxPlacementHeightOfTarget is not defined.
            'maxPlacementHeightOffsetAboveWall': 'Float', # Float
            # mm, the max noise of the point cloud inside the container. This is used for computing the pack dimensions by not considering areas which the point cloud hits the bottom of the surface.
            'maxPointCloudNoise': 'Float', # Float
            # mm, if > 0, then the max distance the target top can be above the wall height. By default will constraint the target under the wall height (_maxWallHeightOfContainer). If < 0, then need to have the target under. By default, this is very large.
            'maxTargetAboveWallHeight': 'Float', # Float
            # mm, median filter will be applied for the depth matrix cell only if the difference between depth value before median filter and filtered depth value is smaller than this parameter. The median filtered depth value will be always applied if the parameter not set.
            'medianFilterMaxZOffsetToOverwrite': 'Float', # Float
            # mm, median window filter full size to apply to the pointcloud for dynamicgoals generation. Bigger the value more noise is filtered, but if too big the obstacles can be filtered out.
            'medianFilterWindowSize': 'Float', # Float
            # mm, The minum edge wall height to consider for edge walls and approach
            'minEdgeWallZHeight': 'Float', # Float
            # ratio, for every target, the minimum supporting region area below it necessary for acceptance of the placement position
            'minSupportingAreaRatio': 'Float', # Float
            # If True, then normalizes the input packFormation to a corner of the empty region. By default this is True since packs can be generated from a canonical cage/pallet, and need to be fit to the current place container. If packs are being planned with the current dest container in mind, then set this to False.
            'normalizePackToEmptyRegion': 'Boolean', # Boolean
            # ratio, parameter for increasing supporting region because of closiness to walls. if the item placed within 'notFallRatioNearWall' * 'item size' from the wall it assumed to be supported. The value for packing computation should be smaller than for real robot execution systems to compensate discretization difference.
            'notFallRatioNearWall': 'Float', # Float
            # If True, then the most recent point cloud will overwrite any placed object info that have been placed before the point cloud arrived. This is used
            'overwritePlacementWithDynamicPointCloud': 'Boolean', # Boolean
            # Mode to follow packing computed by Mujin packing cluster. Used only if packFormationComputationResult provided. 
            #             - **none**  - none, no specific requirement for following the pack;
            #             - **strict**  - check that inputPartIndex is following the order and all previous items packed by robot;
            #             - **strictStopOnFailure** - similar to **strict**, but execution stops only if cannot continue packing with "FinishedNoMoreDestOutOfOrder" error.
            #             - **smallerFirst**  - iterates for all possible placements and taking the first partIndex where the item can be placed,
            #             - **smallerFirstThenStrict**  - iterates for all possible placements and taking the first partIndex where the item can be placed for the first item in pick and place order request. Next items will follow the pack strictly starting from the succesful placement of the 1st item.
            'packFollowMode': 'String', # String
            # Pivot check position mode, changes the priority of search of dynamic goals by prioritizing the closest to the pivot. Possible prioritization is:
            #             - **NXNY**  - negative X and negative Y corner in local coordinates of the container,
            #             - **NXCY**  - negative X and center Y side in local coordinates of the container,
            #             - **NXPY**  - negative X and positive Y corner in local coordinates of the container,
            #             - **CXNY**  - center X and negative Y side in local coordinates of the container,
            #             - **CXCY**  - center of the container,
            #             - **CXPY**  - center X and positive Y side in local coordinates of the container,
            #             - **PXNY**  - positive X and negative Y corner in local coordinates of the container,
            #             - **PXCY**  - positive X and center Y side in local coordinates of the container,
            #             - **PXPY**  - positive X and positive Y corner in local coordinates of the container,
            'pivotCheckPositionMode': 'String', # String
            # placement area of the container by height from the container floor. Usually used when sensor visibility cannot cover entire container area close to the sensor.
            'placementAreaByHeightInfos': 'PlacementAreaByHeightInfo', # [PlacementAreaByHeightInfo]
            # mm, distance from the surface to place a box the surface can be bottom of the container or another box
            'placementOfBoxFromSurface': 'Float', # Float
            # Placement to rioritize placement of the dynamicgoal generated placements. Bigger coefficient means prioritize placement by the criteria. Negative means penalize. All criterias are normalized, the minimum value of the criteria is 0.0, the maximum is 1.0.
            'placementPriorityParameters': 'PlacementPriorityParameters', # PlacementPriorityParameters
            # If true and using pack formation result then if the placement is not possible into ordere packing placement, then will continue packing using random packing placement caomputation. If false and using pack formation result then will raise an error if placement is not possible into requested packing placement index.
            'randomPackingModeAllowed': 'Boolean', # Boolean
            # If True, reject all z-only approaches when there are other candidates with xy-movements. Keep the generated z-approach if only and only if it is the sole candidate. Make the parameter False when intOppositeObject clearance is big and linear z-only approach is always safe for all different items.
            'rejectUnsafeZApproach': 'Boolean', # Boolean
            # If True, then do not validate the used pack formation before placing targets with respect to it. Set to False by default.
            'skipPackFormationValidation': 'Boolean', # Boolean
            # ratio, how much of the box side has to be near the wall or another box and has to pass the target height test controlled by _supportingWallTargetHeightRatio.
            'supportingWallEdgeRatio': 'Float', # Float
            # ratio, the percentage of box height that all the supporting wall regions have to be greater than for the placement to be accepted.
            'supportingWallTargetHeightRatio': 'Float', # Float
            # mm, given the z placement of the target, all regions in depthmap that are within this range will be counted as supporting regions
            'supportingZRange': 'Float', # Float
            # mm, tool erosion windoe size, how much to errode tooldepth matrix (similar to the clearance around the tool.
            'toolDepthErosionWindowSize': 'Float', # Float
            # mm, all tool depth matrix values will be increased to at least this value. The value is the same as the distance between tool point and real metal hand to ignore collision of suction foams with already placed parts.
            'toolDepthMinDeadRegion': 'Float', # Float
            # mm, clearance from the top approaching surface. Due to point cloud noise, robot has to make sure grabbed part bottom is away from any top surfaces from existing point cloud by this amount. A good value has to be greater than executionVerificationInfo/bottomOverhangForPushVerificationXYZ[2], otherwise execution verification will keep on triggering.
            'topApproachSurfaceClearance': 'Float', # Float
            # mm, when approaching a tight space and there are walls on both sides, describes the min height difference of the walls that will still allow the robot to go inside.
            'topEdgeMinIntersection': 'Float', # Float
            # to use dynamic goals generation to define position of the items in the destcontainername
            'use': 'Boolean', # Boolean
            # a bitmask, 0x1 means use 0 degrees rotation around the axis pointing up direction of the container, 0x2 means use 90 degrees rotation around the axis pointing up direction of the container for placement
            'use90DegreesRotations': 'Int', # Int
            # 0 or 1, specifies if dynamic goal generator should use point cloud from camera for placement
            'useDynamicPointCloud': 'Int', # Int
            # 0 or 1, specifies if dynamic goal generator should use layout data coming from PLC or not
            'useLayoutData': 'Int', # Int
            # Set to true to enable tilt placement for tall standing items
            'useTiltPlacement': 'Boolean', # Boolean
            # When set, will validate that all placed objects on the pack are still guaranteed that can be picked up by the gripper in any order.
            'validatePlacedAllPickable': 'Boolean', # Boolean
        },

        # Dynamic goals generator parameters. Used only if useDynamicGoals is True
        'DynamicGoalsConfigInput': {
            # mm, the discretization step size in XY. Smaller the step, placement more precise, but computation time increase quadratically
            'deltastepsize': 'Float', # Float
            # If true, create a depart enough so that tool clears the container wall.
            'departToClearContainerWall': 'Boolean', # Boolean
            # If true, create a depart enough so that tool clears the contents inside container.
            'departToClearContents': 'Boolean', # Boolean
            # mm, The minimum height to clear when departing. This is used to make sure robot can support multiple container heights going through it while departing with the maximum height.
            'departToClearMinHeight': 'Float', # Float
            # mm, The minimum height to clear when departing only for the last pick. This is used to make sure robot can support multiple container heights going through it while departing with the maximum height during the final pick.
            'departToClearMinHeightAtFinal': 'Float', # Float
            # deg, approach angle for diagonal dest approach around x and y axis (parallel to the floor of the container) in container coordinates, means how much deviate from placement position
            'destApproachAngle': 'Float', # Float
            # List of destination approach offset to force dynamic goal generator special final movement. Dynamic goal generator will generate destination goals for each of the force final offset if possible.
            'destApproachForceFinalOffsets': 'Float', # [[Float]]
            # The dest approach mode. Types are:
            # - **default**  - Robot tries to be safe while minimizing linear approach.
            # - **highestEdge** - Robot tries to approach highest edge first.
            'destApproachMode': 'String', # String
            # mm, distance for diagonal destination approach offset for x and y axis (parallel to the floor of the container) in container coordinates
            'destApproachOffsetByXY': 'Float', # Float
            # mm, distance to start moving linear on Z axis.
            'destApproachOffsetByZ': 'Float', # Float
            # Multiplier of how much to consider accumulated approach for tool to depart from placement.
            'destDepartAccumApproachDirMult': 'Float', # Float
            # mm, Extra distance for departing on z axis once part is released in container coordinates. The bigger it is, the more the longer the linear movement becomes.
            'destDepartOffsetByZ': 'Float', # Float
            # mm, Extra distance for departing on xy axis once part is placed near container wall. The bigger it is, the more the longer the linear movement becomes.
            'destDepartOffsetXYFromWall': 'Float', # Float
            # ratio, the part can be dropped from the part height multiplied by this ratio. 1.0 means, that the part can be dropped from the height of its size
            'destDropRatio': 'Float', # Float
            # mm, Distance from the surface to place a box the surface can be bottom of the container or another box. depth matrices are still initialized at 0, just that the ikparam where the tool goes is offset
            'dropOffsetZ': 'Float', # Float
            # The dynamic packing mode. Types are:
            # - **default**  - Default algorithm that packs first layer, then goes to second layer.
            # - **stacking** - Prioritize stacking objects on top of each other before filling the first layer.
            'dynamicPackingMode': 'String', # String
            # discrete gradient, threshold for magnitute of gradient depth map image for determining edges
            'edgedetectorThresh': 'Float', # Float
            # If true, then the dest container has no walls and dynamic goal generation can assume that the robot can approach through the virtual walls. This makes the generated goal easier.
            'ignoreContainerWalls': 'Boolean', # Boolean
            # The number of voxels to ensure that are empty around the object before trying to place it. The higher the number, the more conservative/safe the system chooses the goals.
            'intGoalsPackingClearance': 'Int', # Int
            # voxels, maximum jitter offset to be applied on the placed item to confirm that placement of the object is stable. That means that item will be moved by this amount from the placement positions to confirm stable placement
            'intJitterPlacementOffset': 'Int', # Int
            # voxels, applied only when packing is used. The computed package will be offset from the computed position for at maximum this parameter. When not set the package will move to the open face of the cage with 3 walls, to the open corner when cage has 2 walls as a corner and center pacakge if cage is a cart (walls are opposite sides).
            'intMaxPackageTranslationOffsetXY': 'Int', # [Int]
            # voxels, How many grids to stay away from walls. Used when there is point cloud noise along the walls.
            'intOffsetFromWallRange': 'Int', # Int
            # voxels, the maximum allowed offset for packing placement check if packing placement is not available. Used only for packing formation computation verification.
            'intPackingCheckGoalsOffset': 'Int', # Int
            # voxels, two adjacent sides of the target object should have supporting walls from the existing depth map. A region is supporting when its points are within this range from the sides of the target.
            'intSupportingWallRange': 'Int', # Int
            # The target will be grabbed by a tool when it is placed inside the container. By specifying the tool XY size, can assure that the target will not be placed too close to walls so that it is impossible for the tool to place.
            'intToolXYSize': 'Int', # [Int]
            # ratio, maximum jitter offset of the item's COM to be applied on the placed item to confirm that placement of the object is stable. That means that item will be moved by ratio*(size of the item) per each dimension from the placement positions to confirm stable placement
            'jitterCOMRatioOffset': 'Float', # Float
            # mm, If > 0, then the max distance the COM can be above the wall height. By default will constraint the target COM under the wall height (maxWallHeightOfContainer). If < 0, then need to have COM under. By default, this is very large.
            'maxDistOfCOMAboveWallHeight': 'Float', # Float
            # mm, the max height of any point on the target that can be placed in the container. Usually at the container top, but can be extended to be a little bit out. Used to filter out targets placed too high. If set to 0, use the height of the container
            'maxHeightOfTargetInContainer': 'Float', # Float
            # Used only when dynamicgoals following the pack. Maximum number of destination approaches to compute. 0 means compute as much as can find. More destination approaches computed makes planning slower, but increases success rate.
            'maxNumDestApproachesToCompute': 'Int', # Int
            # mm (x,y,z), maximum deviation of the part size. All packing items input size will add the maxPartFullSizeDeviation for the package computation to ensure that the real item can be packed safely in the planned position.
            'maxPartFullSizeDeviation': 'Float', # [Float]
            # mm, The max placement height of the bottom edge of the target.
            'maxPlacementHeightOfTarget': 'Float', # Float
            # mm, The maximum placement height of the bottom edge of the target above wall which is allowed. If negative then targets will be placed below the wall. Valid only if maxPlacementHeightOfTarget is not defined.
            'maxPlacementHeightOffsetAboveWall': 'Float', # Float
            # mm, the max noise of the point cloud inside the container. This is used for computing the pack dimensions by not considering areas which the point cloud hits the bottom of the surface.
            'maxPointCloudNoise': 'Float', # Float
            # mm, if > 0, then the max distance the target top can be above the wall height. By default will constraint the target under the wall height (_maxWallHeightOfContainer). If < 0, then need to have the target under. By default, this is very large.
            'maxTargetAboveWallHeight': 'Float', # Float
            # mm, median filter will be applied for the depth matrix cell only if the difference between depth value before median filter and filtered depth value is smaller than this parameter. The median filtered depth value will be always applied if the parameter not set.
            'medianFilterMaxZOffsetToOverwrite': 'Float', # Float
            # mm, median window filter full size to apply to the pointcloud for dynamicgoals generation. Bigger the value more noise is filtered, but if too big the obstacles can be filtered out.
            'medianFilterWindowSize': 'Float', # Float
            # mm, The minum edge wall height to consider for edge walls and approach
            'minEdgeWallZHeight': 'Float', # Float
            # ratio, for every target, the minimum supporting region area below it necessary for acceptance of the placement position
            'minSupportingAreaRatio': 'Float', # Float
            # If True, then normalizes the input packFormation to a corner of the empty region. By default this is True since packs can be generated from a canonical cage/pallet, and need to be fit to the current place container. If packs are being planned with the current dest container in mind, then set this to False.
            'normalizePackToEmptyRegion': 'Boolean', # Boolean
            # ratio, parameter for increasing supporting region because of closiness to walls. if the item placed within 'notFallRatioNearWall' * 'item size' from the wall it assumed to be supported. The value for packing computation should be smaller than for real robot execution systems to compensate discretization difference.
            'notFallRatioNearWall': 'Float', # Float
            # If True, then the most recent point cloud will overwrite any placed object info that have been placed before the point cloud arrived. This is used
            'overwritePlacementWithDynamicPointCloud': 'Boolean', # Boolean
            # Mode to follow packing computed by Mujin packing cluster. Used only if packFormationComputationResult provided. 
            #             - **none**  - none, no specific requirement for following the pack;
            #             - **strict**  - check that inputPartIndex is following the order and all previous items packed by robot;
            #             - **strictStopOnFailure** - similar to **strict**, but execution stops only if cannot continue packing with "FinishedNoMoreDestOutOfOrder" error.
            #             - **smallerFirst**  - iterates for all possible placements and taking the first partIndex where the item can be placed,
            #             - **smallerFirstThenStrict**  - iterates for all possible placements and taking the first partIndex where the item can be placed for the first item in pick and place order request. Next items will follow the pack strictly starting from the succesful placement of the 1st item.
            'packFollowMode': 'String', # String
            # Pivot check position mode, changes the priority of search of dynamic goals by prioritizing the closest to the pivot. Possible prioritization is:
            #             - **NXNY**  - negative X and negative Y corner in local coordinates of the container,
            #             - **NXCY**  - negative X and center Y side in local coordinates of the container,
            #             - **NXPY**  - negative X and positive Y corner in local coordinates of the container,
            #             - **CXNY**  - center X and negative Y side in local coordinates of the container,
            #             - **CXCY**  - center of the container,
            #             - **CXPY**  - center X and positive Y side in local coordinates of the container,
            #             - **PXNY**  - positive X and negative Y corner in local coordinates of the container,
            #             - **PXCY**  - positive X and center Y side in local coordinates of the container,
            #             - **PXPY**  - positive X and positive Y corner in local coordinates of the container,
            'pivotCheckPositionMode': 'String', # String
            # placement area of the container by height from the container floor. Usually used when sensor visibility cannot cover entire container area close to the sensor.
            'placementAreaByHeightInfos': 'PlacementAreaByHeightInfoInput', # [PlacementAreaByHeightInfoInput]
            # mm, distance from the surface to place a box the surface can be bottom of the container or another box
            'placementOfBoxFromSurface': 'Float', # Float
            # Placement to rioritize placement of the dynamicgoal generated placements. Bigger coefficient means prioritize placement by the criteria. Negative means penalize. All criterias are normalized, the minimum value of the criteria is 0.0, the maximum is 1.0.
            'placementPriorityParameters': 'PlacementPriorityParametersInput', # PlacementPriorityParametersInput
            # If true and using pack formation result then if the placement is not possible into ordere packing placement, then will continue packing using random packing placement caomputation. If false and using pack formation result then will raise an error if placement is not possible into requested packing placement index.
            'randomPackingModeAllowed': 'Boolean', # Boolean
            # If True, reject all z-only approaches when there are other candidates with xy-movements. Keep the generated z-approach if only and only if it is the sole candidate. Make the parameter False when intOppositeObject clearance is big and linear z-only approach is always safe for all different items.
            'rejectUnsafeZApproach': 'Boolean', # Boolean
            # If True, then do not validate the used pack formation before placing targets with respect to it. Set to False by default.
            'skipPackFormationValidation': 'Boolean', # Boolean
            # ratio, how much of the box side has to be near the wall or another box and has to pass the target height test controlled by _supportingWallTargetHeightRatio.
            'supportingWallEdgeRatio': 'Float', # Float
            # ratio, the percentage of box height that all the supporting wall regions have to be greater than for the placement to be accepted.
            'supportingWallTargetHeightRatio': 'Float', # Float
            # mm, given the z placement of the target, all regions in depthmap that are within this range will be counted as supporting regions
            'supportingZRange': 'Float', # Float
            # mm, tool erosion windoe size, how much to errode tooldepth matrix (similar to the clearance around the tool.
            'toolDepthErosionWindowSize': 'Float', # Float
            # mm, all tool depth matrix values will be increased to at least this value. The value is the same as the distance between tool point and real metal hand to ignore collision of suction foams with already placed parts.
            'toolDepthMinDeadRegion': 'Float', # Float
            # mm, clearance from the top approaching surface. Due to point cloud noise, robot has to make sure grabbed part bottom is away from any top surfaces from existing point cloud by this amount. A good value has to be greater than executionVerificationInfo/bottomOverhangForPushVerificationXYZ[2], otherwise execution verification will keep on triggering.
            'topApproachSurfaceClearance': 'Float', # Float
            # mm, when approaching a tight space and there are walls on both sides, describes the min height difference of the walls that will still allow the robot to go inside.
            'topEdgeMinIntersection': 'Float', # Float
            # to use dynamic goals generation to define position of the items in the destcontainername
            'use': 'Boolean', # Boolean
            # a bitmask, 0x1 means use 0 degrees rotation around the axis pointing up direction of the container, 0x2 means use 90 degrees rotation around the axis pointing up direction of the container for placement
            'use90DegreesRotations': 'Int', # Int
            # 0 or 1, specifies if dynamic goal generator should use point cloud from camera for placement
            'useDynamicPointCloud': 'Int', # Int
            # 0 or 1, specifies if dynamic goal generator should use layout data coming from PLC or not
            'useLayoutData': 'Int', # Int
            # Set to true to enable tilt placement for tall standing items
            'useTiltPlacement': 'Boolean', # Boolean
            # When set, will validate that all placed objects on the pack are still guaranteed that can be picked up by the gripper in any order.
            'validatePlacedAllPickable': 'Boolean', # Boolean
        },

        # Description of a joint's electric actuator.
        'ElectricMotorActuator': {
            'assignedPowerRating': 'Float', # Float
            'coloumbFriction': 'Float', # Float
            'gearRatio': 'Float', # Float
            'maxInstantaneousTorque': 'Float', # Float
            'maxSpeed': 'Float', # Float
            'maxSpeedTorquePoints': 'Float', # [[Float!]!]
            'modelType': 'String', # String
            'noLoadSpeed': 'Float', # Float
            'nominalSpeedTorquePoints': 'Float', # [[Float!]!]
            'nominalTorque': 'Float', # Float
            'nominalVoltage': 'Float', # Float
            'rotorInertia': 'Float', # Float
            'speedConstant': 'Float', # Float
            'stallTorque': 'Float', # Float
            'startingCurrent': 'Float', # Float
            'terminalResistance': 'Float', # Float
            'torqueConstant': 'Float', # Float
            'viscousFriction': 'Float', # Float
        },

        # Description of a joint's electric actuator.
        'ElectricMotorActuatorInput': {
            'assignedPowerRating': 'Float', # Float
            'coloumbFriction': 'Float', # Float
            'gearRatio': 'Float', # Float
            'maxInstantaneousTorque': 'Float', # Float
            'maxSpeed': 'Float', # Float
            'maxSpeedTorquePoints': 'Float', # [[Float!]!]
            'modelType': 'String', # String
            'noLoadSpeed': 'Float', # Float
            'nominalSpeedTorquePoints': 'Float', # [[Float!]!]
            'nominalTorque': 'Float', # Float
            'nominalVoltage': 'Float', # Float
            'rotorInertia': 'Float', # Float
            'speedConstant': 'Float', # Float
            'stallTorque': 'Float', # Float
            'startingCurrent': 'Float', # Float
            'terminalResistance': 'Float', # Float
            'torqueConstant': 'Float', # Float
            'viscousFriction': 'Float', # Float
        },

        # An OpenRAVE Environment
        'Environment': {
            # For environments containing a single body, these are indexed readonly properties extracted deep inside the body.
            'attributes': 'Attributes', # Attributes
            # Last author who modified the environment.
            'author': 'String', # String!
            # List of blobs belonging to this environment.
            'blobs': 'Blob', # [Blob!]
            # List of bodies in the environment. Bodies represent robots, manipulators, grippers, physical objects and more
            'bodies': 'Body', # [Body!]
            # Number of bodies inside the environment, readonly property.
            'bodyCount': 'Int', # Int
            # Timestamp when the environment was created.
            'createdAt': 'DateTime', # DateTime
            # Description of the environment.
            'description': 'String', # String
            # Not used at the moment.
            'disabledReferenceEnvironmentIds': 'String', # [String!]
            # Gravity direction and magnitude of the environment, unit in meters per second squared.
            'gravity': 'Float', # [Float!]
            # The unique ID of the environment.
            'id': 'String', # String!
            # List of keywords tagged on the environment.
            'keywords': 'String', # [String!]
            # Timestamp when the environment was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # Name of the environment. Not guaranteed to be unique.
            'name': 'String', # String
            # Not used at the moment.
            'referenceEnvironmentIds': 'String', # [String!]
            # For robot files and linking the environment to a file stored on disk.
            'referenceFilename': 'String', # String
            # Latest revision id of the environment.
            'revisionId': 'Int', # Int!
            # Stats recorded for this environment.
            'stats': 'Stats', # Stats
            # Length unit used in the environment.
            'unit': 'Unit', # Unit
        },

        # An OpenRAVE Environment
        'EnvironmentInput': {
            # List of blobs belonging to this environment.
            'blobs': 'BlobInput', # [BlobInput!]
            # List of bodies in the environment. Bodies represent robots, manipulators, grippers, physical objects and more
            'bodies': 'BodyInput', # [BodyInput!]
            # Description of the environment.
            'description': 'String', # String
            # Not used at the moment.
            'disabledReferenceEnvironmentIds': 'String', # [String!]
            # Gravity direction and magnitude of the environment, unit in meters per second squared.
            'gravity': 'Float', # [Float!]
            # The unique ID of the environment.
            'id': 'String', # String
            # List of keywords tagged on the environment.
            'keywords': 'String', # [String!]
            # Name of the environment. Not guaranteed to be unique.
            'name': 'String', # String
            # Not used at the moment.
            'referenceEnvironmentIds': 'String', # [String!]
            # For robot files and linking the environment to a file stored on disk.
            'referenceFilename': 'String', # String
            # Length unit used in the environment.
            'unit': 'UnitInput', # UnitInput
        },

        # Parameters for enabling and setting up execution verification that allows the robot to quickly stop when it is about to hit a part that is moved. This function is *highly recommend* to be used.
        'ExecutionVerificationInfo': {
            # mm, The extra overhang from the bottom of the target on each of the XYZ axes to simulate safety. The coordinate system is one where +Z is up vector.
            'bottomOverhangForPushVerificationXYZ': 'Float', # [Float]
            # mm, The bottom thickness of the part.
            'bottomThicknessForPushVerification': 'Float', # Float
            # s, The duration after changing contents of the dest container to keep on doing verification. Used with pointCloudOnChangeWithDuration.
            'destAfterChangeDuration': 'Float', # Float
            # mm, distance threshold (in mm) when robot should stop verifying with the dest execution verification point cloud for the dest container since it is too close.
            'destApproachIgnoreDistance': 'Float', # Float
            # mm, If the target is within its goal by this XY distance, then ignore collisions with the held target. This essentially allows 'pushing' of the other objects within this threshold. Note that there is a separate check that checks that the target does not crush neighboring targets when going down.
            'destApproachIgnoreDistanceXY': 'Float', # Float
            # The point size multiplier to resize the points when checking for execution verification. Usually should be smaller than the point size used for planning so that execution verification is not triggered when planning succeeds.
            'pointSizeMult': 'Float', # Float
            # s, The duration after changing the contents of the source container to keep on doing verification. Used with pointCloudOnChangeWithDuration.
            'sourceAfterChangeDuration': 'Float', # Float
            # mm, distance threshold (in mm) when robot should stop verifying with the source execution verification point cloud for the source container since it is too close.
            'sourceApproachIgnoreDistance': 'Float', # Float
            # If True, then if execution verification point cloud arrives before robot after robot has executed the trajectory, and robot has already finished the trajectory, there might be a potential collision, so stop the cycle. This parameter should be True for fragile items, but can be False for metal items where torque limit can recover the system.
            'stopOnLatePointCloud': 'Boolean', # Boolean
            # Sets the run-time verification mode of the dest container. This is important since dest container contents could have changed by the time the robot executes the plan. Modes are:
            # - never - never do run-time verification of dest. (DANGEROUS)
            # - lastDetection - do verification on the last detected items, sometimes there could be a delay so NOT RECOMMENDED.
            # - pointCloudOnChange - do verification on the real-time point cloud data only when source/dest container is known to have changed. When robot goes into dest container and leaves, that counts as a change. (RECOMMENDED)
            # - pointCloudOnChangeAfterGrab - For dest containers only. Do verification on the real-time point cloud data only when container is known to have changed and after robot has grabbed the part. When robot goes into dest container and leaves, that counts as a change. Enabling this option means the robot will stop more while grabbing object.
            # - pointCloudAlways - do verification on the real-time point cloud data constantly for every snapshot. This setting is important if things other than robot can change the dest container, but can slow things down and have robot be more susceptible to point cloud noise.
            # - pointCloudOnChangeWithDuration - Used for objects like cylinders that can continue to move inside the container for some time before getting into a stable state. Same as pointCloudOnChange, it does verification only when container is known to have changed its contents (ie robot went inside), but it continues to take verification and snapshots until "afterChangeDuration" has expired. For example, if afterChangeDuration is 15s, then will continue capturing the point clouds up to 15s after the robot went inside. When robot goes into container and leaves, that counts as a change.
            # - pointCloudOnChangeFirstCycleOnly - only check the point cloud verification on the first execution cycle. This prevents problems if different unexpected containers coming to robot when cycle first starts.
            'verifyDestMode': 'String', # String
            # Sets the run-time verification mode of the source container. This is important since source container contents could have changed by the time the robot executes the plan. Modes are:
            # - never - never do run-time verification of source. (DANGEROUS)
            # - lastDetection - do verification on the last detected items, sometimes there could be a delay so NOT RECOMMENDED.
            # - pointCloudOnChange - Do verification on the real-time point cloud data only when container is known to have changed its contents (ie robot went inside). When robot goes into container and leaves, that counts as a change. (RECOMMENDED)
            # - pointCloudAlways - do verification on the real-time point cloud data constantly for every snapshot. This setting is important if things other than robot can change the source container, but can slow things down and have robot be more susceptible to point cloud noise.
            # - pointCloudOnChangeWithDuration - Used for objects like cylinders that can continue to move inside the container for some time before getting into a stable state. Same as pointCloudOnChange, it does verification only when container is known to have changed its contents (ie robot went inside), but it continues to take verification and snapshots until "afterChangeDuration" has expired. For example, if afterChangeDuration is 15s, then will continue capturing the point clouds up to 15s after the robot went inside. When robot goes into container and leaves, that counts as a change.
            # - pointCloudOnChangeFirstCycleOnly - only check the point cloud verification on the first execution cycle. This prevents problems if different unexpected containers coming to robot when cycle first starts.
            # - pointCloudOnChangeAfterGrab - do verification for the point cloud only after the target is grabbed. Otherwise, same as pointCloudOnChange
            'verifySourceMode': 'String', # String
            # When the robot approaching to grasp a part, look at the latest detection results and see if any part of the target has been offset more than this threshold. If yes, then robot will give up with execution verification error and replan for a new part. Should be enabled if packing is important.
            'verifyTargetPositionThresh': 'Float', # Float
        },

        # Parameters for enabling and setting up execution verification that allows the robot to quickly stop when it is about to hit a part that is moved. This function is *highly recommend* to be used.
        'ExecutionVerificationInfoInput': {
            # mm, The extra overhang from the bottom of the target on each of the XYZ axes to simulate safety. The coordinate system is one where +Z is up vector.
            'bottomOverhangForPushVerificationXYZ': 'Float', # [Float]
            # mm, The bottom thickness of the part.
            'bottomThicknessForPushVerification': 'Float', # Float
            # s, The duration after changing contents of the dest container to keep on doing verification. Used with pointCloudOnChangeWithDuration.
            'destAfterChangeDuration': 'Float', # Float
            # mm, distance threshold (in mm) when robot should stop verifying with the dest execution verification point cloud for the dest container since it is too close.
            'destApproachIgnoreDistance': 'Float', # Float
            # mm, If the target is within its goal by this XY distance, then ignore collisions with the held target. This essentially allows 'pushing' of the other objects within this threshold. Note that there is a separate check that checks that the target does not crush neighboring targets when going down.
            'destApproachIgnoreDistanceXY': 'Float', # Float
            # The point size multiplier to resize the points when checking for execution verification. Usually should be smaller than the point size used for planning so that execution verification is not triggered when planning succeeds.
            'pointSizeMult': 'Float', # Float
            # s, The duration after changing the contents of the source container to keep on doing verification. Used with pointCloudOnChangeWithDuration.
            'sourceAfterChangeDuration': 'Float', # Float
            # mm, distance threshold (in mm) when robot should stop verifying with the source execution verification point cloud for the source container since it is too close.
            'sourceApproachIgnoreDistance': 'Float', # Float
            # If True, then if execution verification point cloud arrives before robot after robot has executed the trajectory, and robot has already finished the trajectory, there might be a potential collision, so stop the cycle. This parameter should be True for fragile items, but can be False for metal items where torque limit can recover the system.
            'stopOnLatePointCloud': 'Boolean', # Boolean
            # Sets the run-time verification mode of the dest container. This is important since dest container contents could have changed by the time the robot executes the plan. Modes are:
            # - never - never do run-time verification of dest. (DANGEROUS)
            # - lastDetection - do verification on the last detected items, sometimes there could be a delay so NOT RECOMMENDED.
            # - pointCloudOnChange - do verification on the real-time point cloud data only when source/dest container is known to have changed. When robot goes into dest container and leaves, that counts as a change. (RECOMMENDED)
            # - pointCloudOnChangeAfterGrab - For dest containers only. Do verification on the real-time point cloud data only when container is known to have changed and after robot has grabbed the part. When robot goes into dest container and leaves, that counts as a change. Enabling this option means the robot will stop more while grabbing object.
            # - pointCloudAlways - do verification on the real-time point cloud data constantly for every snapshot. This setting is important if things other than robot can change the dest container, but can slow things down and have robot be more susceptible to point cloud noise.
            # - pointCloudOnChangeWithDuration - Used for objects like cylinders that can continue to move inside the container for some time before getting into a stable state. Same as pointCloudOnChange, it does verification only when container is known to have changed its contents (ie robot went inside), but it continues to take verification and snapshots until "afterChangeDuration" has expired. For example, if afterChangeDuration is 15s, then will continue capturing the point clouds up to 15s after the robot went inside. When robot goes into container and leaves, that counts as a change.
            # - pointCloudOnChangeFirstCycleOnly - only check the point cloud verification on the first execution cycle. This prevents problems if different unexpected containers coming to robot when cycle first starts.
            'verifyDestMode': 'String', # String
            # Sets the run-time verification mode of the source container. This is important since source container contents could have changed by the time the robot executes the plan. Modes are:
            # - never - never do run-time verification of source. (DANGEROUS)
            # - lastDetection - do verification on the last detected items, sometimes there could be a delay so NOT RECOMMENDED.
            # - pointCloudOnChange - Do verification on the real-time point cloud data only when container is known to have changed its contents (ie robot went inside). When robot goes into container and leaves, that counts as a change. (RECOMMENDED)
            # - pointCloudAlways - do verification on the real-time point cloud data constantly for every snapshot. This setting is important if things other than robot can change the source container, but can slow things down and have robot be more susceptible to point cloud noise.
            # - pointCloudOnChangeWithDuration - Used for objects like cylinders that can continue to move inside the container for some time before getting into a stable state. Same as pointCloudOnChange, it does verification only when container is known to have changed its contents (ie robot went inside), but it continues to take verification and snapshots until "afterChangeDuration" has expired. For example, if afterChangeDuration is 15s, then will continue capturing the point clouds up to 15s after the robot went inside. When robot goes into container and leaves, that counts as a change.
            # - pointCloudOnChangeFirstCycleOnly - only check the point cloud verification on the first execution cycle. This prevents problems if different unexpected containers coming to robot when cycle first starts.
            # - pointCloudOnChangeAfterGrab - do verification for the point cloud only after the target is grabbed. Otherwise, same as pointCloudOnChange
            'verifySourceMode': 'String', # String
            # When the robot approaching to grasp a part, look at the latest detection results and see if any part of the target has been offset more than this threshold. If yes, then robot will give up with execution verification error and replan for a new part. Should be enabled if packing is important.
            'verifyTargetPositionThresh': 'Float', # Float
        },

        # Priorities of the faces to pick up the box.
        'FacePickUpPriorities': {
            # Priority for x negative face.
            'xn': 'Int', # Int
            # Priority for x positive face.
            'xp': 'Int', # Int
            # Priority for y negative face.
            'yn': 'Int', # Int
            # Priority for y positive face.
            'yp': 'Int', # Int
            # Priority for z negative face.
            'zn': 'Int', # Int
            # Priority for z positive face.
            'zp': 'Int', # Int
        },

        # Priorities of the faces to pick up the box.
        'FacePickUpPrioritiesInput': {
            # Priority for x negative face.
            'xn': 'Int', # Int
            # Priority for x positive face.
            'xp': 'Int', # Int
            # Priority for y negative face.
            'yn': 'Int', # Int
            # Priority for y positive face.
            'yp': 'Int', # Int
            # Priority for z negative face.
            'zn': 'Int', # Int
            # Priority for z positive face.
            'zp': 'Int', # Int
        },

        # A named parameter holding an array of float values
        'FloatsParameter': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String!
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            'values': 'Float', # [Float!]
        },

        # A named parameter holding an array of float values
        'FloatsParameterInput': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String
            'values': 'Float', # [Float!]
        },

        # Parameters for state estimation features based on force torque sensor
        'ForceTorqueBasedEstimatorParameters': {
            # threshold to detect collision from estimated external force and torque. unit is N for force, Nm for torque. note that estimated external force and torque are computed by subtracting bias force (gravitational force, inertial force etc) from measured force and torque. And also estimated external force and torque is filtered by 'externalForceTorqueFilter'. negative value means disabled
            'collisionExternalForceTorqueThresholds': 'Float', # [Float]
            # threshold to detect collision from measured force and torque. unit is N for force, Nm for torque. note that this threshold is applied to the values filtered by 'forceTorqueFilter'. negative value means disabled
            'collisionSensorValueThresholds': 'Float', # [Float]
            # delay between commanded joint values and actual joint values.
            'controlDelay': 'Float', # Float
            # matrix that multiplied to raw force and torque values to correct cross-talk etc
            'correctionMatrix': 'Float', # [[Float]]
            # Force torque sensor's device name
            'devicename': 'String', # String
            # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
            'externalForceTorqueFilter': 'ForceTorqueFilterParameters', # ForceTorqueFilterParameters
            # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
            'forceTorqueFilter': 'ForceTorqueFilterParameters', # ForceTorqueFilterParameters
            # center of mass of robot's hand under Force Torque sensor with respect to the sensor coordinate system. unit is mm
            'handCenterOfMass': 'Float', # [Float]
            # mass of robot's hand. unit is kg
            'handMass': 'Float', # Float
            # m/s^2. When the force torque sensor has the absolute value of vertical acceleration smaller than this value, the force torque based estimator skips the mass estimation since the estimated mass is likely unreliable.
            'minVerticalAccelerationForMassEstimation': 'Float', # Float
            # Newtons. When the force torque sensor has the absolute value of vertical force smaller than this value, the force torque based estimator skips the center of mass estimation since the estimated center of mass is likely unreliable..
            'minVerticalForceForCenterOfMassEstimation': 'Float', # Float
            # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
            'objectMassEstimationFilter': 'ForceTorqueFilterParameters', # ForceTorqueFilterParameters
            # A position configuration to use to calibrate the force torque sensor.
            'robotForceTorqueCalibrationPositionName': 'String', # String
            # Bias force torque that can be predicted by IO signals.
            'sensorBiasByIoSignals': 'SensorBiasByIoSignals', # [SensorBiasByIoSignals]
            # Accuracy of measured force in Newtons. This value is used to judge whether to accept or reject measurement from the force torque sensor, as very small measurements and measurements with very large disturbances are not reliable. For example, if the lateral force measured by the sensor is over 10x larger than this valie during measurement of mass properties, the result is likely unreliable and should be discarded. Similarly, if the measured weight is below this value, the center of mass measurement would also be unreliable and should not be used.
            'sensorForceAccuracy': 'Float', # Float
            # frequency of updating measured values from a sensor
            'sensorFrequency': 'Float', # Float
            # Link name which sensor is attached to
            'sensorLinkName': 'String', # String
            # Polarity of force torque sensor. When tool is attached to sensor's base side (upside down mounting), usually the polarity should be -1.
            'sensorPolarity': 'Int', # Int
            # Accuracy of measured torque in Newton-meters. This value is used to evaluate the accuracy of the center of mass measurement.
            'sensorTorqueAccuracy': 'Float', # Float
            # Set to true to enable force torque based estimation.
            'use': 'Boolean', # Boolean
            # Set to true to enable correction matrix.
            'useCorrectionMatrix': 'Boolean', # Boolean
        },

        # Parameters for state estimation features based on force torque sensor
        'ForceTorqueBasedEstimatorParametersInput': {
            # threshold to detect collision from estimated external force and torque. unit is N for force, Nm for torque. note that estimated external force and torque are computed by subtracting bias force (gravitational force, inertial force etc) from measured force and torque. And also estimated external force and torque is filtered by 'externalForceTorqueFilter'. negative value means disabled
            'collisionExternalForceTorqueThresholds': 'Float', # [Float]
            # threshold to detect collision from measured force and torque. unit is N for force, Nm for torque. note that this threshold is applied to the values filtered by 'forceTorqueFilter'. negative value means disabled
            'collisionSensorValueThresholds': 'Float', # [Float]
            # delay between commanded joint values and actual joint values.
            'controlDelay': 'Float', # Float
            # matrix that multiplied to raw force and torque values to correct cross-talk etc
            'correctionMatrix': 'Float', # [[Float]]
            # Force torque sensor's device name
            'devicename': 'String', # String
            # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
            'externalForceTorqueFilter': 'ForceTorqueFilterParametersInput', # ForceTorqueFilterParametersInput
            # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
            'forceTorqueFilter': 'ForceTorqueFilterParametersInput', # ForceTorqueFilterParametersInput
            # center of mass of robot's hand under Force Torque sensor with respect to the sensor coordinate system. unit is mm
            'handCenterOfMass': 'Float', # [Float]
            # mass of robot's hand. unit is kg
            'handMass': 'Float', # Float
            # m/s^2. When the force torque sensor has the absolute value of vertical acceleration smaller than this value, the force torque based estimator skips the mass estimation since the estimated mass is likely unreliable.
            'minVerticalAccelerationForMassEstimation': 'Float', # Float
            # Newtons. When the force torque sensor has the absolute value of vertical force smaller than this value, the force torque based estimator skips the center of mass estimation since the estimated center of mass is likely unreliable..
            'minVerticalForceForCenterOfMassEstimation': 'Float', # Float
            # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
            'objectMassEstimationFilter': 'ForceTorqueFilterParametersInput', # ForceTorqueFilterParametersInput
            # A position configuration to use to calibrate the force torque sensor.
            'robotForceTorqueCalibrationPositionName': 'String', # String
            # Bias force torque that can be predicted by IO signals.
            'sensorBiasByIoSignals': 'SensorBiasByIoSignalsInput', # [SensorBiasByIoSignalsInput]
            # Accuracy of measured force in Newtons. This value is used to judge whether to accept or reject measurement from the force torque sensor, as very small measurements and measurements with very large disturbances are not reliable. For example, if the lateral force measured by the sensor is over 10x larger than this valie during measurement of mass properties, the result is likely unreliable and should be discarded. Similarly, if the measured weight is below this value, the center of mass measurement would also be unreliable and should not be used.
            'sensorForceAccuracy': 'Float', # Float
            # frequency of updating measured values from a sensor
            'sensorFrequency': 'Float', # Float
            # Link name which sensor is attached to
            'sensorLinkName': 'String', # String
            # Polarity of force torque sensor. When tool is attached to sensor's base side (upside down mounting), usually the polarity should be -1.
            'sensorPolarity': 'Int', # Int
            # Accuracy of measured torque in Newton-meters. This value is used to evaluate the accuracy of the center of mass measurement.
            'sensorTorqueAccuracy': 'Float', # Float
            # Set to true to enable force torque based estimation.
            'use': 'Boolean', # Boolean
            # Set to true to enable correction matrix.
            'useCorrectionMatrix': 'Boolean', # Boolean
        },

        # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
        'ForceTorqueFilterParameters': {
            # cut-off frequency of low pass filter. unit is Hz
            'cutOffFrequency': 'Float', # Float
            # order of low pass filter. this has to be a positive integer.
            'order': 'Int', # Int
            # Currently 'butterworth' and 'bessel' are supported. Usually 'bessel' is preferable to detect anomaly since it has very small overshoot and delay.
            'type': 'String', # String
        },

        # Filter Parameters for Force Torque sensor related feature. Currently we only supports low pass filters
        'ForceTorqueFilterParametersInput': {
            # cut-off frequency of low pass filter. unit is Hz
            'cutOffFrequency': 'Float', # Float
            # order of low pass filter. this has to be a positive integer.
            'order': 'Int', # Int
            # Currently 'butterworth' and 'bessel' are supported. Usually 'bessel' is preferable to detect anomaly since it has very small overshoot and delay.
            'type': 'String', # String
        },

        # Geometry of a link. A link can have multiple geometries, and a body can have multiple links. All geometries of a link move together.
        'Geometry': {
            'ambientColor': 'Float', # [Float!]
            # TODO(felixvd): What do these values describe?
            # (Cage measurement (1/5)): The extents of the base of a cage (an object to stack boxes into)
            'baseExtents': 'Float', # [Float!]
            # (Container measurement (4/4)): The normal vector of the bottom surface
            'bottom': 'Float', # [Float!]
            # (Container measurement (3/4)): The cross vector of the bottom surface
            'bottomCross': 'Float', # [Float!]
            # For calibration boards
            'calibrationBoardParameters': 'CalibrationBoardParameters', # CalibrationBoardParameters
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            'diffuseColor': 'Float', # [Float!]
            # Half the extents of a box, in each dimension. For a crate of size 1 m x 1 m x 2 m, this vector would be [0.5, 0.5, 1.0]
            'halfExtents': 'Float', # [Float!]
            # For cylinders only
            'height': 'Float', # Float
            # The ID of the environment. Unique within a link.
            'id': 'String', # String!
            # (Container measurement (2/4)): The inner extent of the container.
            'innerExtents': 'Float', # [Float!]
            # (Cage measurement (2/5)):
            'innerSizeX': 'Float', # Float
            # (Cage measurement (3/5)):
            'innerSizeY': 'Float', # Float
            # (Cage measurement (4/5)):
            'innerSizeZ': 'Float', # Float
            # For trimeshes
            'mesh': 'Mesh', # Mesh
            'modifiable': 'Boolean', # Boolean
            # The name of a geometry. Unique within a link.
            'name': 'String', # String
            # (Container measurement (1/4)): The outer extent of the container
            'outerExtents': 'Float', # [Float!]
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # For spheres and cylinders
            'radius': 'Float', # Float
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # (Cage measurement (5/5)):
            'sideWalls': 'SideWall', # [SideWall!]
            # Transform of geometry in link space
            'transform': 'Float', # [Float!]
            'transparency': 'Float', # Float
            # Type of geometry, can be one of: box, container, cage, sphere, cylinder, trimesh
            'type': 'String', # String
            'visible': 'Boolean', # Boolean
        },

        # Geometry of a link. A link can have multiple geometries, and a body can have multiple links. All geometries of a link move together.
        'GeometryInput': {
            'ambientColor': 'Float', # [Float!]
            # TODO(felixvd): What do these values describe?
            # (Cage measurement (1/5)): The extents of the base of a cage (an object to stack boxes into)
            'baseExtents': 'Float', # [Float!]
            # (Container measurement (4/4)): The normal vector of the bottom surface
            'bottom': 'Float', # [Float!]
            # (Container measurement (3/4)): The cross vector of the bottom surface
            'bottomCross': 'Float', # [Float!]
            # For calibration boards
            'calibrationBoardParameters': 'CalibrationBoardParametersInput', # CalibrationBoardParametersInput
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            'diffuseColor': 'Float', # [Float!]
            # Half the extents of a box, in each dimension. For a crate of size 1 m x 1 m x 2 m, this vector would be [0.5, 0.5, 1.0]
            'halfExtents': 'Float', # [Float!]
            # For cylinders only
            'height': 'Float', # Float
            # The ID of the environment. Unique within a link.
            'id': 'String', # String
            # (Container measurement (2/4)): The inner extent of the container.
            'innerExtents': 'Float', # [Float!]
            # (Cage measurement (2/5)):
            'innerSizeX': 'Float', # Float
            # (Cage measurement (3/5)):
            'innerSizeY': 'Float', # Float
            # (Cage measurement (4/5)):
            'innerSizeZ': 'Float', # Float
            # For trimeshes
            'mesh': 'MeshInput', # MeshInput
            'modifiable': 'Boolean', # Boolean
            # The name of a geometry. Unique within a link.
            'name': 'String', # String
            # (Container measurement (1/4)): The outer extent of the container
            'outerExtents': 'Float', # [Float!]
            # For spheres and cylinders
            'radius': 'Float', # Float
            # (Cage measurement (5/5)):
            'sideWalls': 'SideWallInput', # [SideWallInput!]
            # Transform of geometry in link space
            'transform': 'Float', # [Float!]
            'transparency': 'Float', # Float
            # Type of geometry, can be one of: box, container, cage, sphere, cylinder, trimesh
            'type': 'String', # String
            'visible': 'Boolean', # Boolean
        },

        # An object that is currently grabbed (grasped) by the robot.
        'Grabbed': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The name of the grabbed object. Unique within a body.
            'grabbedName': 'String', # String
            # The ID of the grabbed object. Unique within a body.
            'id': 'String', # String!
            # Links for which collision with the object should be ignored
            'ignoreRobotLinkNames': 'String', # [String!]
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # The link that the grabbed object is attached to
            'robotLinkName': 'String', # String
            # Transform from the robot link the object is attached to
            'transform': 'Float', # [Float!]
        },

        # An object that is currently grabbed (grasped) by the robot.
        'GrabbedInput': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The name of the grabbed object. Unique within a body.
            'grabbedName': 'String', # String
            # The ID of the grabbed object. Unique within a body.
            'id': 'String', # String
            # Links for which collision with the object should be ignored
            'ignoreRobotLinkNames': 'String', # [String!]
            # The link that the grabbed object is attached to
            'robotLinkName': 'String', # String
            # Transform from the robot link the object is attached to
            'transform': 'Float', # [Float!]
        },

        # Sensor definition
        'GrabbedTargetIOSensorDefinition': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Name of the geometries representing the sensors. The sensor ray is assumed to be in the +Z axis of the geometry frame. Each name should be in the format of instobjectname/linkname/geomname.
            'geomNames': 'String', # [String]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Names of the IK parameters which gives the direction of the sensor ray. Assuming +Z axis is the direction of the ray. Each name should be in the format of instobjectname/ikparamname.
            'ikparamNames': 'String', # [String]
            # Name of the corresponding IO signal.
            'ioname': 'String', # String
            # If "all", all rays defined by ikparamNames need to be occluded by the grabbed targets in order to trigger the sensors. If "any", any of the rays can be occluded by the targets in order to trigger the sensors.
            'rayCheckMode': 'String', # String
        },

        # Sensor definition
        'GrabbedTargetIOSensorDefinitionInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Name of the geometries representing the sensors. The sensor ray is assumed to be in the +Z axis of the geometry frame. Each name should be in the format of instobjectname/linkname/geomname.
            'geomNames': 'String', # [String]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Names of the IK parameters which gives the direction of the sensor ray. Assuming +Z axis is the direction of the ray. Each name should be in the format of instobjectname/ikparamname.
            'ikparamNames': 'String', # [String]
            # Name of the corresponding IO signal.
            'ioname': 'String', # String
            # If "all", all rays defined by ikparamNames need to be occluded by the grabbed targets in order to trigger the sensors. If "any", any of the rays can be occluded by the targets in order to trigger the sensors.
            'rayCheckMode': 'String', # String
        },

        # Project-Id-Version: PACKAGE VERSION
        # Report-Msgid-Bugs-To: 
        # PO-Revision-Date: 2015-07-17 11:57+0900
        # Last-Translator: Automatically generated
        # Language-Team: none
        # Language: en_US
        # MIME-Version: 1.0
        # Content-Type: text/plain; charset=UTF-8
        # Content-Transfer-Encoding: 8bit
        # Plural-Forms: nplurals=2; plural=(n != 1);
        'GrabbedTargetValidationSignalsInfo': {
            # Definition of sensors to trigger if occluded by the grabbed targets.
            'ioSensors': 'GrabbedTargetIOSensorDefinition', # [GrabbedTargetIOSensorDefinition]
            # Set to true to enable grabbed target validation signals info.
            'use': 'Boolean', # Boolean
        },

        # Project-Id-Version: PACKAGE VERSION
        # Report-Msgid-Bugs-To: 
        # PO-Revision-Date: 2015-07-17 11:57+0900
        # Last-Translator: Automatically generated
        # Language-Team: none
        # Language: en_US
        # MIME-Version: 1.0
        # Content-Type: text/plain; charset=UTF-8
        # Content-Transfer-Encoding: 8bit
        # Plural-Forms: nplurals=2; plural=(n != 1);
        'GrabbedTargetValidationSignalsInfoInput': {
            # Definition of sensors to trigger if occluded by the grabbed targets.
            'ioSensors': 'GrabbedTargetIOSensorDefinitionInput', # [GrabbedTargetIOSensorDefinitionInput]
            # Set to true to enable grabbed target validation signals info.
            'use': 'Boolean', # Boolean
        },

        # Array of the pair of scaling multiplier and mass.
        'GraspDepartAccelDecelScaleMultOnTargetMass': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # kg, Specifies target mass.
            'mass': 'Float', # Float
            # Specifies the number by which the grasp depart accel and decel multiplied.
            'scale': 'Float', # Float
        },

        # Array of the pair of scaling multiplier and mass.
        'GraspDepartAccelDecelScaleMultOnTargetMassInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # kg, Specifies target mass.
            'mass': 'Float', # Float
            # Specifies the number by which the grasp depart accel and decel multiplied.
            'scale': 'Float', # Float
        },

        # Multipliers for various grasp-goal pair costs.
        'GraspGoalPairCostMultipliers': {
            # Multiplier for the rotation difference between manip pose at grasp and manip pose at dest. A higher value means to penalize a grasp-goal pair whose manip poses at grasp and dest are more different.
            'grabToolRotMult': 'Float', # Float
            # Multiplier for priority for singularity point passing during linear grasp approach/depart and dest approach/depart trajectories. This number should be negative to prioritize linear trajectories that are not close to robot singularities.
            'singularityPriorityMult': 'Float', # Float
            # Multiplier for the rotation difference between target pose at source and target pose at dest. A higher value means to penalize a grasp-goal pair whose target poses (rotation components) at grasp and dest are more different.
            'sourceDestTargetOrientationDiffMult': 'Float', # Float
            # Multiplier for deviation between the target pose from the dest ikparam and the computed target pose. For example, when grasp ikparams are TranslationDirection5D, the poses might not match exactly.
            'targetDeviationMult': 'Float', # Float
            # If > 0, will compute maximum tool deviation along an estimated transfer trajectory. The more deviation, the more penalty for the corresponding grasp-goal pair.
            'toolDeviationMult': 'Float', # Float
        },

        # Multipliers for various grasp-goal pair costs.
        'GraspGoalPairCostMultipliersInput': {
            # Multiplier for the rotation difference between manip pose at grasp and manip pose at dest. A higher value means to penalize a grasp-goal pair whose manip poses at grasp and dest are more different.
            'grabToolRotMult': 'Float', # Float
            # Multiplier for priority for singularity point passing during linear grasp approach/depart and dest approach/depart trajectories. This number should be negative to prioritize linear trajectories that are not close to robot singularities.
            'singularityPriorityMult': 'Float', # Float
            # Multiplier for the rotation difference between target pose at source and target pose at dest. A higher value means to penalize a grasp-goal pair whose target poses (rotation components) at grasp and dest are more different.
            'sourceDestTargetOrientationDiffMult': 'Float', # Float
            # Multiplier for deviation between the target pose from the dest ikparam and the computed target pose. For example, when grasp ikparams are TranslationDirection5D, the poses might not match exactly.
            'targetDeviationMult': 'Float', # Float
            # If > 0, will compute maximum tool deviation along an estimated transfer trajectory. The more deviation, the more penalty for the corresponding grasp-goal pair.
            'toolDeviationMult': 'Float', # Float
        },

        'GraspModelInfo': {
            'minNumSupportedFaces': 'Int', # Int
        },

        'GraspModelInfoInput': {
            'minNumSupportedFaces': 'Int', # Int
        },

        # Multipliers for various grasp priority values.
        'GraspPriorityMultipliers': {
            # Multiplier for the deviation between the tool direction at grasp and the constrained global direction (see constraintToolInfo). This value indicates how much to penalize grasps that are tilted away further from the global direction. A higher value means to penalize this grasp more.
            'constraintToolDeviationMult': 'Float', # Float
            # Multiplier for the distance between the grasp center and the target center of mass (COM), measured perpendicular to target's Z-axis. This value indicates how much to penalize grasps that are farther from the target COM. A higher value means to penalize this grasp more.
            'graspDistMult': 'Float', # Float
            # Multiplier for grasp priority defined in the grasping model. A higher value means to prioritize this grasp more.
            'graspPriorityMult': 'Float', # Float
            # This number will be directly added to the total grasp priority when another target is found graspable by this grasp in a multi-pick scenario.
            'multiGrasp': 'Float', # Float
            # Multiplier for suction force priority, indicating how much to prioritize grasps that provide higher suction force. A higher value means to prioritize the grasp more.
            'suctionForceMult': 'Float', # Float
            # Multiplier for transfer speed mult priority, indicating how much to prioritize grasps that allow higher transfer speed mult. A higher value means to prioritize the grasp more.
            'transferSpeedMult': 'Float', # Float
        },

        # Multipliers for various grasp priority values.
        'GraspPriorityMultipliersInput': {
            # Multiplier for the deviation between the tool direction at grasp and the constrained global direction (see constraintToolInfo). This value indicates how much to penalize grasps that are tilted away further from the global direction. A higher value means to penalize this grasp more.
            'constraintToolDeviationMult': 'Float', # Float
            # Multiplier for the distance between the grasp center and the target center of mass (COM), measured perpendicular to target's Z-axis. This value indicates how much to penalize grasps that are farther from the target COM. A higher value means to penalize this grasp more.
            'graspDistMult': 'Float', # Float
            # Multiplier for grasp priority defined in the grasping model. A higher value means to prioritize this grasp more.
            'graspPriorityMult': 'Float', # Float
            # This number will be directly added to the total grasp priority when another target is found graspable by this grasp in a multi-pick scenario.
            'multiGrasp': 'Float', # Float
            # Multiplier for suction force priority, indicating how much to prioritize grasps that provide higher suction force. A higher value means to prioritize the grasp more.
            'suctionForceMult': 'Float', # Float
            # Multiplier for transfer speed mult priority, indicating how much to prioritize grasps that allow higher transfer speed mult. A higher value means to prioritize the grasp more.
            'transferSpeedMult': 'Float', # Float
        },

        # Represents a set of IKParams at which an object may be grasped.
        'GraspSet': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The ID of the grasp set. Unique within a body.
            'id': 'String', # String!
            # name of the ikparams
            'ikParams': 'String', # [String!]
            # The name of the grasp set. Unique within a body.
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
        },

        # Represents a set of IKParams at which an object may be grasped.
        'GraspSetInput': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The ID of the grasp set. Unique within a body.
            'id': 'String', # String
            # name of the ikparams
            'ikParams': 'String', # [String!]
            # The name of the grasp set. Unique within a body.
            'name': 'String', # String
        },

        'GripperConfiguration': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Name of the gripper bridge to load
            'gripperBridgeType': 'String', # String
            # ID of the gripperInfo defined in the robot
            'grippername': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Name of robot that gripper is attached to
            'robotname': 'String', # String
            # Set to false to disable gripper.
            'use': 'Boolean', # Boolean
        },

        # Gripper info describing the gripper properties, used for planning gripper operations.
        'GripperInfo': {
            # Describes the properties and link associations of each air channel
            'airchannels': 'GripperInfoAirChannel', # [GripperInfoAirChannel]
            # The longer edge of the tool is aligned to the longer edge of the target.
            'alignLongEdgeInfo': 'GripperInfoAlignLongEdgeInfo', # GripperInfoAlignLongEdgeInfo
            # A boolean indicates the automatic finger values generation
            'automaticFingerValuesGeneration': 'Boolean', # Boolean
            # If 1, then can blow the part while blowWhileDestDeparting. By default this is None, meaning system makes best judgement
            'blowWhileDestDeparting': 'Boolean', # Boolean
            # Direction of Camera Angle
            'cameraDirAngleInfo': 'GripperInfoCameraDirAngleInfo', # GripperInfoCameraDirAngleInfo
            # Distance info of camera
            'cameraDistanceInfo': 'GripperInfoCameraDistanceInfo', # GripperInfoCameraDistanceInfo
            # Roll Info of camera
            'cameraRollInfo': 'GripperInfoCameraRollInfo', # GripperInfoCameraRollInfo
            # Check-collision grid info specifies points in XY plane of the grasp ikparam frame that the end-effector collision checking should be performed. This is used for grasp validation.
            'checkCollisionGridInfo': 'GripperInfoCheckCollisionGridInfo', # GripperInfoCheckCollisionGridInfo
            # Boolean to enable check collision when unused
            'checkCollisionWhenUnused': 'Boolean', # Boolean
            # If "first_and_then_or", then robot first checks to make sure that all planned suction cups are ON, otherwise will return with PieceLost. After robot validates that all used suction cups's pressure is good, then it will switch to "or" setting so that the cycle doesn't stop if one suction cup is bad. If "and", then all io values should feet mapCheckHandIOForSuccessMask to count grasp as successfull. By default it is "or" which means grasp count as successful if ANY of the suction cups are ON.
            'checkIOForSuccessOperation': 'String', # String
            # List of names of child grippers. Applicable only when using grouped grippers.
            'childGripperNames': 'String', # [String]
            # The amount of time to delay sending the chuck signals. Sometimes when the robot is moving too fast, the physical robot will not catch up with the commanded trajectory. In that case, if the gripper is suction and has valves and pressure is turned on, there is a good chance the valves will trigger leading the robot to believe there is something picked up.
            'chuckEventDelayFromApproach': 'Float', # Float
            # Used to determine when internal joints stop moving by checking the current encoder values with those in the past. If all values are within this threshold, will stop.
            'chuckJointDeltaToStop': 'Float', # Float
            # The offset to add to every finger's joints chucking direction from the predicted value. Used to make gripper move a little bit more, to make torque and pressure on the picking part to hold it stronger.
            'chuckOffset': 'Float', # Float
            # The default chucking direction of each of the individual gripper joints when grasping the part. If 0, then joint won't move. Size is gripper DOF. This can be overwritten by different grasps.
            'chuckingDirection': 'Float', # [Float]
            # Parameters for Compute Finger Value
            'computeFingerValuesParameters': 'GripperInfoComputeFingerValuesParameters', # GripperInfoComputeFingerValuesParameters
            # The allowed minimum ratio of suction cups that needs to be inside of the pickable region before a suction cup/pad's is considered to contribute to the grasp, and be considered for the calculation of transfer speed and grasp failure.
            # 
            # If more cups of the total (or more surface of the suction pad) are covered than this ratio, the air pressure will be used to determine e.g. transfer speed and grasp failure. If only a smaller section of the cups/pad is covered by the part, the air pressure level is ignored. The suction cups/pad may nonetheless be used to increase the suction force.
            # 
            # If minInsideCupsRatioPerLink is set, this value is overridden.
            'defaultMinInsideCupsRatio': 'Float', # Float
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The mass of discretization
            'discretizationMass': 'Float', # Float
            # How much to discretize priorities using XYZ in order to avoid small noise from affecting the priority computation directly.
            'discretizationXYZ': 'Float', # [Float]
            # List of 3-values of extra tool offsets in addition the automatically computed tool offsets. Each automatically computed tool offset will also generate a grasp with these translation offsets computed
            'extraToolTranslationOffsets': 'Float', # [[Float]]
            # When set, only these gripper control indices will be activated during a grasp.
            'filterGripperControlIndices': 'Int', # [Int]
            # The index of force gripper control
            'forceGripperControlIndex': 'Int', # Int
            # If grippertype is airchannels and value is True will do blow out on all airchannels regardless on which airchannel was used for grasp.
            'forceUnchuckAllAirChannels': 'Boolean', # Boolean
            # If ratio between suction force and target weight exceeds this parameter, then robot transfer speed due to weight component is full speed. Otherwise, the speed reduces linearly up until suction force is equal to taret weight.
            'fullSpeedCutoff': 'Float', # Float
            # When generating grasps for the hand, generate specific offsets per object such that the corner of the gripper alignes with each of the corners of the box. This greatly helps in palleitizing and depalletizing applications.
            'generateCornerOffsets': 'Boolean', # Boolean
            # Project-Id-Version: PACKAGE VERSION
            # Report-Msgid-Bugs-To: 
            # PO-Revision-Date: 2015-11-09 17:26+0900
            # Last-Translator: Automatically generated
            # Language-Team: none
            # Language: en_US
            # MIME-Version: 1.0
            # Content-Type: text/plain; charset=ASCII
            # Content-Transfer-Encoding: 8bit
            # Plural-Forms: nplurals=2; plural=(n != 1);
            'grabbingPartPositionBalanceCheckInfo': 'GripperInfoGrabbingPartPositionBalanceCheckInfo', # GripperInfoGrabbingPartPositionBalanceCheckInfo
            # The time from which we start checking for value of pressureSensorIO
            'gripperIOCheckStartTime': 'Float', # Float
            # List of gripper joint names.
            'gripperJointNames': 'String', # [String]
            # The id used to match what registration system gripper the customer did the confirmation with.
            'gripperModelId': 'String', # String
            # Type of gripper that will be used for planning. This is the type regardless of the control/communication method. Application specific gripper types and timing for gripper control are embedded in this category.
            'grippertype': 'String', # String
            # The ID of the GripperInfo. Unique within a body.
            'id': 'String', # String!
            # Number multiplier for imbalance force ratio from the center of mass of the target. The higher the value, the more imbalanced forces get penalized.
            'imbalanceForceRatioMult': 'Float', # Float
            # Angle in float
            'lineSensorAngleThresh': 'Float', # Float
            # The length of line sensor
            'lineSensorLength': 'Float', # Float
            # Link name of Line Sensor
            'lineSensorLinkName': 'String', # String
            # direction of plane of suction cups in manip coordinate system
            'localSuctionDir': 'Float', # [Float]
            # The speed limit to use when suction force equals target weight.
            'lowerSpeedRatio': 'Float', # Float
            # ratio [0,1], Lowest transfer speed multiplier when support region ratio of the part is less than supportRegionRatioFullSpeed
            'lowerSupportSpeedRatio': 'Float', # Float
            # ratio [0,1], If ratio of moment arm to suction force is greater than this parameter, then slow down robot while transferring grabbed item.
            'lowestMomentRatio': 'Float', # Float
            # speed [0,1], The speed to drop to when the robot is at the lowestMomentRatio.
            'lowestMomentRatioSpeed': 'Float', # Float
            # kg, The max weight supported by an entire suction pad (means all suction cups/holes are covered) in favorable conditions.
            'maxDistributedWeight': 'Float', # Float
            # The angle for max size for incidence angle
            'maxSizeForIncidenceAngle': 'Float', # Float
            # The value for rotate grasps max size
            'maxSizeForRotatedGrasps': 'Float', # Float
            # The max weight of an object the gripper can support. Any objects beyond this weight will be rejected.
            'maxWeight': 'Float', # Float
            # Value in [0,1] where 1 is 100% transfer speed multiplier. After grasp computation computes the transfer speed multiplier, any values less than 'minAcceptedTransferSpeedMult' will be rejected.
            'minAcceptedTransferSpeedMult': 'Float', # Float
            # The allowed minimum ratio of suction cups that needs to be inside of the pickable region. This is used to determine if a suction cup/pad is contributing to the grasp, and if it should be taken into account for the calculation of transfer speed and grasp failure.
            # 
            # If more cups of the total (or more surface of the suction pad) are covered than this ratio, the air pressure will be used to determine e.g. transfer speed and grasp failure. If only a smaller section of the cups/pad is covered by the part, the air pressure level is ignored. The suction cups/pad may nonetheless be used to increase the suction force.
            # 
            # Overrides defaultMinInsideCupsRatio.
            'minInsideCupsRatioPerLink': 'Float', # [Float]
            # Threshold momentArm/totalSuctionForce where momentArm is the amount of moment that comes from the target COM from where the center of force is, and totalSuctionForce is the total force of all suction cups that are touching the target. Making this parameter lower means grasps where center of force is too far from COM will get rejected more.
            'momentArmThresh': 'Float', # Float
            # A separate treshold when there's only a single cup involved. Thresholds momentArm/totalSuctionForce where momentArm is the amount of moment that comes from the target COM from where the center of force is, and totalSuctionForce is the total force of all suction cups that are touching the target.
            'momentArmThreshForSingleCup': 'Float', # Float
            # The name of the GripperInfo. Unique within a body.
            'name': 'String', # String
            # An array of nominal camera direction
            'nominalCameraDir': 'Float', # [Float]
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # If this combination of preshape and gripperControlIndex is not on the list, skip it
            'possibleAirChannelCombinationsPerPreshape': 'Int', # [[Int]]
            # Initial state of gripper joint values. Gripper joints are defined as all the joints after the end effector link.
            'preshapes': 'Float', # [[Float]]
            # Priority to multiply the scores by when adding to the grasp set.
            'priorityMultiplier': 'Float', # Float
            # List of ramp up speeds for each of the axes of the gripper.
            'rampUpSpeeds': 'Float', # [Float]
            # A bit map of air channel combinations to reject.
            'rejectAirChannelCombinations': 'Int', # [Int]
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Array of booleans to indicate skip rotation grasp per preshape or not
            'skipRotationGraspsPerPreshape': 'Boolean', # [Boolean]
            # The size ratio for the suction cup to use when trying to figure out whether the cup can make contact with the target surface. Used for computing grasps and deciding how much of the suction cups needs to touch the target in order to get a vacuum force.
            'suctionCupSizeRatio': 'Float', # Float
            # Depth value for suction press
            'suctionPressDepth': 'Float', # Float
            # Compute and threshold the (horizontal ratio between hand overlap target) * (ratio of suction force to target weight). The higher the threshold is, the more conservative the robot gets about handling targets with full speed.
            'supportHorzRatioFullSpeed': 'Float', # Float
            # The minimum supporting region ratio to get full speed for the target. This is proportional to SupportDist/COMHeight and totalSuctionForce/targetWeight. Lower this value is, the faster the robot goes for a target since full speed can happen with lower support. 0.6 for piece picking, 1.0 is for heavy cases.
            'supportRegionRatioFullSpeed': 'Float', # Float
            # mm, x,y,z, The offset translation to apply to the position of a part after grabbing. Some grippers have a mechanism such that the position of a grabbed part after grabbing differs from that on grabbing. In that case, the offset needs to be specified here in the tool coordinate system.
            'targetTranslationOffsetAfterGrabbing': 'Float', # [Float]
            # Time between blow when unchucking a part, setting this > 0 allows
            'timeBetweenBlow': 'Float', # Float
            # Defines the time to turn on/off suction before the final point of picking/transfering trajectory. For example: if this value is 0.5 then the robot will start suction 0.5 before reaching the final point of the trajectory approaching to a picking part. Usually defined by time needed for the hand to turn on.
            'timeToSetGripperIO': 'Float', # Float
            # Internally grasps are created for each new tool offset information specified here. air channels for each grasps are automatically choosed by computing overlapped suction cups which are linked to air channels through useLinkNames.
            'toolOffsetsForChannels': 'Float', # [[Float]]
            # Internally grasps are created for each new tool offset information specified here. This allows the robot to control different gripper IO depending on which tool offset is selected by planning. For each group, useLinkNames is mandatory. If toolTranslationOffset is not specified, then will compute new tool point based on the mean between the centers of all the cylinders.
            'toolOffsetsPerGrasp': 'GripperInfoToolOffsetsPerGrasp', # [GripperInfoToolOffsetsPerGrasp]
            # Array of link names related to tool size safety
            'toolSizeSafetyLinkNames': 'String', # [String]
            # When auto-computing tool XY size, add this padding to the tool size. Tool sizes are used for safety checking when using dynamic goal generator and for creating corner/edge grasps.
            'toolSizeSafetyPadding': 'Float', # Float
            # When auto-computing tool XY size, add this padding to the tool size. Tool sizes are used for safety checking when using dynamic goal generator and for creating corner/edge grasps.
            'toolSizeSafetyPaddings': 'Float', # [Float]
            # Translation offsets of the tool (per preshape)
            'toolTranslationOffsetsPerPreshape': 'Float', # [Float]
            # When the part is being grasped by the gripper, then continuously check the current for the gripper letting go of the part or not. If at any point in time the current drops below this theshold, then a piece lost error will occur.
            'torqueGripperHoldThresh': 'Float', # Float
            # Scale value of touching size
            'touchingSizeScale': 'Float', # Float
            # The offset to add to the gripper when unchucking the part
            'unchuckOffset': 'Float', # Float
            # Mapping between target mass and unchuck wait time. Unchuck wait time is an amount of time to wait for the hand to unchuck, will skip using feedback from the hand, used to speed up unchucking. If target mass is inbetween of values defined by this map, unchuck wait time is computed by linear interpolation. unchuckWaitTimePerMass is prioritized over unchuckWaitTime.
            'unchuckWaitTimePerMass': 'GripperInfoUnchuckWaitTimePerMass', # [GripperInfoUnchuckWaitTimePerMass]
            # Unit used in gripper info
            'unit': 'String', # String
            # Set to true to enable gripper info.
            'use': 'Boolean', # Boolean
            # All the link names used by the gripper. For suction grippers, this is the link names where suction cups are defined. Each link must have a list of cylinders, where each cylinder represents the surface area of the suction cup it is modeling.
            'useLinkNames': 'String', # [String]
            # Boolean to enable overlap checking
            'useOverlap': 'Boolean', # Boolean
            # If True, then partially touching cups are also turned on and become part of the grasp set. This allows the possibly of cups accidentally grabbing adjacent parts. Although the picking system will check to make sure there are no double picks like this by using the point clouds and neighboring detection results, misisng data could make it possible that double picks occur. For applications with very light parts that can be partially picked up like this, set this parameter to False. For applications that need as much force as possible, set this to True.
            'usePartiallyTouchingCups': 'Boolean', # Boolean
        },

        # The information for each tool offset.
        'GripperInfoAirChannel': {
            # multiplied graspDepartAccel and destDepartAccel. it can be used to avoid passive sucker like suction pad lift neighbor stuffs up when such suction pad is not used.
            'departAccelMultWhenUnused': 'Float', # Float
            # If true, then there are valves attached to each of the suction cups, which allow one cup not to make contact
            'haveValve': 'Boolean', # Boolean
            # kg, The max weight supported by an entire suction pad (means all suction cups/holes are covered) in favorable conditions.
            'maxDistributedWeight': 'Float', # Float
            # Max angle the suction cup can make with respect to the plane of the part and still suck successfully. This will only be applied if all the suction cups are in a line or there is one single suction cup.
            'maxIncidenceAngle': 'Float', # Float
            # kg, The max weight supported by each suction cup in favorable conditions.
            'maxWeights': 'Float', # [Float]
            # The allowed minimum ratio of suction cups that needs to be inside of the pickable region. This is used to determine if a suction cup/pad is contributing to the grasp, and if it should be taken into account for the calculation of transfer speed and grasp failure.
            # 
            # If more cups of the total (or more surface of the suction pad) are covered than this ratio, the air pressure will be used to determine e.g. transfer speed and grasp failure. If only a smaller section of the cups/pad is covered by the part, the air pressure level is ignored. The suction cups/pad may nonetheless be used to increase the suction force.
            # 
            # Overrides defaultMinInsideCupsRatio.
            'minInsideCupsRatioPerLink': 'Float', # [Float]
            # Priority of this air channel.
            'priority': 'Float', # Float
            # The part type of the suction cups. Using this assumes all the suction cups have the same part type
            'suctionCupPartType': 'String', # String
            # All the part types of the suction cups.
            'suctionCupPartTypes': 'String', # [String]
            # If True, then use the channel for registration
            'useForRegistration': 'Boolean', # Boolean
            # Links to use when using this grasp that represent the suction cups/links that will move with the specified 'gripperControlIndex'.
            'useLinkNames': 'String', # [String]
        },

        # The information for each tool offset.
        'GripperInfoAirChannelInput': {
            # multiplied graspDepartAccel and destDepartAccel. it can be used to avoid passive sucker like suction pad lift neighbor stuffs up when such suction pad is not used.
            'departAccelMultWhenUnused': 'Float', # Float
            # If true, then there are valves attached to each of the suction cups, which allow one cup not to make contact
            'haveValve': 'Boolean', # Boolean
            # kg, The max weight supported by an entire suction pad (means all suction cups/holes are covered) in favorable conditions.
            'maxDistributedWeight': 'Float', # Float
            # Max angle the suction cup can make with respect to the plane of the part and still suck successfully. This will only be applied if all the suction cups are in a line or there is one single suction cup.
            'maxIncidenceAngle': 'Float', # Float
            # kg, The max weight supported by each suction cup in favorable conditions.
            'maxWeights': 'Float', # [Float]
            # The allowed minimum ratio of suction cups that needs to be inside of the pickable region. This is used to determine if a suction cup/pad is contributing to the grasp, and if it should be taken into account for the calculation of transfer speed and grasp failure.
            # 
            # If more cups of the total (or more surface of the suction pad) are covered than this ratio, the air pressure will be used to determine e.g. transfer speed and grasp failure. If only a smaller section of the cups/pad is covered by the part, the air pressure level is ignored. The suction cups/pad may nonetheless be used to increase the suction force.
            # 
            # Overrides defaultMinInsideCupsRatio.
            'minInsideCupsRatioPerLink': 'Float', # [Float]
            # Priority of this air channel.
            'priority': 'Float', # Float
            # The part type of the suction cups. Using this assumes all the suction cups have the same part type
            'suctionCupPartType': 'String', # String
            # All the part types of the suction cups.
            'suctionCupPartTypes': 'String', # [String]
            # If True, then use the channel for registration
            'useForRegistration': 'Boolean', # Boolean
            # Links to use when using this grasp that represent the suction cups/links that will move with the specified 'gripperControlIndex'.
            'useLinkNames': 'String', # [String]
        },

        # The longer edge of the tool is aligned to the longer edge of the target.
        'GripperInfoAlignLongEdgeInfo': {
            # ratio, when the ratio of the longer edge length to the shorter edge length of the target is smaller than this, the target is treated as square shaped and alignment to the shorter edge is allowed
            'treatAsSquareTargetExtentsRatio': 'Float', # Float
            # Set to true to enable align long edge for grasp generation
            'use': 'Boolean', # Boolean
        },

        # The longer edge of the tool is aligned to the longer edge of the target.
        'GripperInfoAlignLongEdgeInfoInput': {
            # ratio, when the ratio of the longer edge length to the shorter edge length of the target is smaller than this, the target is treated as square shaped and alignment to the shorter edge is allowed
            'treatAsSquareTargetExtentsRatio': 'Float', # Float
            # Set to true to enable align long edge for grasp generation
            'use': 'Boolean', # Boolean
        },

        # Direction of Camera Angle
        'GripperInfoCameraDirAngleInfo': {
            # Maximum angle in radian
            'max': 'Float', # Float
            # Minimum angle in radian
            'min': 'Float', # Float
            # The sampling steps
            'step': 'Int', # Int
        },

        # Direction of Camera Angle
        'GripperInfoCameraDirAngleInfoInput': {
            # Maximum angle in radian
            'max': 'Float', # Float
            # Minimum angle in radian
            'min': 'Float', # Float
            # The sampling steps
            'step': 'Int', # Int
        },

        # Distance info of camera
        'GripperInfoCameraDistanceInfo': {
            # Maximum distance of camera in millimeter
            'max': 'Int', # Int
            # Minimum distance of camera in millimeter
            'min': 'Int', # Int
            # The sampling steps
            'step': 'Int', # Int
        },

        # Distance info of camera
        'GripperInfoCameraDistanceInfoInput': {
            # Maximum distance of camera in millimeter
            'max': 'Int', # Int
            # Minimum distance of camera in millimeter
            'min': 'Int', # Int
            # The sampling steps
            'step': 'Int', # Int
        },

        # Roll Info of camera
        'GripperInfoCameraRollInfo': {
            # Maximum roll angle in degree
            'max': 'Float', # Float
            # Minimum roll angle in degree
            'min': 'Float', # Float
            # The sampling steps
            'step': 'Int', # Int
        },

        # Roll Info of camera
        'GripperInfoCameraRollInfoInput': {
            # Maximum roll angle in degree
            'max': 'Float', # Float
            # Minimum roll angle in degree
            'min': 'Float', # Float
            # The sampling steps
            'step': 'Int', # Int
        },

        # Check-collision grid info specifies points in XY plane of the grasp ikparam frame that the end-effector collision checking should be performed. This is used for grasp validation.
        'GripperInfoCheckCollisionGridInfo': {
            # mm, The step size used to create a grid inside collisionAreaSizeXY.
            'checkCollisionStepSize': 'Float', # Float
            # mm, Specifies the dimension of a rectangle inside which the end-effector collision checking should be performed.
            'collisionAreaSizeXY': 'Float', # [Float]
            # mm, The collision checking grid will be offset from the grasp point by these offsets.
            'offsetClearanceXYZ': 'Float', # [Float]
            # Set to true to enable check-collision grid for grasp validation.
            'use': 'Boolean', # Boolean
        },

        # Check-collision grid info specifies points in XY plane of the grasp ikparam frame that the end-effector collision checking should be performed. This is used for grasp validation.
        'GripperInfoCheckCollisionGridInfoInput': {
            # mm, The step size used to create a grid inside collisionAreaSizeXY.
            'checkCollisionStepSize': 'Float', # Float
            # mm, Specifies the dimension of a rectangle inside which the end-effector collision checking should be performed.
            'collisionAreaSizeXY': 'Float', # [Float]
            # mm, The collision checking grid will be offset from the grasp point by these offsets.
            'offsetClearanceXYZ': 'Float', # [Float]
            # Set to true to enable check-collision grid for grasp validation.
            'use': 'Boolean', # Boolean
        },

        # Parameters for Compute Finger Value
        'GripperInfoComputeFingerValuesParameters': {
            # Coarse step
            'coarsestep': 'Float', # Float
            # Ranges for expected final gripper
            'expectedFinalGripperRanges': 'Float', # [Float]
            # Fine step
            'finestep': 'Float', # Float
            # Names of finger tip links to be used during grasp kinematics feasibility checking.
            'fingerTipLinkNames': 'String', # [String]
            # Indices of ordered DOF
            'orderedDOFIndices': 'Int', # [Int]
            # The step size from lower limit to upper limit
            'stepsize': 'Float', # Float
            # The translation step's multiplier.
            'translationstepmult': 'Float', # Float
        },

        # Parameters for Compute Finger Value
        'GripperInfoComputeFingerValuesParametersInput': {
            # Coarse step
            'coarsestep': 'Float', # Float
            # Ranges for expected final gripper
            'expectedFinalGripperRanges': 'Float', # [Float]
            # Fine step
            'finestep': 'Float', # Float
            # Names of finger tip links to be used during grasp kinematics feasibility checking.
            'fingerTipLinkNames': 'String', # [String]
            # Indices of ordered DOF
            'orderedDOFIndices': 'Int', # [Int]
            # The step size from lower limit to upper limit
            'stepsize': 'Float', # Float
            # The translation step's multiplier.
            'translationstepmult': 'Float', # Float
        },

        # Project-Id-Version: PACKAGE VERSION
        # Report-Msgid-Bugs-To: 
        # PO-Revision-Date: 2015-11-09 17:26+0900
        # Last-Translator: Automatically generated
        # Language-Team: none
        # Language: en_US
        # MIME-Version: 1.0
        # Content-Type: text/plain; charset=ASCII
        # Content-Transfer-Encoding: 8bit
        # Plural-Forms: nplurals=2; plural=(n != 1);
        'GripperInfoGrabbingPartPositionBalanceCheckInfo': {
            # IO names to check
            'checkIONames': 'String', # [String]
            # seconds, Part position balance is checked during approaching a destination after this delay duration. This parameter can be used to compensate a robot control latency.
            'checkStartTimeDelay': 'Float', # Float
            # All the IO values need to change within this time, otherwise the part might be unbalanced in the gripper, and system should stop with PieceLost.
            'thresholdForTime': 'Float', # Float
            # mm, All the IO values need to change within this tool translational travel distance, otherwise the part might be unbalanced in the gripper, and system should stop with PieceLost.
            'thresholdForToolTravelDistance': 'Float', # Float
        },

        # Project-Id-Version: PACKAGE VERSION
        # Report-Msgid-Bugs-To: 
        # PO-Revision-Date: 2015-11-09 17:26+0900
        # Last-Translator: Automatically generated
        # Language-Team: none
        # Language: en_US
        # MIME-Version: 1.0
        # Content-Type: text/plain; charset=ASCII
        # Content-Transfer-Encoding: 8bit
        # Plural-Forms: nplurals=2; plural=(n != 1);
        'GripperInfoGrabbingPartPositionBalanceCheckInfoInput': {
            # IO names to check
            'checkIONames': 'String', # [String]
            # seconds, Part position balance is checked during approaching a destination after this delay duration. This parameter can be used to compensate a robot control latency.
            'checkStartTimeDelay': 'Float', # Float
            # All the IO values need to change within this time, otherwise the part might be unbalanced in the gripper, and system should stop with PieceLost.
            'thresholdForTime': 'Float', # Float
            # mm, All the IO values need to change within this tool translational travel distance, otherwise the part might be unbalanced in the gripper, and system should stop with PieceLost.
            'thresholdForToolTravelDistance': 'Float', # Float
        },

        # Gripper info describing the gripper properties, used for planning gripper operations.
        'GripperInfoInput': {
            # Describes the properties and link associations of each air channel
            'airchannels': 'GripperInfoAirChannelInput', # [GripperInfoAirChannelInput]
            # The longer edge of the tool is aligned to the longer edge of the target.
            'alignLongEdgeInfo': 'GripperInfoAlignLongEdgeInfoInput', # GripperInfoAlignLongEdgeInfoInput
            # A boolean indicates the automatic finger values generation
            'automaticFingerValuesGeneration': 'Boolean', # Boolean
            # If 1, then can blow the part while blowWhileDestDeparting. By default this is None, meaning system makes best judgement
            'blowWhileDestDeparting': 'Boolean', # Boolean
            # Direction of Camera Angle
            'cameraDirAngleInfo': 'GripperInfoCameraDirAngleInfoInput', # GripperInfoCameraDirAngleInfoInput
            # Distance info of camera
            'cameraDistanceInfo': 'GripperInfoCameraDistanceInfoInput', # GripperInfoCameraDistanceInfoInput
            # Roll Info of camera
            'cameraRollInfo': 'GripperInfoCameraRollInfoInput', # GripperInfoCameraRollInfoInput
            # Check-collision grid info specifies points in XY plane of the grasp ikparam frame that the end-effector collision checking should be performed. This is used for grasp validation.
            'checkCollisionGridInfo': 'GripperInfoCheckCollisionGridInfoInput', # GripperInfoCheckCollisionGridInfoInput
            # Boolean to enable check collision when unused
            'checkCollisionWhenUnused': 'Boolean', # Boolean
            # If "first_and_then_or", then robot first checks to make sure that all planned suction cups are ON, otherwise will return with PieceLost. After robot validates that all used suction cups's pressure is good, then it will switch to "or" setting so that the cycle doesn't stop if one suction cup is bad. If "and", then all io values should feet mapCheckHandIOForSuccessMask to count grasp as successfull. By default it is "or" which means grasp count as successful if ANY of the suction cups are ON.
            'checkIOForSuccessOperation': 'String', # String
            # List of names of child grippers. Applicable only when using grouped grippers.
            'childGripperNames': 'String', # [String]
            # The amount of time to delay sending the chuck signals. Sometimes when the robot is moving too fast, the physical robot will not catch up with the commanded trajectory. In that case, if the gripper is suction and has valves and pressure is turned on, there is a good chance the valves will trigger leading the robot to believe there is something picked up.
            'chuckEventDelayFromApproach': 'Float', # Float
            # Used to determine when internal joints stop moving by checking the current encoder values with those in the past. If all values are within this threshold, will stop.
            'chuckJointDeltaToStop': 'Float', # Float
            # The offset to add to every finger's joints chucking direction from the predicted value. Used to make gripper move a little bit more, to make torque and pressure on the picking part to hold it stronger.
            'chuckOffset': 'Float', # Float
            # The default chucking direction of each of the individual gripper joints when grasping the part. If 0, then joint won't move. Size is gripper DOF. This can be overwritten by different grasps.
            'chuckingDirection': 'Float', # [Float]
            # Parameters for Compute Finger Value
            'computeFingerValuesParameters': 'GripperInfoComputeFingerValuesParametersInput', # GripperInfoComputeFingerValuesParametersInput
            # The allowed minimum ratio of suction cups that needs to be inside of the pickable region before a suction cup/pad's is considered to contribute to the grasp, and be considered for the calculation of transfer speed and grasp failure.
            # 
            # If more cups of the total (or more surface of the suction pad) are covered than this ratio, the air pressure will be used to determine e.g. transfer speed and grasp failure. If only a smaller section of the cups/pad is covered by the part, the air pressure level is ignored. The suction cups/pad may nonetheless be used to increase the suction force.
            # 
            # If minInsideCupsRatioPerLink is set, this value is overridden.
            'defaultMinInsideCupsRatio': 'Float', # Float
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The mass of discretization
            'discretizationMass': 'Float', # Float
            # How much to discretize priorities using XYZ in order to avoid small noise from affecting the priority computation directly.
            'discretizationXYZ': 'Float', # [Float]
            # List of 3-values of extra tool offsets in addition the automatically computed tool offsets. Each automatically computed tool offset will also generate a grasp with these translation offsets computed
            'extraToolTranslationOffsets': 'Float', # [[Float]]
            # When set, only these gripper control indices will be activated during a grasp.
            'filterGripperControlIndices': 'Int', # [Int]
            # The index of force gripper control
            'forceGripperControlIndex': 'Int', # Int
            # If grippertype is airchannels and value is True will do blow out on all airchannels regardless on which airchannel was used for grasp.
            'forceUnchuckAllAirChannels': 'Boolean', # Boolean
            # If ratio between suction force and target weight exceeds this parameter, then robot transfer speed due to weight component is full speed. Otherwise, the speed reduces linearly up until suction force is equal to taret weight.
            'fullSpeedCutoff': 'Float', # Float
            # When generating grasps for the hand, generate specific offsets per object such that the corner of the gripper alignes with each of the corners of the box. This greatly helps in palleitizing and depalletizing applications.
            'generateCornerOffsets': 'Boolean', # Boolean
            # Project-Id-Version: PACKAGE VERSION
            # Report-Msgid-Bugs-To: 
            # PO-Revision-Date: 2015-11-09 17:26+0900
            # Last-Translator: Automatically generated
            # Language-Team: none
            # Language: en_US
            # MIME-Version: 1.0
            # Content-Type: text/plain; charset=ASCII
            # Content-Transfer-Encoding: 8bit
            # Plural-Forms: nplurals=2; plural=(n != 1);
            'grabbingPartPositionBalanceCheckInfo': 'GripperInfoGrabbingPartPositionBalanceCheckInfoInput', # GripperInfoGrabbingPartPositionBalanceCheckInfoInput
            # The time from which we start checking for value of pressureSensorIO
            'gripperIOCheckStartTime': 'Float', # Float
            # List of gripper joint names.
            'gripperJointNames': 'String', # [String]
            # The id used to match what registration system gripper the customer did the confirmation with.
            'gripperModelId': 'String', # String
            # Type of gripper that will be used for planning. This is the type regardless of the control/communication method. Application specific gripper types and timing for gripper control are embedded in this category.
            'grippertype': 'String', # String
            # The ID of the GripperInfo. Unique within a body.
            'id': 'String', # String
            # Number multiplier for imbalance force ratio from the center of mass of the target. The higher the value, the more imbalanced forces get penalized.
            'imbalanceForceRatioMult': 'Float', # Float
            # Angle in float
            'lineSensorAngleThresh': 'Float', # Float
            # The length of line sensor
            'lineSensorLength': 'Float', # Float
            # Link name of Line Sensor
            'lineSensorLinkName': 'String', # String
            # direction of plane of suction cups in manip coordinate system
            'localSuctionDir': 'Float', # [Float]
            # The speed limit to use when suction force equals target weight.
            'lowerSpeedRatio': 'Float', # Float
            # ratio [0,1], Lowest transfer speed multiplier when support region ratio of the part is less than supportRegionRatioFullSpeed
            'lowerSupportSpeedRatio': 'Float', # Float
            # ratio [0,1], If ratio of moment arm to suction force is greater than this parameter, then slow down robot while transferring grabbed item.
            'lowestMomentRatio': 'Float', # Float
            # speed [0,1], The speed to drop to when the robot is at the lowestMomentRatio.
            'lowestMomentRatioSpeed': 'Float', # Float
            # kg, The max weight supported by an entire suction pad (means all suction cups/holes are covered) in favorable conditions.
            'maxDistributedWeight': 'Float', # Float
            # The angle for max size for incidence angle
            'maxSizeForIncidenceAngle': 'Float', # Float
            # The value for rotate grasps max size
            'maxSizeForRotatedGrasps': 'Float', # Float
            # The max weight of an object the gripper can support. Any objects beyond this weight will be rejected.
            'maxWeight': 'Float', # Float
            # Value in [0,1] where 1 is 100% transfer speed multiplier. After grasp computation computes the transfer speed multiplier, any values less than 'minAcceptedTransferSpeedMult' will be rejected.
            'minAcceptedTransferSpeedMult': 'Float', # Float
            # The allowed minimum ratio of suction cups that needs to be inside of the pickable region. This is used to determine if a suction cup/pad is contributing to the grasp, and if it should be taken into account for the calculation of transfer speed and grasp failure.
            # 
            # If more cups of the total (or more surface of the suction pad) are covered than this ratio, the air pressure will be used to determine e.g. transfer speed and grasp failure. If only a smaller section of the cups/pad is covered by the part, the air pressure level is ignored. The suction cups/pad may nonetheless be used to increase the suction force.
            # 
            # Overrides defaultMinInsideCupsRatio.
            'minInsideCupsRatioPerLink': 'Float', # [Float]
            # Threshold momentArm/totalSuctionForce where momentArm is the amount of moment that comes from the target COM from where the center of force is, and totalSuctionForce is the total force of all suction cups that are touching the target. Making this parameter lower means grasps where center of force is too far from COM will get rejected more.
            'momentArmThresh': 'Float', # Float
            # A separate treshold when there's only a single cup involved. Thresholds momentArm/totalSuctionForce where momentArm is the amount of moment that comes from the target COM from where the center of force is, and totalSuctionForce is the total force of all suction cups that are touching the target.
            'momentArmThreshForSingleCup': 'Float', # Float
            # The name of the GripperInfo. Unique within a body.
            'name': 'String', # String
            # An array of nominal camera direction
            'nominalCameraDir': 'Float', # [Float]
            # If this combination of preshape and gripperControlIndex is not on the list, skip it
            'possibleAirChannelCombinationsPerPreshape': 'Int', # [[Int]]
            # Initial state of gripper joint values. Gripper joints are defined as all the joints after the end effector link.
            'preshapes': 'Float', # [[Float]]
            # Priority to multiply the scores by when adding to the grasp set.
            'priorityMultiplier': 'Float', # Float
            # List of ramp up speeds for each of the axes of the gripper.
            'rampUpSpeeds': 'Float', # [Float]
            # A bit map of air channel combinations to reject.
            'rejectAirChannelCombinations': 'Int', # [Int]
            # Array of booleans to indicate skip rotation grasp per preshape or not
            'skipRotationGraspsPerPreshape': 'Boolean', # [Boolean]
            # The size ratio for the suction cup to use when trying to figure out whether the cup can make contact with the target surface. Used for computing grasps and deciding how much of the suction cups needs to touch the target in order to get a vacuum force.
            'suctionCupSizeRatio': 'Float', # Float
            # Depth value for suction press
            'suctionPressDepth': 'Float', # Float
            # Compute and threshold the (horizontal ratio between hand overlap target) * (ratio of suction force to target weight). The higher the threshold is, the more conservative the robot gets about handling targets with full speed.
            'supportHorzRatioFullSpeed': 'Float', # Float
            # The minimum supporting region ratio to get full speed for the target. This is proportional to SupportDist/COMHeight and totalSuctionForce/targetWeight. Lower this value is, the faster the robot goes for a target since full speed can happen with lower support. 0.6 for piece picking, 1.0 is for heavy cases.
            'supportRegionRatioFullSpeed': 'Float', # Float
            # mm, x,y,z, The offset translation to apply to the position of a part after grabbing. Some grippers have a mechanism such that the position of a grabbed part after grabbing differs from that on grabbing. In that case, the offset needs to be specified here in the tool coordinate system.
            'targetTranslationOffsetAfterGrabbing': 'Float', # [Float]
            # Time between blow when unchucking a part, setting this > 0 allows
            'timeBetweenBlow': 'Float', # Float
            # Defines the time to turn on/off suction before the final point of picking/transfering trajectory. For example: if this value is 0.5 then the robot will start suction 0.5 before reaching the final point of the trajectory approaching to a picking part. Usually defined by time needed for the hand to turn on.
            'timeToSetGripperIO': 'Float', # Float
            # Internally grasps are created for each new tool offset information specified here. air channels for each grasps are automatically choosed by computing overlapped suction cups which are linked to air channels through useLinkNames.
            'toolOffsetsForChannels': 'Float', # [[Float]]
            # Internally grasps are created for each new tool offset information specified here. This allows the robot to control different gripper IO depending on which tool offset is selected by planning. For each group, useLinkNames is mandatory. If toolTranslationOffset is not specified, then will compute new tool point based on the mean between the centers of all the cylinders.
            'toolOffsetsPerGrasp': 'GripperInfoToolOffsetsPerGraspInput', # [GripperInfoToolOffsetsPerGraspInput]
            # Array of link names related to tool size safety
            'toolSizeSafetyLinkNames': 'String', # [String]
            # When auto-computing tool XY size, add this padding to the tool size. Tool sizes are used for safety checking when using dynamic goal generator and for creating corner/edge grasps.
            'toolSizeSafetyPadding': 'Float', # Float
            # When auto-computing tool XY size, add this padding to the tool size. Tool sizes are used for safety checking when using dynamic goal generator and for creating corner/edge grasps.
            'toolSizeSafetyPaddings': 'Float', # [Float]
            # Translation offsets of the tool (per preshape)
            'toolTranslationOffsetsPerPreshape': 'Float', # [Float]
            # When the part is being grasped by the gripper, then continuously check the current for the gripper letting go of the part or not. If at any point in time the current drops below this theshold, then a piece lost error will occur.
            'torqueGripperHoldThresh': 'Float', # Float
            # Scale value of touching size
            'touchingSizeScale': 'Float', # Float
            # The offset to add to the gripper when unchucking the part
            'unchuckOffset': 'Float', # Float
            # Mapping between target mass and unchuck wait time. Unchuck wait time is an amount of time to wait for the hand to unchuck, will skip using feedback from the hand, used to speed up unchucking. If target mass is inbetween of values defined by this map, unchuck wait time is computed by linear interpolation. unchuckWaitTimePerMass is prioritized over unchuckWaitTime.
            'unchuckWaitTimePerMass': 'GripperInfoUnchuckWaitTimePerMassInput', # [GripperInfoUnchuckWaitTimePerMassInput]
            # Unit used in gripper info
            'unit': 'String', # String
            # Set to true to enable gripper info.
            'use': 'Boolean', # Boolean
            # All the link names used by the gripper. For suction grippers, this is the link names where suction cups are defined. Each link must have a list of cylinders, where each cylinder represents the surface area of the suction cup it is modeling.
            'useLinkNames': 'String', # [String]
            # Boolean to enable overlap checking
            'useOverlap': 'Boolean', # Boolean
            # If True, then partially touching cups are also turned on and become part of the grasp set. This allows the possibly of cups accidentally grabbing adjacent parts. Although the picking system will check to make sure there are no double picks like this by using the point clouds and neighboring detection results, misisng data could make it possible that double picks occur. For applications with very light parts that can be partially picked up like this, set this parameter to False. For applications that need as much force as possible, set this to True.
            'usePartiallyTouchingCups': 'Boolean', # Boolean
        },

        # The information for each tool offset.
        'GripperInfoToolOffsetsPerGrasp': {
            # Specifies a unique index into graspParameterMap from gripperControl that can set new IO for suction and pressure checking.
            'gripperControlIndex': 'Int', # Int
            # Max angle the suction cup can make with respect to the plane of the part and still suck successfully. This will only be applied if all the suction cups are in a line or there is one single suction cup.
            'maxIncidenceAngle': 'Float', # Float
            # Priority of this tool offset definition which is added to the original grasp's priority and then the grasps are ordered. The offset with higher priority will be checked before the lower ones. Usually this value should be set to negative so that it is less prioritized than the default tool.
            'priority': 'Float', # Float
            # mm, x,y,z, A new tool offset defined in the currently used tool coordinates. If not specified, will use the center of each cylinder to compute the translation offset.
            'toolTranslationOffset': 'Float', # [Float]
            # Links to use when using this grasp that represent the suction cups/links that will move with the specified 'gripperControlIndex'. Has to already be defined in checkOverlapRobotLinkNames
            'useLinkNames': 'String', # [String]
        },

        # The information for each tool offset.
        'GripperInfoToolOffsetsPerGraspInput': {
            # Specifies a unique index into graspParameterMap from gripperControl that can set new IO for suction and pressure checking.
            'gripperControlIndex': 'Int', # Int
            # Max angle the suction cup can make with respect to the plane of the part and still suck successfully. This will only be applied if all the suction cups are in a line or there is one single suction cup.
            'maxIncidenceAngle': 'Float', # Float
            # Priority of this tool offset definition which is added to the original grasp's priority and then the grasps are ordered. The offset with higher priority will be checked before the lower ones. Usually this value should be set to negative so that it is less prioritized than the default tool.
            'priority': 'Float', # Float
            # mm, x,y,z, A new tool offset defined in the currently used tool coordinates. If not specified, will use the center of each cylinder to compute the translation offset.
            'toolTranslationOffset': 'Float', # [Float]
            # Links to use when using this grasp that represent the suction cups/links that will move with the specified 'gripperControlIndex'. Has to already be defined in checkOverlapRobotLinkNames
            'useLinkNames': 'String', # [String]
        },

        # Unchuck Wait Time per Mass
        'GripperInfoUnchuckWaitTimePerMass': {
            # Mass of Target in kg
            'mass': 'Float', # Float
            # Unchuck Wait Time in seconds.
            'waitTime': 'Float', # Float
        },

        # Unchuck Wait Time per Mass
        'GripperInfoUnchuckWaitTimePerMassInput': {
            # Mass of Target in kg
            'mass': 'Float', # Float
            # Unchuck Wait Time in seconds.
            'waitTime': 'Float', # Float
        },

        # Scores how a gripper's suction cups are performing.
        'GripperSuctionCupsPerformance': {
            'gripperName': 'String', # String!
            # Scores the performance of a set of suction cups.
            'suctionCupsPerformances': 'SuctionCupsPerformance', # [SuctionCupsPerformance!]!
        },

        # Scores how a gripper's suction cups are performing.
        'GripperSuctionCupsPerformanceInput': {
            'gripperName': 'String', # String!
            # Scores the performance of a set of suction cups.
            'suctionCupsPerformances': 'SuctionCupsPerformanceInput', # [SuctionCupsPerformanceInput!]!
        },

        # Parameters used to prioritize and order items for packing
        'GroupComparatorParameters': {
            # If True, then will shift the entire pack up so that the first layer can align with the last layer.
            'autoPackMoveResultsToLastLayer': 'Boolean', # Boolean
            # If True, then will use the previous computed auto-pack results for that SKU rather than computing from scratch every .
            'autoPackUseCache': 'Boolean', # Boolean
            # Coefficient on how much to prioritize items with bigger height.
            'heightCoefficient': 'Float', # Float
            # Coefficient on how much to prioritize items with bigger X or Y dimension.
            'longestCoefficient': 'Float', # Float
            # mm, discretization step of a packing item by z dimension.
            'packingItemHeightDiscretizationStep': 'Float', # Float
            # Coefficient on how much to prioritize groups which will increase already generated layers.
            'similarLayerCoefficient': 'Float', # Float
            # Set to true to enable packing items re-ordering from the input order.
            'use': 'Boolean', # Boolean
            # Coefficient on how much to prioritize groups with total bigger weight.
            'weightCoefficient': 'Float', # Float
            # Coefficient on how much to prioritize items with bigger XY surface.
            'xySurfaceCoefficient': 'Float', # Float
        },

        # Parameters used to prioritize and order items for packing
        'GroupComparatorParametersInput': {
            # If True, then will shift the entire pack up so that the first layer can align with the last layer.
            'autoPackMoveResultsToLastLayer': 'Boolean', # Boolean
            # If True, then will use the previous computed auto-pack results for that SKU rather than computing from scratch every .
            'autoPackUseCache': 'Boolean', # Boolean
            # Coefficient on how much to prioritize items with bigger height.
            'heightCoefficient': 'Float', # Float
            # Coefficient on how much to prioritize items with bigger X or Y dimension.
            'longestCoefficient': 'Float', # Float
            # mm, discretization step of a packing item by z dimension.
            'packingItemHeightDiscretizationStep': 'Float', # Float
            # Coefficient on how much to prioritize groups which will increase already generated layers.
            'similarLayerCoefficient': 'Float', # Float
            # Set to true to enable packing items re-ordering from the input order.
            'use': 'Boolean', # Boolean
            # Coefficient on how much to prioritize groups with total bigger weight.
            'weightCoefficient': 'Float', # Float
            # Coefficient on how much to prioritize items with bigger XY surface.
            'xySurfaceCoefficient': 'Float', # Float
        },

        'HypervisorAvailableUpgrade': {
            # Build id for reference.
            'buildId': 'String', # String!
            # Runtime image info, if upgrade includes runtime image.
            'imageId': 'String', # String!
            # Project name.
            'project': 'String', # String!
            # Provisioning version, if upgrade includes provisioning.
            'provisioningVersion': 'String', # String!
            # Timestamp when the upgrade was published.
            'publishedAt': 'DateTime', # DateTime!
            # Hash of the upgrade image.
            'sha1': 'String', # String!
            # Size of the upgrade image.
            'size': 'Int', # Int!
            # Url to download this upgrade.
            'url': 'String', # String!
        },

        'HypervisorCPUStatus': {
            # cpu temperature in celsius
            'temperature': 'Float', # Float!
            # cpu usage in percentage
            'usage': 'Float', # Float!
            # cpu usage per core in percentage
            'usages': 'Float', # [Float!]!
        },

        # clock drift event
        'HypervisorClockDrift': {
            # amount of drift
            'drift': 'Float', # Float!
            # timestamp when drift happened
            'monotonic': 'Float', # Float!
            # timestamp when drift happened
            'timestamp': 'Float', # Float!
        },

        # drive status in the disk array
        'HypervisorDiskArrayDriveStatus': {
            # device path of the drive, for example "/dev/sda"
            'device': 'String', # String!
            # sync progress from 0 to 1
            'progress': 'Float', # Float
            # state of the drive, for example "working"
            'state': 'String', # String!
        },

        # disk array status
        'HypervisorDiskArrayStatus': {
            # number of active members in the array
            'active': 'Int', # Int!
            # when array was created
            'created': 'DateTime', # DateTime!
            # device path, for example "/dev/md0"
            'device': 'String', # String!
            # status of each drive in the array
            'drives': 'HypervisorDiskArrayDriveStatus', # [HypervisorDiskArrayDriveStatus!]!
            # number of events
            'events': 'Int', # Int!
            # io stats
            'io': 'HypervisorDiskIOStats', # HypervisorDiskIOStats
            # raid level, for example "raid1"
            'level': 'String', # String!
            # name of the array
            'name': 'String', # String!
            # overall sync progress
            'progress': 'Float', # Float
            # states of the array
            'states': 'String', # [String!]!
            # when array was updated
            'updated': 'DateTime', # DateTime!
            # uuid of the array
            'uuid': 'String', # String!
        },

        # array metadata on disk drive
        'HypervisorDiskDriveArrayStatus': {
            # number of active members in the array
            'active': 'Int', # Int!
            # when array was created
            'created': 'DateTime', # DateTime!
            # number of events
            'events': 'Int', # Int!
            # raid level, for example "raid1"
            'level': 'String', # String!
            # name of the array
            'name': 'String', # String!
            # when array was updated
            'updated': 'DateTime', # DateTime!
            # uuid of the array
            'uuid': 'String', # String!
        },

        # disk smart attributes
        'HypervisorDiskDriveAttribute': {
            'id': 'Int', # Int!
            'raw': 'Int', # Int!
            'value': 'Int', # Int!
            'worst': 'Int', # Int!
        },

        # disk drive status
        'HypervisorDiskDriveStatus': {
            # if the drive belongs to an array, the metadata about that array
            'array': 'HypervisorDiskDriveArrayStatus', # HypervisorDiskDriveArrayStatus
            # additional attributes
            'attributes': 'HypervisorDiskDriveAttribute', # [HypervisorDiskDriveAttribute!]!
            # device path, for example "/dev/sda1"
            'device': 'String', # String!
            # sata host number
            'host': 'Int', # Int!
            # io stats
            'io': 'HypervisorDiskIOStats', # HypervisorDiskIOStats
            # model of the drive
            'model': 'String', # String!
            # power cycles count
            'power_cycles': 'Int', # Int!
            # power on hours count
            'power_on_hours': 'Int', # Int!
            # serial number
            'serial': 'String', # String!
            # size of the drive
            'size': 'Int', # Int!
            # temperature of the drive
            'temperature': 'Float', # Float!
            # physical tray index
            'tray': 'Int', # Int
        },

        # common disk stats structure
        'HypervisorDiskIOStats': {
            'active_time': 'Int', # Int!
            'inflight_count': 'Int', # Int!
            'read_bytes': 'Int', # Int!
            'read_count': 'Int', # Int!
            'read_time': 'Int', # Int!
            'time_in_queue': 'Int', # Int!
            'write_bytes': 'Int', # Int!
            'write_count': 'Int', # Int!
            'write_time': 'Int', # Int!
        },

        # disk partitions
        'HypervisorDiskPartitionStatus': {
            'available': 'Int', # Int!
            # system, data, log
            'category': 'String', # String!
            # backing device name, filesystem type and mount options
            'device': 'String', # String!
            'fstype': 'String', # String!
            # io stats
            'io': 'HypervisorDiskIOStats', # HypervisorDiskIOStats
            # disk label
            'label': 'String', # String!
            # mountpoint on filesystem
            'mountpoint': 'String', # String!
            'opts': 'String', # String!
            # usage numbers in bytes
            'total': 'Int', # Int!
            'usage': 'Int', # Int!
        },

        # disk status
        'HypervisorDiskStatus': {
            # arrays detected
            'arrays': 'HypervisorDiskArrayStatus', # [HypervisorDiskArrayStatus!]!
            # drives detected
            'drives': 'HypervisorDiskDriveStatus', # [HypervisorDiskDriveStatus!]!
            # partitions detected
            'partitions': 'HypervisorDiskPartitionStatus', # [HypervisorDiskPartitionStatus!]!
            # number of physical trays
            'trays': 'Int', # Int!
        },

        'HypervisorInterfaceEtherCATStatus': {
            'master': 'Int', # Int
            'supported': 'Boolean', # Boolean!
        },

        'HypervisorInterfaceEthernetSettings': {
            'duplex': 'String', # String!
            'speed': 'Int', # Int!
        },

        'HypervisorInterfaceEthernetStatus': {
            'autoneg': 'Boolean', # Boolean!
            'duplex': 'String', # String!
            'link_detected': 'Boolean', # Boolean!
            'speed': 'Int', # Int!
        },

        'HypervisorInterfaceRoute': {
            'destination': 'String', # String!
            'src': 'String', # String!
            'via': 'String', # String!
        },

        'HypervisorInterfaceSettings': {
            'address': 'String', # String
            'addresses': 'String', # [String!]
            'ethernet': 'HypervisorInterfaceEthernetSettings', # HypervisorInterfaceEthernetSettings
            'gateway': 'String', # String
            'label': 'String', # String!
            'mode': 'String', # String!
            'nameservers': 'String', # [String!]
            'netmask': 'String', # String
            'routes': 'HypervisorInterfaceRoute', # [HypervisorInterfaceRoute!]
            'wireless': 'HypervisorInterfaceWirelessSettings', # HypervisorInterfaceWirelessSettings
            'wolmac': 'String', # String
        },

        'HypervisorInterfaceStats': {
            'rx': 'HypervisorInterfaceTXRXStats', # HypervisorInterfaceTXRXStats!
            'tx': 'HypervisorInterfaceTXRXStats', # HypervisorInterfaceTXRXStats!
        },

        'HypervisorInterfaceStatus': {
            'address': 'String', # String!
            'addresses': 'String', # [String!]!
            'connected': 'Boolean', # Boolean!
            # dev name of interface, for example "dir-eth0"
            'dev': 'String', # String!
            'domain': 'String', # String!
            # driver name of interface, for example "e1000e"
            'driver': 'String', # String!
            'ethercat': 'HypervisorInterfaceEtherCATStatus', # HypervisorInterfaceEtherCATStatus
            'ethernet': 'HypervisorInterfaceEthernetStatus', # HypervisorInterfaceEthernetStatus
            'gateway': 'String', # String!
            # label of interface, for example "LAN1"
            'label': 'String', # String!
            'mac': 'String', # String!
            'mtu': 'Int', # Int!
            # name of interface, for example "eth0"
            'name': 'String', # String!
            'nameservers': 'String', # [String!]!
            'netmask': 'String', # String!
            # namespace of the interface
            'netns': 'String', # String!
            # device path, for example ["pci0000:00", "0000:00:13.3", "0000:04:00.0"]
            'path': 'String', # [String!]!
            'product': 'Int', # Int!
            'routes': 'HypervisorInterfaceRoute', # [HypervisorInterfaceRoute!]!
            'search': 'String', # [String!]!
            # settings of interface
            'settings': 'HypervisorInterfaceSettings', # HypervisorInterfaceSettings
            # stats of interface
            'stats': 'HypervisorInterfaceStats', # HypervisorInterfaceStats
            # type of interface, for example "ethernet" or "wireless"
            'type': 'String', # String!
            'up': 'Boolean', # Boolean!
            # vendor and product
            'vendor': 'Int', # Int!
            'wireless': 'HypervisorInterfaceWirelessStatus', # HypervisorInterfaceWirelessStatus
        },

        'HypervisorInterfaceTXRXStats': {
            'bytes': 'Int', # Int!
            'errors': 'Int', # Int!
            'packets': 'Int', # Int!
        },

        'HypervisorInterfaceWirelessScanResult': {
            'bssid': 'String', # String!
            'flags': 'String', # [String!]!
            'frequency': 'Int', # Int!
            'rssi': 'Int', # Int!
            'ssid': 'String', # String!
        },

        'HypervisorInterfaceWirelessSettings': {
            'psk': 'String', # String!
            'ssid': 'String', # String!
        },

        'HypervisorInterfaceWirelessStatus': {
            'bssid': 'String', # String!
            'frequency': 'Int', # Int!
            'group_cipher': 'String', # String!
            'key_management': 'String', # String!
            'mode': 'String', # String!
            'pairwise_cipher': 'String', # String!
            'rssi': 'Int', # Int!
            'scanning': 'HypervisorInterfaceWirelessScanResult', # [HypervisorInterfaceWirelessScanResult!]!
            'speed': 'Int', # Int!
            'ssid': 'String', # String!
            'state': 'String', # String!
        },

        'HypervisorKernelStatus': {
            'rt': 'Boolean', # Boolean!
            'version': 'Int', # Int!
            'warnings': 'HypervisorKernelWarning', # [HypervisorKernelWarning!]!
        },

        'HypervisorKernelWarning': {
            'message': 'String', # String!
            'timestamp': 'Float', # Float!
            'type': 'String', # String!
        },

        'HypervisorMemoryStatus': {
            # number of bytes available in physical memory
            'available': 'Int', # Int!
            # number of bytes in total physical memory
            'total': 'Int', # Int!
            # usage percentage
            'usage': 'Float', # Float!
        },

        'HypervisorNTPSource': {
            'mode': 'String', # String!
            'source': 'String', # String!
            'status': 'String', # String!
            'stratum': 'Int', # Int!
        },

        'HypervisorNTPStatus': {
            'drift': 'Float', # Float!
            'sources': 'HypervisorNTPSource', # [HypervisorNTPSource!]!
            'stratum': 'Int', # Int!
            'syncing': 'Boolean', # Boolean!
        },

        # running container status
        'HypervisorRuntimeContainerStatus': {
            # when container was created
            'createdAt': 'DateTime', # DateTime!
            # id of the container
            'id': 'String', # String!
            # image id
            'imageId': 'String', # String!
            # ip of container
            'ip': 'String', # String!
            # status of containe
            'status': 'String', # String!
        },

        # information about runtime image
        'HypervisorRuntimeImageStatus': {
            # when image was created
            'createdAt': 'DateTime', # DateTime!
            # image id
            'id': 'String', # String!
            # labels set on image
            'labels': 'Any', # Any!
            # size of image on disk
            'size': 'Int', # Int!
        },

        # status gotten from runtime container and images
        'HypervisorRuntimeStatus': {
            # whether there is any uncommitted changes to current running container
            'changes': 'Boolean', # Boolean!
            # running container status
            'container': 'HypervisorRuntimeContainerStatus', # HypervisorRuntimeContainerStatus
            # information about runtime image
            'images': 'HypervisorRuntimeImageStatus', # [HypervisorRuntimeImageStatus!]!
        },

        # Hypervisor status
        'HypervisorStatus': {
            # capabilities of this hypervisor implementation
            'capabilities': 'String', # [String!]!
            # detected clock drifts
            'clockdrifts': 'HypervisorClockDrift', # [HypervisorClockDrift!]!
            # cpu status
            'cpu': 'HypervisorCPUStatus', # HypervisorCPUStatus
            # disk status
            'disk': 'HypervisorDiskStatus', # HypervisorDiskStatus
            # hardware model
            'hardware': 'String', # String!
            # controller id, for example "controller123"
            'id': 'String', # String!
            # network interface status, key by name of interface
            'interfaces': 'HypervisorInterfaceStatus', # [HypervisorInterfaceStatus!]!
            # kernel status
            'kernel': 'HypervisorKernelStatus', # HypervisorKernelStatus
            # memory status
            'memory': 'HypervisorMemoryStatus', # HypervisorMemoryStatus
            # monotonic time
            'monotonic': 'Float', # Float!
            # current time
            'now': 'DateTime', # DateTime!
            # ntp status
            'ntp': 'HypervisorNTPStatus', # HypervisorNTPStatus
            # product id
            'product': 'String', # String!
            # Runtime container and images status.
            'runtime': 'HypervisorRuntimeStatus', # HypervisorRuntimeStatus
            # unix timestamp
            'timestamp': 'Float', # Float!
            # current timezone
            'timezone': 'String', # String!
            # upgrade status
            'upgrade': 'HypervisorUpgradeStatus', # HypervisorUpgradeStatus
            # version of provisioning, read from /version file
            'version': 'String', # String!
            # vpn connection status
            'vpn': 'HypervisorVPNStatus', # HypervisorVPNStatus
        },

        'HypervisorUpgradeStatus': {
            'error': 'String', # String!
            'isRunning': 'Boolean', # Boolean!
            'progress': 'Float', # Float
            'rebootPendingSince': 'Float', # Float!
            'status': 'String', # String!
        },

        'HypervisorVPNStatus': {
            'gateway': 'String', # [String!]!
            'ipsec': 'String', # String!
            'status': 'String', # String!
        },

        # Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
        'IKParameterization': {
            'angle': 'Float', # Float
            # A named parameter holding an array of float values
            'customData': 'FloatsParameter', # [FloatsParameter!]
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # A direction vector (e.g. for approach or depart motions)
            'direction': 'Float', # [Float!]
            # The ID of the IKParam. Unique within a body.
            'id': 'String', # String!
            # A translation the local coordinate system (transformed by this Transform)
            'localTranslate': 'Float', # [Float!]
            # The name of the IKParam. Unique within a body.
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            'quaternion': 'Float', # [Float!]
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            'transform': 'Float', # [Float!]
            # A translation in the global coordinate system
            'translate': 'Float', # [Float!]
            # One of: Transform6D, Rotation3D, Translation3D, Direction3D, Ray4D, Lookat3D, TranslationDirection5D, TranslationXY2D, TranslationXYOrientation3D, TranslationLocalGlobal6D, TranslationXAxisAngle4D, TranslationYAxisAngle4D, TranslationZAxisAngle4D, TranslationXAxisAngleZNorm4D, TranslationYAxisAngleXNorm4D, TranslationZAxisAngleYNorm4D.
            'type': 'String', # String
        },

        # Inverse Kinematics Parameterization describes a pose in space. Includes additional parameters that can affect grasping (e.g. Direction, Angle).
        'IKParameterizationInput': {
            'angle': 'Float', # Float
            # A named parameter holding an array of float values
            'customData': 'FloatsParameterInput', # [FloatsParameterInput!]
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # A direction vector (e.g. for approach or depart motions)
            'direction': 'Float', # [Float!]
            # The ID of the IKParam. Unique within a body.
            'id': 'String', # String
            # A translation the local coordinate system (transformed by this Transform)
            'localTranslate': 'Float', # [Float!]
            # The name of the IKParam. Unique within a body.
            'name': 'String', # String
            'quaternion': 'Float', # [Float!]
            'transform': 'Float', # [Float!]
            # A translation in the global coordinate system
            'translate': 'Float', # [Float!]
            # One of: Transform6D, Rotation3D, Translation3D, Direction3D, Ray4D, Lookat3D, TranslationDirection5D, TranslationXY2D, TranslationXYOrientation3D, TranslationLocalGlobal6D, TranslationXAxisAngle4D, TranslationYAxisAngle4D, TranslationZAxisAngle4D, TranslationXAxisAngleZNorm4D, TranslationYAxisAngleXNorm4D, TranslationZAxisAngleYNorm4D.
            'type': 'String', # String
        },

        # Pair of IO Name and value to be satisfied
        'IONameValueDefinition': {
            # Name of IO signal
            'ioName': 'String', # String
            # Value of IO signal to be satisfied
            'ioValue': 'Int', # Int
        },

        # Pair of IO Name and value to be satisfied
        'IONameValueDefinitionInput': {
            # Name of IO signal
            'ioName': 'String', # String
            # Value of IO signal to be satisfied
            'ioValue': 'Int', # Int
        },

        # Describes the ITL program execution requirements
        'ITLExecutionInfo': {
            # If True, then delays setting needContainer flag for the dest con.
            'delayNeedPlaceContainerAfterITL': 'Boolean', # Boolean
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The event type to trigger the ITL
            'eventType': 'String', # String
            # If True, after ITL program has finished executing, will check the final robot robot values with where the robot started, and if not the same, will move the robot there before completing ITL execution.
            'finishAtStartAfterITL': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Names of ITL programs to run after final trajectory
            'itlProgramNames': 'String', # [String]
            # If True, then ITL needs the ITL program needs to use the pick container, so pick container should not be moved out.
            'needPickContainer': 'Boolean', # Boolean
            # If True, then ITL needs the ITL program needs to use the place container, so place container should not be moved out.
            'needPlaceContainer': 'Boolean', # Boolean
            # If True, then pickworker system will leave the placed target in the environment for the ITL program to manipulate it.
            'needPlacedTarget': 'Boolean', # Boolean
        },

        # Describes the ITL program execution requirements
        'ITLExecutionInfoInput': {
            # If True, then delays setting needContainer flag for the dest con.
            'delayNeedPlaceContainerAfterITL': 'Boolean', # Boolean
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The event type to trigger the ITL
            'eventType': 'String', # String
            # If True, after ITL program has finished executing, will check the final robot robot values with where the robot started, and if not the same, will move the robot there before completing ITL execution.
            'finishAtStartAfterITL': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Names of ITL programs to run after final trajectory
            'itlProgramNames': 'String', # [String]
            # If True, then ITL needs the ITL program needs to use the pick container, so pick container should not be moved out.
            'needPickContainer': 'Boolean', # Boolean
            # If True, then ITL needs the ITL program needs to use the place container, so place container should not be moved out.
            'needPlaceContainer': 'Boolean', # Boolean
            # If True, then pickworker system will leave the placed target in the environment for the ITL program to manipulate it.
            'needPlacedTarget': 'Boolean', # Boolean
        },

        # Specifies how to check condition of detected targets at the beginning of cycle. Number of detected targets and scanned barcode on detection time can be checked.
        'InitialDetectionValidationInfo': {
            # If not empty, checks if barcodes on detected targets matches with expected barcodes
            'checkExpectedBarcodes': 'String', # [String]
            # If true, checks if number of detected targets matches with order number
            'checkNumTargetsMatchesOrder': 'Boolean', # Boolean
            # Timeout[sec] for initial detection validation. If the validation failed and another detection comes before timeout, it validates again.
            'timeout': 'Float', # Float
            # Set to true to enable initial detection validation.
            'use': 'Boolean', # Boolean
        },

        # Specifies how to check condition of detected targets at the beginning of cycle. Number of detected targets and scanned barcode on detection time can be checked.
        'InitialDetectionValidationInfoInput': {
            # If not empty, checks if barcodes on detected targets matches with expected barcodes
            'checkExpectedBarcodes': 'String', # [String]
            # If true, checks if number of detected targets matches with order number
            'checkNumTargetsMatchesOrder': 'Boolean', # Boolean
            # Timeout[sec] for initial detection validation. If the validation failed and another detection comes before timeout, it validates again.
            'timeout': 'Float', # Float
            # Set to true to enable initial detection validation.
            'use': 'Boolean', # Boolean
        },

        # Properties about drop off location
        'InspectionFailDropOffInfo': {
            # mm (x,y,z), only being used when useDropOffAfterTorqueLimits. when robot will depart this offset before robot transfers target to drop off
            'departOffsetAfterTorqueLimits': 'Float', # [Float]
            # Coordinate system type of the destination. can be one of:
            # - 'targetAnyBottomFaceAlignedX' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the X axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceXIsLongAxis' specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the longest side of the target with the X-axis of the goal. Will align so that the target X axis is always toward the X of the ikparam. Use 'facePlaceEdge' to control which corner to align the box with.
            'destcoordtype': 'String', # String
            # Name of the destination ikparameter
            'destname': 'String', # String
            # mm (x,y,z)
            'dropDepartOffset': 'Float', # [Float]
            # The drop off location name
            'dropOffLocationName': 'String', # String
            # A vector of [-1,0,1] of where to place the box when destcoordtype is one of targetAnyBottomFace types. By default this is (0,0,-1) the bottom center.
            'facePlaceEdge': 'Float', # [Float]
            # Is dropped off IO name
            'isDroppedOffIOName': 'String', # String
            # Set to true to enable drop off location.
            'use': 'Boolean', # Boolean
            # If true, robot will try to bring target to drop off location
            'useDropOffAfterTorqueLimits': 'Boolean', # Boolean
        },

        # Properties about drop off location
        'InspectionFailDropOffInfoInput': {
            # mm (x,y,z), only being used when useDropOffAfterTorqueLimits. when robot will depart this offset before robot transfers target to drop off
            'departOffsetAfterTorqueLimits': 'Float', # [Float]
            # Coordinate system type of the destination. can be one of:
            # - 'targetAnyBottomFaceAlignedX' specifying that robot should put the target on its bottom face regardless of which grasp it makes such that the X axis of the object is aligned with X axis of the goal, or
            # - 'targetAnyBottomFaceXIsLongAxis' specifying that robot should put the target on its bottom face regardless of how it is grasped and to align the longest side of the target with the X-axis of the goal. Will align so that the target X axis is always toward the X of the ikparam. Use 'facePlaceEdge' to control which corner to align the box with.
            'destcoordtype': 'String', # String
            # Name of the destination ikparameter
            'destname': 'String', # String
            # mm (x,y,z)
            'dropDepartOffset': 'Float', # [Float]
            # The drop off location name
            'dropOffLocationName': 'String', # String
            # A vector of [-1,0,1] of where to place the box when destcoordtype is one of targetAnyBottomFace types. By default this is (0,0,-1) the bottom center.
            'facePlaceEdge': 'Float', # [Float]
            # Is dropped off IO name
            'isDroppedOffIOName': 'String', # String
            # Set to true to enable drop off location.
            'use': 'Boolean', # Boolean
            # If true, robot will try to bring target to drop off location
            'useDropOffAfterTorqueLimits': 'Boolean', # Boolean
        },

        # Specifies the conditions to run one intermediate cycle. Conditions can be on grasp set or target URI, and intermediate cycle can change the destination the target is placed and then regrabbed from. This allows parts that are not placeable in the original goals to be put somewhere for later processing.
        'IntermediateCycleInfo': {
            # s, delay before execute placement to the final destination. Valid only if "planToDest" is true!
            'delayBeforeExecute': 'Float', # Float
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Names of the intermediate destination ik parameters to which the robot will go and release the part. Should be in the format instobjectname/ikparamname
            'destikparamnames': 'String', # [String]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Parameters to be overwritten for the plan from intermediate destination to the final destination.
            'intermediateCycleOverwrite': 'CycleOverwriteParameters', # CycleOverwriteParameters
            # The position of the part after release, could be different from the position where it was released. Intermediate destination name of the goal where the part will appear after placing to one of the intermediate ik parameters, should be in format: instobjectname/ikparamname.
            'intermediateDestNames': 'String', # [String]
            # if true robot will move to the finish position after intermediate destination. The part placed in the intermediate position will be removed! Valid if "planToDest" is false!
            'moveToFinishPositionAtEnd': 'Boolean', # Boolean
            # if true robot will move to the finish position after intermediate destination. The part placed in the intermediate position will be removed! Valid if "planToDest" is false!
            'onlyOnChangeAllowPlacement': 'Boolean', # Boolean
            # if true the original "destGoals" will be overwritten by "destikparamnames" and robot will always place to the intermediate position before placing to the final destination. Valid if "planToDest" is true!
            'overwriteDest': 'Boolean', # Boolean
            # if true will plan to the original destinations after placing in the intermediate position
            'planToDest': 'Boolean', # Boolean
            # Parameters to be overwritten for for the plan from source container to intermediate position.
            'preCycleOverwrite': 'CycleOverwriteParameters', # CycleOverwriteParameters
            # mm. Adds padding to target object's AABB (axis-aligned bounding box) at the location where the part was placed. This avoids other objects being placed too closely to it. The value is added to the box' extent of each axis, so a value of targetPaddingBuffer=20 adds a padding of 20 mm to each dimension.
            'targetPaddingBuffer': 'Float', # Float
            # Set to true to enable using intermediate dest.
            'use': 'Boolean', # Boolean
            # Valid grasp set name for the goal
            'validGraspSetName': 'String', # String
            # Uri of the target for which use target destination delete info, if empty will use it for all targets.
            'validTargetUri': 'String', # String
        },

        # Specifies the conditions to run one intermediate cycle. Conditions can be on grasp set or target URI, and intermediate cycle can change the destination the target is placed and then regrabbed from. This allows parts that are not placeable in the original goals to be put somewhere for later processing.
        'IntermediateCycleInfoInput': {
            # s, delay before execute placement to the final destination. Valid only if "planToDest" is true!
            'delayBeforeExecute': 'Float', # Float
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Names of the intermediate destination ik parameters to which the robot will go and release the part. Should be in the format instobjectname/ikparamname
            'destikparamnames': 'String', # [String]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Parameters to be overwritten for the plan from intermediate destination to the final destination.
            'intermediateCycleOverwrite': 'CycleOverwriteParametersInput', # CycleOverwriteParametersInput
            # The position of the part after release, could be different from the position where it was released. Intermediate destination name of the goal where the part will appear after placing to one of the intermediate ik parameters, should be in format: instobjectname/ikparamname.
            'intermediateDestNames': 'String', # [String]
            # if true robot will move to the finish position after intermediate destination. The part placed in the intermediate position will be removed! Valid if "planToDest" is false!
            'moveToFinishPositionAtEnd': 'Boolean', # Boolean
            # if true robot will move to the finish position after intermediate destination. The part placed in the intermediate position will be removed! Valid if "planToDest" is false!
            'onlyOnChangeAllowPlacement': 'Boolean', # Boolean
            # if true the original "destGoals" will be overwritten by "destikparamnames" and robot will always place to the intermediate position before placing to the final destination. Valid if "planToDest" is true!
            'overwriteDest': 'Boolean', # Boolean
            # if true will plan to the original destinations after placing in the intermediate position
            'planToDest': 'Boolean', # Boolean
            # Parameters to be overwritten for for the plan from source container to intermediate position.
            'preCycleOverwrite': 'CycleOverwriteParametersInput', # CycleOverwriteParametersInput
            # mm. Adds padding to target object's AABB (axis-aligned bounding box) at the location where the part was placed. This avoids other objects being placed too closely to it. The value is added to the box' extent of each axis, so a value of targetPaddingBuffer=20 adds a padding of 20 mm to each dimension.
            'targetPaddingBuffer': 'Float', # Float
            # Set to true to enable using intermediate dest.
            'use': 'Boolean', # Boolean
            # Valid grasp set name for the goal
            'validGraspSetName': 'String', # String
            # Uri of the target for which use target destination delete info, if empty will use it for all targets.
            'validTargetUri': 'String', # String
        },

        # A named parameter holding an array of integer values
        'IntsParameter': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String!
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            'values': 'Int', # [Int!]
        },

        # A named parameter holding an array of integer values
        'IntsParameterInput': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String
            'values': 'Int', # [Int!]
        },

        # Parameters dealing with jittering the robot out of collisions.
        'JittererParameters': {
            # mm, When jittering, try to bias the tool in a specific direction. For example if (0, 0, 100), then the tool will be bias to move up to 100mm on the z axis
            'jitterBiasDirection': 'Float', # [Float]
            # The minimum distance cached robot configurations can be from their neighbors in the data structure.
            'jitterNeighDistThresh': 'Float', # Float
            # rad or m, When jittering out of obstacles, the max deviation of any joint
            'maxJitter': 'Float', # Float
            # The number of tries for jittering out of collision before giving up.
            'maxJitterIterations': 'Int', # Int
            # mm, When jittering, the max distance any link on the robot can move.
            'maxJitterLinkDist': 'Float', # Float
            # Set to true to switch to using WorkspaceConfigurationJitterer, which computes jittered robot configurations by perturbing the tool position instead of joint values.
            'useWorkspaceJitterer': 'Boolean', # Boolean
        },

        # Parameters dealing with jittering the robot out of collisions.
        'JittererParametersInput': {
            # mm, When jittering, try to bias the tool in a specific direction. For example if (0, 0, 100), then the tool will be bias to move up to 100mm on the z axis
            'jitterBiasDirection': 'Float', # [Float]
            # The minimum distance cached robot configurations can be from their neighbors in the data structure.
            'jitterNeighDistThresh': 'Float', # Float
            # rad or m, When jittering out of obstacles, the max deviation of any joint
            'maxJitter': 'Float', # Float
            # The number of tries for jittering out of collision before giving up.
            'maxJitterIterations': 'Int', # Int
            # mm, When jittering, the max distance any link on the robot can move.
            'maxJitterLinkDist': 'Float', # Float
            # Set to true to switch to using WorkspaceConfigurationJitterer, which computes jittered robot configurations by perturbing the tool position instead of joint values.
            'useWorkspaceJitterer': 'Boolean', # Boolean
        },

        # Joint in a body, which connects a parent link and a child link. Can have multiple degrees of freedom.
        'Joint': {
            # The anchors of the joint. Axes and anchors are relative to the parent link.
            'anchors': 'Float', # [Float!]
            # The axes of the joint. Axes and anchors are relative to the parent link
            'axes': 'Float', # [[Float!]!]
            # The child link of the joint
            'childLinkName': 'String', # String
            # The name of JointControlInfo to use. Can be "None", "RobotController", "IO", "ExternalDevice".
            'controlMode': 'String', # String
            'currentValues': 'Float', # [Float!]
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # Description of a joint's electric actuator.
            'electricMotorActuator': 'ElectricMotorActuator', # ElectricMotorActuator
            # A named parameter holding an array of float values
            'floatParameters': 'FloatsParameter', # [FloatsParameter!]
            'hardMaxAccel': 'Float', # [Float!]
            'hardMaxJerk': 'Float', # [Float!]
            'hardMaxVel': 'Float', # [Float!]
            # The ID of the joint. Unique within a body.
            'id': 'String', # String!
            # A named parameter holding an array of integer values
            'intParameters': 'IntsParameter', # [IntsParameter!]
            'isActive': 'Boolean', # Boolean
            # True if a joint axis has an identification at its lower and upper limits. An identification of the lower and upper limits means that once the joint reaches its upper limit, it is also at its lower limit. The most common identification on revolute joints is at -pi and pi. 'circularity' means that the joint does not stop at the limits.
            'isCircular': 'Int', # [Int!]
            # JointControlInfo for ExternalDevice.
            'jointControlInfoExternalDevice': 'JointControlInfoExternalDevice', # JointControlInfoExternalDevice
            # JointControlInfo for IO.
            'jointControlInfoIO': 'JointControlInfoIO', # JointControlInfoIO
            # JointControlInfo for RobotController.
            'jointControlInfoRobotController': 'JointControlInfoRobotController', # JointControlInfoRobotController
            # The lower limits for the joint's position values
            'lowerLimit': 'Float', # [Float!]
            # Maximum acceleration values
            'maxAccel': 'Float', # [Float!]
            'maxInertia': 'Float', # [Float!]
            # Maximum jerk values (the derivative of the acceleration)
            'maxJerk': 'Float', # [Float!]
            # Maximum torque values
            'maxTorque': 'Float', # [Float!]
            # Maximum velocity values of determined size
            'maxVel': 'Float', # [Float!]
            # Equations for mimic joints, which move depending on this joint.
            'mimics': 'Mimic', # [Mimic!]
            # The name of the joint. Unique within a body.
            'name': 'String', # String
            # Internal wrap offset parameter for revolute joints. Wrap offsets are needed for rotation joints since the range is limited to 2*pi. The offset allows the joint to function in the range [-pi+offset,pi+offset].
            'offsets': 'Float', # [Float!]
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # The parent link of the joint
            'parentLinkName': 'String', # String
            # The discretization of the joint used when line-collision checking. The resolutions should be set as large as possible such that the joint will not go through obstacles.
            'resolutions': 'Float', # [Float!]
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # A named parameter holding a single string value
            'stringParameters': 'StringParameter', # [StringParameter!]
            # Can be "revolute" or "prismatic"
            'type': 'String', # String
            # The upper limits for the joint's position values
            'upperLimit': 'Float', # [Float!]
            # The weight of each joint for computing distance metrics
            'weights': 'Float', # [Float!]
        },

        # Describes the state (position) of a single joint.
        # 
        # This is a name-value tuple so that joint values can be sent for a subset of a kinematic chain without ambiguity.
        'JointConfigurationState': {
            # If this is not empty, this joint is part of a connected body.
            'connectedBodyName': 'String', # String!
            # If a joint configuration is part of a connected body (i.e. ConnectedBodyName is not empty), JointName is not prefixed with the ConnectedBodyName. Instead, it is the pure joint name.
            'jointName': 'String', # String!
            'jointValue': 'Float', # Float!
        },

        # Describes the state (position) of a single joint.
        # 
        # This is a name-value tuple so that joint values can be sent for a subset of a kinematic chain without ambiguity.
        'JointConfigurationStateInput': {
            # If this is not empty, this joint is part of a connected body.
            'connectedBodyName': 'String', # String!
            # If a joint configuration is part of a connected body (i.e. ConnectedBodyName is not empty), JointName is not prefixed with the ConnectedBodyName. Instead, it is the pure joint name.
            'jointName': 'String', # String!
            'jointValue': 'Float', # Float!
        },

        # Info of a joint to be controlled by an external device.
        'JointControlInfoExternalDevice': {
            # The device type for the external device.
            'externalDeviceType': 'String', # String
        },

        # Info of a joint to be controlled by an external device.
        'JointControlInfoExternalDeviceInput': {
            # The device type for the external device.
            'externalDeviceType': 'String', # String
        },

        # Info of a joint to be controlled by IO.
        'JointControlInfoIO': {
            # The type of device this joint is for.
            'deviceType': 'String', # String
            # IO names for detecting if the joint is at its lower limit.
            'lowerLimitIONames': 'String', # [[String!]!]
            # If true, the corresponding lower limit sensor reads 1 when the joint is at its lower limit. otherwise, the lower limit sensor reads 0 when the joint is at its upper limit. the default value is 1.
            'lowerLimitSensorIsOn': 'Any', # [[Any!]!]
            # IO names for controlling positions of this joint.
            'moveIONames': 'String', # [[String!]!]
            # IO names for detecting if the joint is at its upper limit
            'upperLimitIONames': 'String', # [[String!]!]
            # If true, the corresponding upper limit sensor reads 1 when the joint is at its upper limit. otherwise, the upper limit sensor reads 0 when the joint is at its upper limit. the default value is 1.
            'upperLimitSensorIsOn': 'Any', # [[Any!]!]
        },

        # Info of a joint to be controlled by IO.
        'JointControlInfoIOInput': {
            # The type of device this joint is for.
            'deviceType': 'String', # String
            # IO names for detecting if the joint is at its lower limit.
            'lowerLimitIONames': 'String', # [[String!]!]
            # If true, the corresponding lower limit sensor reads 1 when the joint is at its lower limit. otherwise, the lower limit sensor reads 0 when the joint is at its upper limit. the default value is 1.
            'lowerLimitSensorIsOn': 'Any', # [[Any!]!]
            # IO names for controlling positions of this joint.
            'moveIONames': 'String', # [[String!]!]
            # IO names for detecting if the joint is at its upper limit
            'upperLimitIONames': 'String', # [[String!]!]
            # If true, the corresponding upper limit sensor reads 1 when the joint is at its upper limit. otherwise, the upper limit sensor reads 0 when the joint is at its upper limit. the default value is 1.
            'upperLimitSensorIsOn': 'Any', # [[Any!]!]
        },

        # Info of a joint to be controlled by a robot controller.
        'JointControlInfoRobotController': {
            # The type of the controller used to control this joint.
            'controllerType': 'String', # String
            # Indicates which DOF in the robot controller controls which joint axis (up to the DOF of the joint). -1 if not specified/not valid.
            'robotControllerAxisIndex': 'Int', # [Int!]
        },

        # Info of a joint to be controlled by a robot controller.
        'JointControlInfoRobotControllerInput': {
            # The type of the controller used to control this joint.
            'controllerType': 'String', # String
            # Indicates which DOF in the robot controller controls which joint axis (up to the DOF of the joint). -1 if not specified/not valid.
            'robotControllerAxisIndex': 'Int', # [Int!]
        },

        # Joint in a body, which connects a parent link and a child link. Can have multiple degrees of freedom.
        'JointInput': {
            # The anchors of the joint. Axes and anchors are relative to the parent link.
            'anchors': 'Float', # [Float!]
            # The axes of the joint. Axes and anchors are relative to the parent link
            'axes': 'Float', # [[Float!]!]
            # The child link of the joint
            'childLinkName': 'String', # String
            # The name of JointControlInfo to use. Can be "None", "RobotController", "IO", "ExternalDevice".
            'controlMode': 'String', # String
            'currentValues': 'Float', # [Float!]
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # Description of a joint's electric actuator.
            'electricMotorActuator': 'ElectricMotorActuatorInput', # ElectricMotorActuatorInput
            # A named parameter holding an array of float values
            'floatParameters': 'FloatsParameterInput', # [FloatsParameterInput!]
            'hardMaxAccel': 'Float', # [Float!]
            'hardMaxJerk': 'Float', # [Float!]
            'hardMaxVel': 'Float', # [Float!]
            # The ID of the joint. Unique within a body.
            'id': 'String', # String
            # A named parameter holding an array of integer values
            'intParameters': 'IntsParameterInput', # [IntsParameterInput!]
            'isActive': 'Boolean', # Boolean
            # True if a joint axis has an identification at its lower and upper limits. An identification of the lower and upper limits means that once the joint reaches its upper limit, it is also at its lower limit. The most common identification on revolute joints is at -pi and pi. 'circularity' means that the joint does not stop at the limits.
            'isCircular': 'Int', # [Int!]
            # JointControlInfo for ExternalDevice.
            'jointControlInfoExternalDevice': 'JointControlInfoExternalDeviceInput', # JointControlInfoExternalDeviceInput
            # JointControlInfo for IO.
            'jointControlInfoIO': 'JointControlInfoIOInput', # JointControlInfoIOInput
            # JointControlInfo for RobotController.
            'jointControlInfoRobotController': 'JointControlInfoRobotControllerInput', # JointControlInfoRobotControllerInput
            # The lower limits for the joint's position values
            'lowerLimit': 'Float', # [Float!]
            # Maximum acceleration values
            'maxAccel': 'Float', # [Float!]
            'maxInertia': 'Float', # [Float!]
            # Maximum jerk values (the derivative of the acceleration)
            'maxJerk': 'Float', # [Float!]
            # Maximum torque values
            'maxTorque': 'Float', # [Float!]
            # Maximum velocity values of determined size
            'maxVel': 'Float', # [Float!]
            # Equations for mimic joints, which move depending on this joint.
            'mimics': 'MimicInput', # [MimicInput!]
            # The name of the joint. Unique within a body.
            'name': 'String', # String
            # Internal wrap offset parameter for revolute joints. Wrap offsets are needed for rotation joints since the range is limited to 2*pi. The offset allows the joint to function in the range [-pi+offset,pi+offset].
            'offsets': 'Float', # [Float!]
            # The parent link of the joint
            'parentLinkName': 'String', # String
            # The discretization of the joint used when line-collision checking. The resolutions should be set as large as possible such that the joint will not go through obstacles.
            'resolutions': 'Float', # [Float!]
            # A named parameter holding a single string value
            'stringParameters': 'StringParameterInput', # [StringParameterInput!]
            # Can be "revolute" or "prismatic"
            'type': 'String', # String
            # The upper limits for the joint's position values
            'upperLimit': 'Float', # [Float!]
            # The weight of each joint for computing distance metrics
            'weights': 'Float', # [Float!]
        },

        # Parameters for configuring just-in-time tool change planning feature
        'JustInTimeToolChangePlanningParameters': {
            # Set to true to always use the first tool listed in 'toolNames' on start cycle
            'forceUseFirstToolOnStart': 'Boolean', # Boolean
            # ITL program to use for tool changing
            'programName': 'String', # String
            # Names of tools that can be used for tool changing
            'toolNames': 'String', # [String]
            # Set to true to enable tool changing
            'use': 'Boolean', # Boolean
        },

        # Parameters for configuring just-in-time tool change planning feature
        'JustInTimeToolChangePlanningParametersInput': {
            # Set to true to always use the first tool listed in 'toolNames' on start cycle
            'forceUseFirstToolOnStart': 'Boolean', # Boolean
            # ITL program to use for tool changing
            'programName': 'String', # String
            # Names of tools that can be used for tool changing
            'toolNames': 'String', # [String]
            # Set to true to enable tool changing
            'use': 'Boolean', # Boolean
        },

        # Describes the label printer and how the robot computes the label placing motion.
        'LabelPlacingInfo': {
            # mm (x,y,z)
            'approachOffsetDir': 'Float', # [Float]
            # mm (x,y,z)
            'departOffsetDir': 'Float', # [Float]
            # The name of the IO to use to trigger the label ejector.
            'isAtPrinterLocationIO': 'String', # String
            # IK parameter where a label is placed to a target.
            'labelEjectionIkParamName': 'String', # String
            # The name of the IO to specify the content of the label.
            'labelForPartIO': 'String', # String
            # **bottomFlat**
            'labelPositionGeneration': 'String', # String
            # mm (x,y,z)
            'labelSizeXY': 'Float', # [Float]
            # sec, The amount of time for the robot to stop after ejecting a label on a target.
            'pauseTimeAtPrinterLocation': 'Float', # Float
            # The name of the IO to use to trigger the label printer.
            'printTriggerIO': 'String', # String
            # Set to true to enable label placing.
            'use': 'Boolean', # Boolean
        },

        # Describes the label printer and how the robot computes the label placing motion.
        'LabelPlacingInfoInput': {
            # mm (x,y,z)
            'approachOffsetDir': 'Float', # [Float]
            # mm (x,y,z)
            'departOffsetDir': 'Float', # [Float]
            # The name of the IO to use to trigger the label ejector.
            'isAtPrinterLocationIO': 'String', # String
            # IK parameter where a label is placed to a target.
            'labelEjectionIkParamName': 'String', # String
            # The name of the IO to specify the content of the label.
            'labelForPartIO': 'String', # String
            # **bottomFlat**
            'labelPositionGeneration': 'String', # String
            # mm (x,y,z)
            'labelSizeXY': 'Float', # [Float]
            # sec, The amount of time for the robot to stop after ejecting a label on a target.
            'pauseTimeAtPrinterLocation': 'Float', # Float
            # The name of the IO to use to trigger the label printer.
            'printTriggerIO': 'String', # String
            # Set to true to enable label placing.
            'use': 'Boolean', # Boolean
        },

        # Link of a body, containing geometries. Links can be connected by joints.
        'Link': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # A named parameter holding an array of float values
            'floatParameters': 'FloatsParameter', # [FloatsParameter!]
            # Links which will be considered "adjacent". Collisions between adjacent links are ignored.
            'forcedAdjacentLinks': 'String', # [String!]
            # List of geometries in this link. Defined in the link's coordinate system.
            'geometries': 'Geometry', # [Geometry!]
            # The ID of the link. Unique within a body.
            'id': 'String', # String!
            # The moments of inertia around each rotation axis
            'inertiaMoments': 'Float', # [Float!]
            # A named parameter holding an array of integer values
            'intParameters': 'IntsParameter', # [IntsParameter!]
            # Whether collision is enabled for this link.
            'isEnabled': 'Boolean', # Boolean
            # Whether the link is static and cannot move depending on dof values.
            'isStatic': 'Boolean', # Boolean
            # The mass of the link, in kg.
            'mass': 'Float', # Float
            # The frame for inertia and center of mass of the link, in the link's coordinate system.
            'massTransform': 'Float', # [Float!]
            # The name of the link. Unique within a body.
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Relative transform to parent link. Not saved in file, only used by API to update multiple link transforms through relative transform.
            'relativeTransform': 'Float', # [Float!]
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # A named parameter holding a single string value
            'stringParameters': 'StringParameter', # [StringParameter!]
            # The link transform is relative to the body's coordinate system. Same convention as in OpenRAVE. For child links, the transform depends on the joint values and the parent link. A link that has only children and no parents is the body's "base link".
            'transform': 'Float', # [Float!]
            # Summarized visibility state for all geometries in the link. One of "visible", "invisible", "partial", "inapplicable". Not saved in file, only used by API to set all geometries visibility at once. Cannot be set to "partial" or "inapplicable".
            'visibilityState': 'String', # String
        },

        # Link of a body, containing geometries. Links can be connected by joints.
        'LinkInput': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # A named parameter holding an array of float values
            'floatParameters': 'FloatsParameterInput', # [FloatsParameterInput!]
            # Links which will be considered "adjacent". Collisions between adjacent links are ignored.
            'forcedAdjacentLinks': 'String', # [String!]
            # List of geometries in this link. Defined in the link's coordinate system.
            'geometries': 'GeometryInput', # [GeometryInput!]
            # The ID of the link. Unique within a body.
            'id': 'String', # String
            # The moments of inertia around each rotation axis
            'inertiaMoments': 'Float', # [Float!]
            # A named parameter holding an array of integer values
            'intParameters': 'IntsParameterInput', # [IntsParameterInput!]
            # Whether collision is enabled for this link.
            'isEnabled': 'Boolean', # Boolean
            # Whether the link is static and cannot move depending on dof values.
            'isStatic': 'Boolean', # Boolean
            # The mass of the link, in kg.
            'mass': 'Float', # Float
            # The frame for inertia and center of mass of the link, in the link's coordinate system.
            'massTransform': 'Float', # [Float!]
            # The name of the link. Unique within a body.
            'name': 'String', # String
            # Relative transform to parent link. Not saved in file, only used by API to update multiple link transforms through relative transform.
            'relativeTransform': 'Float', # [Float!]
            # A named parameter holding a single string value
            'stringParameters': 'StringParameterInput', # [StringParameterInput!]
            # The link transform is relative to the body's coordinate system. Same convention as in OpenRAVE. For child links, the transform depends on the joint values and the parent link. A link that has only children and no parents is the body's "base link".
            'transform': 'Float', # [Float!]
            # Summarized visibility state for all geometries in the link. One of "visible", "invisible", "partial", "inapplicable". Not saved in file, only used by API to set all geometries visibility at once. Cannot be set to "partial" or "inapplicable".
            'visibilityState': 'String', # String
        },

        'ListApplicationsReturnValue': {
            # A list of applications.
            'applications': 'Application', # [Application!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListAttachedSensorsReturnValue': {
            # A list of attached sensors.
            'attachedSensors': 'AttachedSensor', # [AttachedSensor!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListBodiesReturnValue': {
            # A list of bodies.
            'bodies': 'Body', # [Body!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListConfigurationsReturnValue': {
            # A list of configurations.
            'configurations': 'Configuration', # [Configuration!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListConnectedBodiesReturnValue': {
            # A list of connected bodies.
            'connectedBodies': 'ConnectedBody', # [ConnectedBody!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListEnvironmentsReturnValue': {
            # A list of environments.
            'environments': 'Environment', # [Environment!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListGeometriesReturnValue': {
            # A list of geometries.
            'geometries': 'Geometry', # [Geometry!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListGrabbedsReturnValue': {
            # A list of grabbed.
            'grabbeds': 'Grabbed', # [Grabbed!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListGraspSetsReturnValue': {
            # A list of grasp sets.
            'graspSets': 'GraspSet', # [GraspSet!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListGripperInfosReturnValue': {
            # A list of gripper infos.
            'gripperInfos': 'GripperInfo', # [GripperInfo!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListIKParameterizationsReturnValue': {
            # A list of ikparams.
            'ikParams': 'IKParameterization', # [IKParameterization!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListJointsReturnValue': {
            # A list of joints.
            'joints': 'Joint', # [Joint!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        'ListLinksReturnValue': {
            # A list of links.
            'links': 'Link', # [Link!]!
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
        },

        # Meta information returned by the query.
        'ListMeta': {
            # Total number of entries.
            'totalCount': 'Int', # Int!
        },

        # Optional list query parameters, used to filter returned results.
        'ListOptionsInput': {
            # Filters to be applied to the result, such as "field_subField__in=a,b,c".
            'filters': 'String', # [String!]
            # Limit the returned results to first few.
            'first': 'Int', # Int
            # Groupping to be applied to the result, such as ["field_subField", "field2"].
            'groups': 'String', # [String!]
            # Offset the returned results, skip amount specified by offset.
            'offset': 'Int', # Int
            # Ordering to be applied to the result, such as ["-field_subField", "field2"].
            'orders': 'String', # [String!]
        },

        'ListPositionConfigurationsReturnValue': {
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
            # A list of position configurations.
            'positionConfigurations': 'PositionConfiguration', # [PositionConfiguration!]!
        },

        'ListProgramsReturnValue': {
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
            # A list of programs.
            'programs': 'Program', # [Program!]!
        },

        'ListRevisionsReturnValue': {
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
            # A list of revisions.
            'revisions': 'Revision', # [Revision!]!
        },

        'ListToolsReturnValue': {
            # Meta information returned by the query.
            'meta': 'ListMeta', # ListMeta
            # A list of tools.
            'tools': 'Tool', # [Tool!]!
        },

        # Low Priority Type Info
        'LowPriorityTypeInfo': {
            # Parameters to be overwritten for the plan.
            'cycleOverwrite': 'CycleOverwriteParameters', # CycleOverwriteParameters
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # list of dictionaries where each dictionary contains the goal description. A goal contains: ikparamnames or jointvalues, validGraspSetName(optional), name(optional).
            'destGoals': 'BinpickingDestGoal', # [BinpickingDestGoal]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # objectTypes of the target which can be assumed as the low priority type
            'validObjectTypes': 'String', # [String]
            # Uris of the target which can be assumed as the low priority type
            'validTargetUris': 'String', # [String]
        },

        # Low Priority Type Info
        'LowPriorityTypeInfoInput': {
            # Parameters to be overwritten for the plan.
            'cycleOverwrite': 'CycleOverwriteParametersInput', # CycleOverwriteParametersInput
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # list of dictionaries where each dictionary contains the goal description. A goal contains: ikparamnames or jointvalues, validGraspSetName(optional), name(optional).
            'destGoals': 'BinpickingDestGoalInput', # [BinpickingDestGoalInput]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # objectTypes of the target which can be assumed as the low priority type
            'validObjectTypes': 'String', # [String]
            # Uris of the target which can be assumed as the low priority type
            'validTargetUris': 'String', # [String]
        },

        # Configuration of Datalogic Matrixbarcode scanner.
        'MatrixSensorConfiguration': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # List of available Matrix barcode sensors.
            'sensorList': 'Any', # Any
        },

        # Configuration of Datalogic Matrixbarcode scanner.
        'MatrixSensorConfigurationInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # List of available Matrix barcode sensors.
            'sensorList': 'Any', # Any
        },

        # Parameters for generating a connecting trajectory, which is a trajectory segment connecting the current robot values (which may be the result of the robot stopping due to io sensors) with the initial robot values of the next trajectory to be executed.
        'MergeTrajectoryParameters': {
            # Second. The connecting trajectory will be rejected if its duration is greater than this threshold.
            'badTrajTimeThresh': 'Float', # Float
            # Degree. If any of the the current robot joint values are further from the initial robot values of the next trajectory to be executed for more than this threshold, will raise an error.
            'maxJointThresh': 'Float', # Float
            # Degree. If all the current robot joint values are within this threshold from the initial robot values of the next trajectory to be executed, a connecting trajectory is not necessary.
            'minJointThresh': 'Float', # Float
            # A multiplier for when computing joint errors for the fourth and the sixth joints of a 6-degree-of-freedom robot. This multiplier is used in computation when the robot posture is singular.
            'singularityJointMult': 'Float', # Float
            # Degree. When computing a connecting trajectory, if some certain joints have their values be within this threshold, the robot posture is assumed to be singular, which will activate specific computation for singular cases.
            'singularityJointThresh': 'Float', # Float
            # Degree. The connecting trajectory will be rejected if it contains a point whose tool orientation deviates from the current tool orientation for more than this threshold.
            'toolOrientationThresh': 'Float', # Float
            # mm. The connecting trajectory will be rejected if it contains a point whose tool position deviates from the current tool position for more than this threshold.
            'toolTranslationThresh': 'Float', # Float
        },

        # Parameters for generating a connecting trajectory, which is a trajectory segment connecting the current robot values (which may be the result of the robot stopping due to io sensors) with the initial robot values of the next trajectory to be executed.
        'MergeTrajectoryParametersInput': {
            # Second. The connecting trajectory will be rejected if its duration is greater than this threshold.
            'badTrajTimeThresh': 'Float', # Float
            # Degree. If any of the the current robot joint values are further from the initial robot values of the next trajectory to be executed for more than this threshold, will raise an error.
            'maxJointThresh': 'Float', # Float
            # Degree. If all the current robot joint values are within this threshold from the initial robot values of the next trajectory to be executed, a connecting trajectory is not necessary.
            'minJointThresh': 'Float', # Float
            # A multiplier for when computing joint errors for the fourth and the sixth joints of a 6-degree-of-freedom robot. This multiplier is used in computation when the robot posture is singular.
            'singularityJointMult': 'Float', # Float
            # Degree. When computing a connecting trajectory, if some certain joints have their values be within this threshold, the robot posture is assumed to be singular, which will activate specific computation for singular cases.
            'singularityJointThresh': 'Float', # Float
            # Degree. The connecting trajectory will be rejected if it contains a point whose tool orientation deviates from the current tool orientation for more than this threshold.
            'toolOrientationThresh': 'Float', # Float
            # mm. The connecting trajectory will be rejected if it contains a point whose tool position deviates from the current tool position for more than this threshold.
            'toolTranslationThresh': 'Float', # Float
        },

        # triangle mesh
        'Mesh': {
            'indices': 'Int', # [Int!]!
            'vertices': 'Float', # [Float!]!
        },

        # triangle mesh
        'MeshInput': {
            'indices': 'Int', # [Int!]!
            'vertices': 'Float', # [Float!]!
        },

        # Equations for mimic joints, whose motion depends on another joint.
        # 
        # See http://warp.povusers.org/FunctionParser/fparser.html for a full description of the equation format.
        'Mimic': {
            'equations': 'String', # [String!]!
        },

        # Equations for mimic joints, whose motion depends on another joint.
        # 
        # See http://warp.povusers.org/FunctionParser/fparser.html for a full description of the equation format.
        'MimicInput': {
            'equations': 'String', # [String!]!
        },

        # parameters that are used with planning for minimum viable region
        'MinViableRegionPlanParameters': {
            # If ratio between maxPossibleSize and targetSize is smaller than this ratio, allow lift even when registrationMotionMode is 'drag'
            'allowLiftSizeRatio': 'Float', # Float
            # Set to true to immediately replanning of part once it is dropped.
            'canDoReplanWithNewTarget': 'Boolean', # Boolean
            # The name of the IO to stop sensor measuring minimum viable region size.
            'captureCancelIOName': 'String', # String
            # The name of the IO to know if sensor finishes measuring minimum viable region size.
            'captureFinishIOName': 'String', # String
            # The name of the IO to trigger sensor to measure minimum viable region size.
            'captureTriggerIOName': 'String', # String
            # default transfer speed multiplier for lifting up
            'defaultLiftingUpSpeedMult': 'Float', # Float
            # If True, system will raise an error when force / torque exceeding draggingForceTorqueExceedThresholds or draggingForceTorqueExceedThresholdsDelta is detected. If False, robot will try to continue.
            'draggingForceTorqueExceedStop': 'Boolean', # Boolean
            # Threshold for force / torque to detect collision during dragging the grabbed item. unit is N for force, Nm for torque.
            'draggingForceTorqueExceedThresholds': 'Float', # [Float]
            # Threshold for force / torque delta to detect collision during dragging the grabbed item. unit is N for force, Nm for torque.
            'draggingForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # transfer speed multiplier for lifting up size measurement and registration. this should be slow enough to safely lifting up uncertain size objects
            'liftingUpSpeedMultForSizeMeasurement': 'Float', # Float
            # Defines maximum allowed center of mass deviation from geometrical center for registration to be successful. The allowed center of mass range is computed by multiplication of this ratio and size of target.
            'maxAllowedObjectComRatio': 'Float', # Float
            # Maximum sagging angle in degrees for compensating sagging by gripper rotation.
            'maxSaggingAngle': 'Float', # Float
            # Maximum seconds to hold minimum viable region for registration
            'maxSecondsToHold': 'Float', # Float
            # Minimum allowed size change ratio to bring minimum viable region to destination
            'minAllowedObjectSizeRatio': 'Float', # Float
            # Minimum allowed transfer speed mult to bring minimum viable region to destination
            'minAllowedTransferSpeedMult': 'Float', # Float
            # kg, The minimum candidate mass to register
            'minCandidateMass': 'Float', # Float
            # Minimum distance in mm to expose uncertain corner to vision
            'minCornerVisibleDist': 'Float', # Float
            # Minimum distance in mm to expose uncertain corner of octagonal case to vision
            'minCornerVisibleDistForOctagonal': 'Float', # Float
            # The size XYZ in mm to clean obstacles surrounding the newly registered item for re-planning
            'obstacleCleanSizeXYZForReplan': 'Float', # [Float]
            # Allowed penetration distance in mm for robot to go inside of an area that should not be occluded
            'occlusionPenetration': 'Float', # Float
            # The distance in mm to lower obstacles surrounding the newly registered item for re-planning
            'overlappingObstacleLoweringDistanceForReplan': 'Float', # Float
            # Speed multiplier for placing a grabbed target back.
            'placeBackSpeedMult': 'Float', # Float
            # If True, system will raise an error when force / torque exceeding putBackSafetyForceTorqueExceedThresholds or putBackSafetyForceTorqueExceedThresholdsDelta is detected. If False, robot will try to continue.
            'putBackSafetyForceTorqueExceedStop': 'Boolean', # Boolean
            # Threshold for force / torque to detect collision during putting the grabbed item back. unit is N for force, Nm for torque.
            'putBackSafetyForceTorqueExceedThresholds': 'Float', # [Float]
            # Threshold for force / torque delta to detect collision during putting the grabbed item back. unit is N for force, Nm for torque.
            'putBackSafetyForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm, The distance to lift while dragging target to ease effect of friction between target and ground.
            'registrationDragLiftOffset': 'Float', # Float
            # mm, distance to drag target in order to separate it from other objects and register its XY size.
            'registrationDragOffset': 'Float', # Float
            # mm, The distance to lift the object in the air in order to separate it from other objects and register its XY size.
            'registrationGraspLiftOffset': 'Float', # Float
            # This mode describes how robot moves workpiece on size registration.
            'registrationMotionMode': 'String', # String
            # Ratio to estimate sagging angle from center of mass deviation from grasp. saggingAngle[deg]=saggingAngleGuessingRatio*centerOfMassDeviation[mm].
            'saggingAngleGuessingRatio': 'Float', # Float
            # If True, lift position of MVR uses X and Y components copied from grasp depart offset. This can make the MVR detached from neighbor when robot does mass measurement and can expect better accuracy.
            'shiftByGraspDepartOffset': 'Boolean', # Boolean
            # The name of IK Parameter that represents the line sensor used for stopping approach motion if a grabbed part hit the sensor. The position of body is used to calculate geometry of the grabbed part. Usually, height is determined by this sensor. Should be in the format instobjectname/ikparamname
            'stopSensorIkParamName': 'String', # String
            # This parameter is obsolete. please define IK parameter for the stop sensor and migrate to stopSensorIkParamName. The name of sensor body that is used to stop approach motion if a grabbed part hit the sensor. The position of body is used to calculate geometry of the grabbed part. Usually, height is determined by this sensor
            'stopSensorObjectName': 'String', # String
            # Set to true to enable minimum viable region planning parameters.
            'use': 'Boolean', # Boolean
            # Wait registration of min viable region before starting planning for next pick cycle.
            'waitRegistrationForNextPlan': 'Boolean', # Boolean
        },

        # parameters that are used with planning for minimum viable region
        'MinViableRegionPlanParametersInput': {
            # If ratio between maxPossibleSize and targetSize is smaller than this ratio, allow lift even when registrationMotionMode is 'drag'
            'allowLiftSizeRatio': 'Float', # Float
            # Set to true to immediately replanning of part once it is dropped.
            'canDoReplanWithNewTarget': 'Boolean', # Boolean
            # The name of the IO to stop sensor measuring minimum viable region size.
            'captureCancelIOName': 'String', # String
            # The name of the IO to know if sensor finishes measuring minimum viable region size.
            'captureFinishIOName': 'String', # String
            # The name of the IO to trigger sensor to measure minimum viable region size.
            'captureTriggerIOName': 'String', # String
            # default transfer speed multiplier for lifting up
            'defaultLiftingUpSpeedMult': 'Float', # Float
            # If True, system will raise an error when force / torque exceeding draggingForceTorqueExceedThresholds or draggingForceTorqueExceedThresholdsDelta is detected. If False, robot will try to continue.
            'draggingForceTorqueExceedStop': 'Boolean', # Boolean
            # Threshold for force / torque to detect collision during dragging the grabbed item. unit is N for force, Nm for torque.
            'draggingForceTorqueExceedThresholds': 'Float', # [Float]
            # Threshold for force / torque delta to detect collision during dragging the grabbed item. unit is N for force, Nm for torque.
            'draggingForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # transfer speed multiplier for lifting up size measurement and registration. this should be slow enough to safely lifting up uncertain size objects
            'liftingUpSpeedMultForSizeMeasurement': 'Float', # Float
            # Defines maximum allowed center of mass deviation from geometrical center for registration to be successful. The allowed center of mass range is computed by multiplication of this ratio and size of target.
            'maxAllowedObjectComRatio': 'Float', # Float
            # Maximum sagging angle in degrees for compensating sagging by gripper rotation.
            'maxSaggingAngle': 'Float', # Float
            # Maximum seconds to hold minimum viable region for registration
            'maxSecondsToHold': 'Float', # Float
            # Minimum allowed size change ratio to bring minimum viable region to destination
            'minAllowedObjectSizeRatio': 'Float', # Float
            # Minimum allowed transfer speed mult to bring minimum viable region to destination
            'minAllowedTransferSpeedMult': 'Float', # Float
            # kg, The minimum candidate mass to register
            'minCandidateMass': 'Float', # Float
            # Minimum distance in mm to expose uncertain corner to vision
            'minCornerVisibleDist': 'Float', # Float
            # Minimum distance in mm to expose uncertain corner of octagonal case to vision
            'minCornerVisibleDistForOctagonal': 'Float', # Float
            # The size XYZ in mm to clean obstacles surrounding the newly registered item for re-planning
            'obstacleCleanSizeXYZForReplan': 'Float', # [Float]
            # Allowed penetration distance in mm for robot to go inside of an area that should not be occluded
            'occlusionPenetration': 'Float', # Float
            # The distance in mm to lower obstacles surrounding the newly registered item for re-planning
            'overlappingObstacleLoweringDistanceForReplan': 'Float', # Float
            # Speed multiplier for placing a grabbed target back.
            'placeBackSpeedMult': 'Float', # Float
            # If True, system will raise an error when force / torque exceeding putBackSafetyForceTorqueExceedThresholds or putBackSafetyForceTorqueExceedThresholdsDelta is detected. If False, robot will try to continue.
            'putBackSafetyForceTorqueExceedStop': 'Boolean', # Boolean
            # Threshold for force / torque to detect collision during putting the grabbed item back. unit is N for force, Nm for torque.
            'putBackSafetyForceTorqueExceedThresholds': 'Float', # [Float]
            # Threshold for force / torque delta to detect collision during putting the grabbed item back. unit is N for force, Nm for torque.
            'putBackSafetyForceTorqueExceedThresholdsDelta': 'Float', # [Float]
            # mm, The distance to lift while dragging target to ease effect of friction between target and ground.
            'registrationDragLiftOffset': 'Float', # Float
            # mm, distance to drag target in order to separate it from other objects and register its XY size.
            'registrationDragOffset': 'Float', # Float
            # mm, The distance to lift the object in the air in order to separate it from other objects and register its XY size.
            'registrationGraspLiftOffset': 'Float', # Float
            # This mode describes how robot moves workpiece on size registration.
            'registrationMotionMode': 'String', # String
            # Ratio to estimate sagging angle from center of mass deviation from grasp. saggingAngle[deg]=saggingAngleGuessingRatio*centerOfMassDeviation[mm].
            'saggingAngleGuessingRatio': 'Float', # Float
            # If True, lift position of MVR uses X and Y components copied from grasp depart offset. This can make the MVR detached from neighbor when robot does mass measurement and can expect better accuracy.
            'shiftByGraspDepartOffset': 'Boolean', # Boolean
            # The name of IK Parameter that represents the line sensor used for stopping approach motion if a grabbed part hit the sensor. The position of body is used to calculate geometry of the grabbed part. Usually, height is determined by this sensor. Should be in the format instobjectname/ikparamname
            'stopSensorIkParamName': 'String', # String
            # This parameter is obsolete. please define IK parameter for the stop sensor and migrate to stopSensorIkParamName. The name of sensor body that is used to stop approach motion if a grabbed part hit the sensor. The position of body is used to calculate geometry of the grabbed part. Usually, height is determined by this sensor
            'stopSensorObjectName': 'String', # String
            # Set to true to enable minimum viable region planning parameters.
            'use': 'Boolean', # Boolean
            # Wait registration of min viable region before starting planning for next pick cycle.
            'waitRegistrationForNextPlan': 'Boolean', # Boolean
        },

        'ModifyReferenceObjectPKsReturnValue': {
            # List of disabled reference object pks after modification.
            'disabledReferenceObjectPks': 'String', # [String!]!
            # List of reference object pks after modification.
            'referenceObjectPks': 'String', # [String!]!
        },

        # Parameters used for linear movement when have to do dynamic replanning during execution. The parameters should be more loose than moveStraightParameters since the robot might be very close to thresholds and fail.
        'MoveStraightParameters': {
            # rad, Check that the expected quaternion and real quaternion angles don't differ by more than this amount. The default value is 0.891, which is cos(27 deg) or cos(0.15*pi).
            'cosDeltaAngleThresh': 'Float', # Float
            # Indicates whether to check for torque limits when planning.
            'dynamicsConstraintsType': 'String', # String
            # A positive number to multiply to the distance between two consecutive IK parameters along the linear path to give a threshold value. The threshold limits the distance between the tool point computed from the forward kinematics of (vpreviksol + vcursol)/2 and the tool point computed from the IK parameter in the middle of previk and curik.
            'ikMidpointMaxDistMult': 'Float', # Float
            # deg, A maximum angle the tool is allowed to deviate from the expected path.
            'ikMidpointMaxRotDist': 'Float', # Float
            # mm, A maximum distance the tool is allowed to deviate from the expected path.
            'ikMidpointMaxTransDist': 'Float', # Float
            # Used in workspace verifier to reject solutions close to singularities. If max(eig)/min(eig) is greater than this number, then reject. If set to be negative, will be disabled.
            'jacobianMinCond': 'Float', # Float
            # Used in workspace verifier to reject solutions close to singularities. If the minimum Jacobian eigen value is less than this value, then reject. If set to be negative, will be disabled.
            'jacobianMinEigenValue': 'Float', # Float
            # A number between 0 and 1 to multiply to the robot joint acceleration limits when planning linear trajectories.
            'jointaccelmult': 'Float', # Float
            # The maximum number of times the planner is allowed to increase its step size in order to cope with singularities.
            'maxAdaptiveSteps': 'Int', # Int
            # The maximum number of iterations for the move-straight trajectory planner.
            'maxIterations': 'Int', # Int
            # rad, Limits how much a revolute joint can move in one planning step during linear trajectory planning.
            'maxRevoluteDifference': 'Float', # Float
            # default: '6d', the move straight mode. If empty, then robot uses all joints to plan for with respect to the grasp's ik type. If 'all6d', then robot uses all joints to plan for with Transform6D ik type (ie hand orientation doesn't change). If 'min6d', then robot uses the 6 joints to plan for with Transform6D ik type (ie 7DOF arm will move without changing hand orientation).
            'moveStraightMode': 'String', # String
            # Check that the length squared of delta quaternion is always greater than this threshold * solution distance squared: |J*solutiondiff|^2 > |solutiondiff|^2 * rotationDiffThresh.
            'rotationDiffThresh': 'Float', # Float
            # s, Sampling the workspace trajectory by this time step in order to generate steps where robot has to guarantee the linear conditions, any in between movements are linearly interpolated in joint space. The smaller the value, the more accurate the total.
            'trajSampleTimeStep': 'Float', # Float
            # Check that the length squared of delta translation is always greater than this threshold * solution distance squared: |J*solutiondiff|^2 > |solutiondiff|^2 * translationDiffThresh
            'translationDiffThresh': 'Float', # Float
            # If 1 is set, will try the greedy workspace planner for moving the hand straight. If 2 is set, will try the RRT for moving straight. If 4 will fallback on workspace optimizer if greedy workspace planner doesn't work. Can set 7 for trying all.
            'useworkspaceplanner': 'Int', # Int
            # mm, When doing linear approach and depart, sample the workspace by this amount and then have the robot go through it. The larger the value, the less linear the tool moves, but it succeeds more often and computes faster.
            'workVerifyStepLength': 'Float', # Float
            # s, The time duration from the beginning of the trajectory that the move-straight planner ignores robot collision.
            'workignorefirstcollision': 'Float', # Float
            # s, The time duration from the beginning of the trajectory that the move-straight planner ignores robot end-effector collision.
            'workignorefirstcollisionee': 'Float', # Float
            # s, The time duration at the end of the trajectory that the move-straight planner ignores robot end-effector collision.
            'workignorelastcollisionee': 'Float', # Float
            # deg, An angle indicating how much the tool is allowed to deviate from the desired linear path in order to, for example, avoid singularities.
            'workmaxdeviationangle': 'Float', # Float
            # m, When doing linear approach and depart, sample the workspace by this amount and then have the robot go through it. The larger the value, the less linear the tool moves, but it succeeds more often and computes faster.
            'worksteplength': 'Float', # Float
        },

        # Parameters used for linear movement when have to do dynamic replanning during execution. The parameters should be more loose than moveStraightParameters since the robot might be very close to thresholds and fail.
        'MoveStraightParametersInput': {
            # rad, Check that the expected quaternion and real quaternion angles don't differ by more than this amount. The default value is 0.891, which is cos(27 deg) or cos(0.15*pi).
            'cosDeltaAngleThresh': 'Float', # Float
            # Indicates whether to check for torque limits when planning.
            'dynamicsConstraintsType': 'String', # String
            # A positive number to multiply to the distance between two consecutive IK parameters along the linear path to give a threshold value. The threshold limits the distance between the tool point computed from the forward kinematics of (vpreviksol + vcursol)/2 and the tool point computed from the IK parameter in the middle of previk and curik.
            'ikMidpointMaxDistMult': 'Float', # Float
            # deg, A maximum angle the tool is allowed to deviate from the expected path.
            'ikMidpointMaxRotDist': 'Float', # Float
            # mm, A maximum distance the tool is allowed to deviate from the expected path.
            'ikMidpointMaxTransDist': 'Float', # Float
            # Used in workspace verifier to reject solutions close to singularities. If max(eig)/min(eig) is greater than this number, then reject. If set to be negative, will be disabled.
            'jacobianMinCond': 'Float', # Float
            # Used in workspace verifier to reject solutions close to singularities. If the minimum Jacobian eigen value is less than this value, then reject. If set to be negative, will be disabled.
            'jacobianMinEigenValue': 'Float', # Float
            # A number between 0 and 1 to multiply to the robot joint acceleration limits when planning linear trajectories.
            'jointaccelmult': 'Float', # Float
            # The maximum number of times the planner is allowed to increase its step size in order to cope with singularities.
            'maxAdaptiveSteps': 'Int', # Int
            # The maximum number of iterations for the move-straight trajectory planner.
            'maxIterations': 'Int', # Int
            # rad, Limits how much a revolute joint can move in one planning step during linear trajectory planning.
            'maxRevoluteDifference': 'Float', # Float
            # default: '6d', the move straight mode. If empty, then robot uses all joints to plan for with respect to the grasp's ik type. If 'all6d', then robot uses all joints to plan for with Transform6D ik type (ie hand orientation doesn't change). If 'min6d', then robot uses the 6 joints to plan for with Transform6D ik type (ie 7DOF arm will move without changing hand orientation).
            'moveStraightMode': 'String', # String
            # Check that the length squared of delta quaternion is always greater than this threshold * solution distance squared: |J*solutiondiff|^2 > |solutiondiff|^2 * rotationDiffThresh.
            'rotationDiffThresh': 'Float', # Float
            # s, Sampling the workspace trajectory by this time step in order to generate steps where robot has to guarantee the linear conditions, any in between movements are linearly interpolated in joint space. The smaller the value, the more accurate the total.
            'trajSampleTimeStep': 'Float', # Float
            # Check that the length squared of delta translation is always greater than this threshold * solution distance squared: |J*solutiondiff|^2 > |solutiondiff|^2 * translationDiffThresh
            'translationDiffThresh': 'Float', # Float
            # If 1 is set, will try the greedy workspace planner for moving the hand straight. If 2 is set, will try the RRT for moving straight. If 4 will fallback on workspace optimizer if greedy workspace planner doesn't work. Can set 7 for trying all.
            'useworkspaceplanner': 'Int', # Int
            # mm, When doing linear approach and depart, sample the workspace by this amount and then have the robot go through it. The larger the value, the less linear the tool moves, but it succeeds more often and computes faster.
            'workVerifyStepLength': 'Float', # Float
            # s, The time duration from the beginning of the trajectory that the move-straight planner ignores robot collision.
            'workignorefirstcollision': 'Float', # Float
            # s, The time duration from the beginning of the trajectory that the move-straight planner ignores robot end-effector collision.
            'workignorefirstcollisionee': 'Float', # Float
            # s, The time duration at the end of the trajectory that the move-straight planner ignores robot end-effector collision.
            'workignorelastcollisionee': 'Float', # Float
            # deg, An angle indicating how much the tool is allowed to deviate from the desired linear path in order to, for example, avoid singularities.
            'workmaxdeviationangle': 'Float', # Float
            # m, When doing linear approach and depart, sample the workspace by this amount and then have the robot go through it. The larger the value, the less linear the tool moves, but it succeeds more often and computes faster.
            'worksteplength': 'Float', # Float
        },

        'NetworkInterfaceRoute': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Route destination specification, in the CIDR format, e.g. 192.168.1.0/24
            'destination': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Route nexthop. Matching traffic will be sent to this IP address on the network
            'via': 'String', # String
        },

        'NetworkInterfaceRouteInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Route destination specification, in the CIDR format, e.g. 192.168.1.0/24
            'destination': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Route nexthop. Matching traffic will be sent to this IP address on the network
            'via': 'String', # String
        },

        # Network interface settings for one specific interface.
        'NetworkInterfaceSettings': {
            # In case of direct or static mode, IP address to be configured on the interface.
            'address': 'String', # String
            # In case of static mode or direct mode, ip addresses to be configured on the interface.
            'addresses': 'String', # [String]
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Usage description defined by user.
            'description': 'String', # String
            # Specifies whether autonegotiation should be enabled. Autonegotiation is enabled by default, but in some network devices may have trouble with it, so you can disable it if really necessary.
            'ethernetautoneg': 'Boolean', # Boolean
            # Sets full or half duplex mode.
            'ethernetduplex': 'String', # String
            # Set speed in Mb/s.
            'ethernetspeed': 'Int', # Int
            # In case of static mode, IP address of the gateway on the network.
            'gateway': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Automatically set and overwritten, e.g. LAN1, LAN2, WiFi.
            'label': 'String', # String
            # Interface configuration mode:
            # 
            # - "dhcp": automatic ip assignment by DHCP server
            # - "static": static ip assignment
            # - "direct": direct interface with static ip assignment
            # - "bridged": bridged network for camera sensors
            # - "ethercat": ethercat master port
            # - "manual": interface not used
            'mode': 'String', # String
            # In case of static mode, IP address of the primary name server on the network.
            'nameserver1': 'String', # String
            # In case of static mode, IP address of the secondary name server on the network.
            'nameserver2': 'String', # String
            # In case of direct or static mode, netmask to be configured on the interface.
            'netmask': 'String', # String
            # In case of static mode, additional routes to be configured for this interface.
            'routes': 'NetworkInterfaceRoute', # [NetworkInterfaceRoute]
            # Specifies the password of the wireless network to connect to.
            'wirelesspsk': 'String', # String
            # Specifies the SSID of the wireless network to connect to.
            'wirelessssid': 'String', # String
            # Specifies the MAC address of the peer controller to wake up over LAN.
            'wolmac': 'String', # String
        },

        # Network interface settings for one specific interface.
        'NetworkInterfaceSettingsInput': {
            # In case of direct or static mode, IP address to be configured on the interface.
            'address': 'String', # String
            # In case of static mode or direct mode, ip addresses to be configured on the interface.
            'addresses': 'String', # [String]
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Usage description defined by user.
            'description': 'String', # String
            # Specifies whether autonegotiation should be enabled. Autonegotiation is enabled by default, but in some network devices may have trouble with it, so you can disable it if really necessary.
            'ethernetautoneg': 'Boolean', # Boolean
            # Sets full or half duplex mode.
            'ethernetduplex': 'String', # String
            # Set speed in Mb/s.
            'ethernetspeed': 'Int', # Int
            # In case of static mode, IP address of the gateway on the network.
            'gateway': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Automatically set and overwritten, e.g. LAN1, LAN2, WiFi.
            'label': 'String', # String
            # Interface configuration mode:
            # 
            # - "dhcp": automatic ip assignment by DHCP server
            # - "static": static ip assignment
            # - "direct": direct interface with static ip assignment
            # - "bridged": bridged network for camera sensors
            # - "ethercat": ethercat master port
            # - "manual": interface not used
            'mode': 'String', # String
            # In case of static mode, IP address of the primary name server on the network.
            'nameserver1': 'String', # String
            # In case of static mode, IP address of the secondary name server on the network.
            'nameserver2': 'String', # String
            # In case of direct or static mode, netmask to be configured on the interface.
            'netmask': 'String', # String
            # In case of static mode, additional routes to be configured for this interface.
            'routes': 'NetworkInterfaceRouteInput', # [NetworkInterfaceRouteInput]
            # Specifies the password of the wireless network to connect to.
            'wirelesspsk': 'String', # String
            # Specifies the SSID of the wireless network to connect to.
            'wirelessssid': 'String', # String
            # Specifies the MAC address of the peer controller to wake up over LAN.
            'wolmac': 'String', # String
        },

        # Parameters to check object mass properties. If enabled, object mass properties will be checked dynamically while executing pick and place cycle. Force/Torque sensor is required to use this feature.
        'ObjectMassPropertiesCheckingInfo': {
            # If true, execute mass/center of mass validation on dest approach
            'checkDuringDestApproach': 'Boolean', # Boolean
            # If true, execute mass/center of mass validation on grasp depart
            'checkDuringGraspDepart': 'Boolean', # Boolean
            # body name which has force torque sensor frame. it is used to transform expected center of mass position etc.
            'forceTorqueSensorLinkName': 'String', # String
            # index to select thresholds set from thresholdsList for dest approach. this index starts from zero
            'indexThresholdsForDestApproach': 'Int', # Int
            # index to select thresholds set from thresholdsList for grasp depart. this index starts from zero
            'indexThresholdsForGraspDepart': 'Int', # Int
            # If true, reference center of mass will be overwritten by current estimated value on the end of grasp depart
            'overwriteExpectedCenterOfMassWithEstimatedOnGraspDepartEnd': 'Boolean', # Boolean
            # If true, reference mass will be overwritten by current estimated value on the end of grasp depart
            'overwriteExpectedMassWithEstimatedOnGraspDepartEnd': 'Boolean', # Boolean
            # List of thresholds set for mass and center of mass validation. thresholds set can be used by specifying from indexThresholdsForGraspDepart and indexThresholdsForDestApproach
            'thresholdsList': 'ObjectMassPropertiesThresholds', # [ObjectMassPropertiesThresholds]
            # The name of the IO to use to trigger mass/COM checking. signal is generated as a part of trajectory
            'triggerIOName': 'String', # String
            # sec, How much to delay the IO signal of the mass/COM checking from the ideal time that the system thinks good timing for measurement. Communication and robot motion delays can cause slight differences in timing, which this parameter can account for.
            'triggerOutputDelay': 'Float', # Float
            # sec, The amount of time to keep checking mass/COM
            'triggerOutputDuration': 'Float', # Float
            # mm, the system starts mass/COM checking after target is sufficiently lifted up from ground and its height exceeds this value.
            'triggerStartHeight': 'Float', # Float
            # Set to true to enable object mass properties checking.
            'use': 'Boolean', # Boolean
        },

        # Parameters to check object mass properties. If enabled, object mass properties will be checked dynamically while executing pick and place cycle. Force/Torque sensor is required to use this feature.
        'ObjectMassPropertiesCheckingInfoInput': {
            # If true, execute mass/center of mass validation on dest approach
            'checkDuringDestApproach': 'Boolean', # Boolean
            # If true, execute mass/center of mass validation on grasp depart
            'checkDuringGraspDepart': 'Boolean', # Boolean
            # body name which has force torque sensor frame. it is used to transform expected center of mass position etc.
            'forceTorqueSensorLinkName': 'String', # String
            # index to select thresholds set from thresholdsList for dest approach. this index starts from zero
            'indexThresholdsForDestApproach': 'Int', # Int
            # index to select thresholds set from thresholdsList for grasp depart. this index starts from zero
            'indexThresholdsForGraspDepart': 'Int', # Int
            # If true, reference center of mass will be overwritten by current estimated value on the end of grasp depart
            'overwriteExpectedCenterOfMassWithEstimatedOnGraspDepartEnd': 'Boolean', # Boolean
            # If true, reference mass will be overwritten by current estimated value on the end of grasp depart
            'overwriteExpectedMassWithEstimatedOnGraspDepartEnd': 'Boolean', # Boolean
            # List of thresholds set for mass and center of mass validation. thresholds set can be used by specifying from indexThresholdsForGraspDepart and indexThresholdsForDestApproach
            'thresholdsList': 'ObjectMassPropertiesThresholdsInput', # [ObjectMassPropertiesThresholdsInput]
            # The name of the IO to use to trigger mass/COM checking. signal is generated as a part of trajectory
            'triggerIOName': 'String', # String
            # sec, How much to delay the IO signal of the mass/COM checking from the ideal time that the system thinks good timing for measurement. Communication and robot motion delays can cause slight differences in timing, which this parameter can account for.
            'triggerOutputDelay': 'Float', # Float
            # sec, The amount of time to keep checking mass/COM
            'triggerOutputDuration': 'Float', # Float
            # mm, the system starts mass/COM checking after target is sufficiently lifted up from ground and its height exceeds this value.
            'triggerStartHeight': 'Float', # Float
            # Set to true to enable object mass properties checking.
            'use': 'Boolean', # Boolean
        },

        # set of thresholds for mass and center of mass validation
        'ObjectMassPropertiesThresholds': {
            # Threshold for error of center of mass (COM) estimation. if distance between expected COM and measured COM exceeds this value, the system will report it and safely react against it.
            'centerOfMassThreshold': 'Float', # Float
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Lower threshold for error of mass estimation. if measured mass is smaller than (expected mass)-(massLowerThreshold), the system will report it and safely react against it.
            'massLowerThreshold': 'Float', # Float
            # When massLowerThresholdMult is being used, lower threshold for estimated mass will be truncated at this value
            'massLowerThresholdMin': 'Float', # Float
            # Lower threshold multiplier for error of mass estimation. if measured mass is smaller than (expected mass)-(massLowerThresholdMult)*(expected mass), the system will report it and safely react against it.
            'massLowerThresholdMult': 'Float', # Float
            # Upper threshold for error of mass estimation. if measured mass is larger than (expected mass)+(massUpperThreshold), the system will report it and safely react against it.
            'massUpperThreshold': 'Float', # Float
            # When massUpperThresholdMult is being used, upper threshold for estimated mass will be truncated at this value
            'massUpperThresholdMin': 'Float', # Float
            # Upper threshold multiplier for error of mass estimation. if measured mass is larger than (expected mass)+(massUpperThresholdMult)*(expected mass), the system will report it and safely react against it.
            'massUpperThresholdMult': 'Float', # Float
        },

        # set of thresholds for mass and center of mass validation
        'ObjectMassPropertiesThresholdsInput': {
            # Threshold for error of center of mass (COM) estimation. if distance between expected COM and measured COM exceeds this value, the system will report it and safely react against it.
            'centerOfMassThreshold': 'Float', # Float
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Lower threshold for error of mass estimation. if measured mass is smaller than (expected mass)-(massLowerThreshold), the system will report it and safely react against it.
            'massLowerThreshold': 'Float', # Float
            # When massLowerThresholdMult is being used, lower threshold for estimated mass will be truncated at this value
            'massLowerThresholdMin': 'Float', # Float
            # Lower threshold multiplier for error of mass estimation. if measured mass is smaller than (expected mass)-(massLowerThresholdMult)*(expected mass), the system will report it and safely react against it.
            'massLowerThresholdMult': 'Float', # Float
            # Upper threshold for error of mass estimation. if measured mass is larger than (expected mass)+(massUpperThreshold), the system will report it and safely react against it.
            'massUpperThreshold': 'Float', # Float
            # When massUpperThresholdMult is being used, upper threshold for estimated mass will be truncated at this value
            'massUpperThresholdMin': 'Float', # Float
            # Upper threshold multiplier for error of mass estimation. if measured mass is larger than (expected mass)+(massUpperThresholdMult)*(expected mass), the system will report it and safely react against it.
            'massUpperThresholdMult': 'Float', # Float
        },

        # Describes some binpicking parameters which have to be applied for the specific objectType.
        'ObjectTypeDynamicParameters': {
            # Describes some binpicking parameters which have to be applied for the specific objectType.
            'cubicalCase': 'ObjectTypeDynamicParameters_CubicalCase', # ObjectTypeDynamicParameters_CubicalCase
            # Describes some binpicking parameters which have to be applied for the specific objectType.
            'octagonalCase': 'ObjectTypeDynamicParameters_OctagonalCase', # ObjectTypeDynamicParameters_OctagonalCase
        },

        # Describes some binpicking parameters which have to be applied for the specific objectType.
        'ObjectTypeDynamicParametersInput': {
            # Describes some binpicking parameters which have to be applied for the specific objectType.
            'cubicalCase': 'ObjectTypeDynamicParametersInput_CubicalCase', # ObjectTypeDynamicParametersInput_CubicalCase
            # Describes some binpicking parameters which have to be applied for the specific objectType.
            'octagonalCase': 'ObjectTypeDynamicParametersInput_OctagonalCase', # ObjectTypeDynamicParametersInput_OctagonalCase
        },

        # Describes some binpicking parameters which have to be applied for the specific objectType.
        'ObjectTypeDynamicParametersInput_CubicalCase': {
            # 1..254, object packing id used for automatic placement generation. Item *i* can be placed on top of item *j* if and only if objectPackingId_i <= objectPackingId_j. Reserved values are: 
            # * 0x0 - empty space, invalid for real objects;
            # * 0x1 - no placement above, none of the items can be placed on top (even the one with objectPackingId == 0x1);
            # * 0xfe - undefined object packing id, any item can be placed on top of it;
            # * 0xff - pointcloud, object representing pointcloud data.
            'objectPackingId': 'Int', # Int
            # Specifies the transfer speed mult ratio in [0,1] to reduce speed when grabbing an object. This is a global setting applied
            'transferSpeedMult': 'Float', # Float
            # Amount of time to wait for the hand after successful chucking. Hand will always wait for this time no matter what
            'waitTimeAfterChuckSuccess': 'Float', # Float
        },

        # Describes some binpicking parameters which have to be applied for the specific objectType.
        'ObjectTypeDynamicParametersInput_OctagonalCase': {
            # 1..254, object packing id used for automatic placement generation. Item *i* can be placed on top of item *j* if and only if objectPackingId_i <= objectPackingId_j. Reserved values are: 
            # * 0x0 - empty space, invalid for real objects;
            # * 0x1 - no placement above, none of the items can be placed on top (even the one with objectPackingId == 0x1);
            # * 0xfe - undefined object packing id, any item can be placed on top of it;
            # * 0xff - pointcloud, object representing pointcloud data.
            'objectPackingId': 'Int', # Int
            # Specifies the transfer speed mult ratio in [0,1] to reduce speed when grabbing an object. This is a global setting applied
            'transferSpeedMult': 'Float', # Float
            # Amount of time to wait for the hand after successful chucking. Hand will always wait for this time no matter what
            'waitTimeAfterChuckSuccess': 'Float', # Float
        },

        # Describes some binpicking parameters which have to be applied for the specific objectType.
        'ObjectTypeDynamicParameters_CubicalCase': {
            # 1..254, object packing id used for automatic placement generation. Item *i* can be placed on top of item *j* if and only if objectPackingId_i <= objectPackingId_j. Reserved values are: 
            # * 0x0 - empty space, invalid for real objects;
            # * 0x1 - no placement above, none of the items can be placed on top (even the one with objectPackingId == 0x1);
            # * 0xfe - undefined object packing id, any item can be placed on top of it;
            # * 0xff - pointcloud, object representing pointcloud data.
            'objectPackingId': 'Int', # Int
            # Specifies the transfer speed mult ratio in [0,1] to reduce speed when grabbing an object. This is a global setting applied
            'transferSpeedMult': 'Float', # Float
            # Amount of time to wait for the hand after successful chucking. Hand will always wait for this time no matter what
            'waitTimeAfterChuckSuccess': 'Float', # Float
        },

        # Describes some binpicking parameters which have to be applied for the specific objectType.
        'ObjectTypeDynamicParameters_OctagonalCase': {
            # 1..254, object packing id used for automatic placement generation. Item *i* can be placed on top of item *j* if and only if objectPackingId_i <= objectPackingId_j. Reserved values are: 
            # * 0x0 - empty space, invalid for real objects;
            # * 0x1 - no placement above, none of the items can be placed on top (even the one with objectPackingId == 0x1);
            # * 0xfe - undefined object packing id, any item can be placed on top of it;
            # * 0xff - pointcloud, object representing pointcloud data.
            'objectPackingId': 'Int', # Int
            # Specifies the transfer speed mult ratio in [0,1] to reduce speed when grabbing an object. This is a global setting applied
            'transferSpeedMult': 'Float', # Float
            # Amount of time to wait for the hand after successful chucking. Hand will always wait for this time no matter what
            'waitTimeAfterChuckSuccess': 'Float', # Float
        },

        # Parameters controlling the packing behaviors and algorithms for startPackFormationComputation command.
        'PackFormationParameters': {
            # If true, then allow packing into multiple containers and the pack will continue packing until all packing items not packed.
            'allowMultipleContainer': 'Boolean', # Boolean
            # Parameters controlling same item automatic packing computation.
            'autoPackFormationComputationParameters': 'AutoPackFormationComputationParameters', # AutoPackFormationComputationParameters
            # Ratio of how many states to remove if the current state has no placements. Only states from the same search subtree (with common root state) will be removed.
            'badStatesPruningRatio': 'Float', # Float
            # If true, then will center the final pack in the middle of the container by X axis.
            'centerFinalPackOnX': 'Boolean', # Boolean
            # If true, then will center the final pack in the middle of the container by Y axis.
            'centerFinalPackOnY': 'Boolean', # Boolean
            'debuglevel': 'Int', # Int
            # Dynamic goals generator parameters. Used only if useDynamicGoals is True
            'dynamicGoalsGeneratorParameters': 'Any', # Any
            # Dynamic goals generator parameters that overwrite original parameters if any object type in pack computation request is a key value of this dictionary. Key value of the dictionary must be one from objectTypeMapping.
            'dynamicGoalsGeneratorParametersPerAnyObjectType': 'Any', # Any
            # If true, then will check each unique group member for 2D search when packing. If true, the 2D search will be much slower, but sometimes can give better solutions. Not recommended to turn on.
            'forceCheckEachUniqueGroupMember': 'Boolean', # Boolean
            # Parameters used to prioritize and order items for packing
            'groupComparatorParameters': 'GroupComparatorParameters', # GroupComparatorParameters
            # HACK for Cosmos beer packing ordering. If true, then will define packingOrderPriority per each item in packing request. If any packingOrderPriority or packingOrderPriorities defined, then parameter will be ignored. The order will be the following: group items by height and priorities groups with bigger amount of items, in side of each group order items by number of same items in the group. For example:
            # - 3 SKU A (500 ml)
            # - 1 SKU B (500 ml)
            # - 5 SKU C (300 ml)
            # - 3 SKU D (300 ml)
            # will be ordered as following:
            # First, decide to pack 500ml and 350ml with the larger total number first. ( 3A +1B ) < ( 5C + 3D ); ( 4 500ml) < ( 8 350ml)   => 350ml first ,500ml later
            # Next, decide the order in each ml. 350ml  5C > 3D  => C first, D 2nd; 500ml  3A > 1B  =>  A 3rd, B 4th
            # Therefore order will be: C -> D -> A -> B
            'isStrictGroupSizeOrdering': 'Boolean', # Boolean
            # Maximum number of items which can be packed to the same container. If 0, then no limit.
            'maxNumItemsInPack': 'Int', # Int
            # The maximum layers to palletize for. If 0, then no limit.
            'maxPalletLayerNumber': 'Int', # Int
            # mm, the maximum allowed gap to move packed items to spread the layer. Must be computed automatically in the parameters parsing depending on the smallest item leftover, etc.
            'maxSpreadPlacementGap': 'Int', # Int
            # Maximum number of spread iterations to perform on the layer before stopping.
            'maxSpreadPlacementsIteration': 'Int', # Int
            # Maximum branching factor for discovering states. For example, if maxStateBranchingFactor=7, then each state can have 7 children explored, 49 grandchildren, 343 great-grandchildren, etc.
            'maxStateBranchingFactor': 'Int', # Int
            # If less than this amount of packed items are improved in packingSpeedIntervalSec time, then packing computation will be stopped.
            'minItemsToPackInSpeedInterval': 'Int', # Int
            # Minimum number of groups to check for search state
            'minNumGroupsToCheck': 'Int', # Int
            # deg, minimum angle which the packing should hold until toppling.
            'minToppleAngle': 'Float', # Float
            # deg, minimum angle which the packing should hold until toppling at the bottom of the container.
            'minToppleAngleAtBottom': 'Float', # Float
            # deg, minimum angle which the packing should hold until toppling at top edge of the container.
            'minToppleAngleAtTop': 'Float', # Float
            # multiplier for "minToppleAngle", "minToppleAngleAtBottom", "minToppleAngleAtTop" to have a stricter topple angle in directions where packing container does not have wall.
            'minToppleAngleOpenWallMult': 'Float', # Float
            # Defines how many states per face of the item to consider after 2D placement of a group of items into a layer (plane with the same height). The bigger makes discovering more states, therefore final result might be better, but the overall search will be slower.
            'numMaxBestStatesPerFace': 'Int', # Int
            # Defines how many states per rotation of the item to consider after 2D placement of a group of items into a layer (plane with the same height). The bigger makes discovering more states, therefore final result might be better, but the overall search will be slower.
            'numMaxBestStatesPerRotation': 'Int', # Int
            # Maximum number of solutions for the 2D search to consider. Larger values make 2D packing better, but will decrease the overall search speed.
            'numMaxSolutions2DSearch': 'Int', # Int
            # If true, then will reorganize the input order depending on the results of the search.
            'outOfOrderSearch': 'Boolean', # Boolean
            # Pack formation parameters that overwrite original parameters if any object type in pack computation request is a key value of this dictionary. Key value of the dictionary must be one from objectTypeMapping.
            'packFormationParametersPerAnyObjectType': 'Any', # Any
            # Parameters that controll the packing 2D pattern automatic selection when packing pattern name is not defined.
            'packing2DPatternAutoSelection': 'Packing2DPatternSelection', # Packing2DPatternSelection
            # Coefficients used to prioritize the search order of items placement.
            'packingCoefficients': 'PackingCoefficients', # PackingCoefficients
            # Multiplier how much weight can be placed onto each item. The multiplier will be applied on (item weight * number of layers the same item can hold).
            'packingPartMaxLoadMult': 'Float', # Float
            # s, time interval during which the packing speed is checked. The speed is computed by number of packed items improvement per 1 second.
            'packingSpeedIntervalSec': 'Float', # Float
            # If true, same items will be placed nearby within the same container. (note: same items can be separated into different containers if allowMultipleContainer is true).
            'placeOnlyNearSameItem': 'Boolean', # Boolean
            # If true, then reorder packed items, so that try to place lower items at placements with targetTopZ before items with bigger placementHeight. Still preserve dependOn
            'postProcessOrdering': 'Boolean', # Boolean
            # If true, then return only the solution which can pack all items. If false, the packing state with the best score will be returned after timing out.
            'returnCompleteSolution': 'Boolean', # Boolean
            # If true, return the first candidate in 2D search (actually switches off 2D search).
            'returnFirstCandidateOn2DSearch': 'Boolean', # Boolean
            # The search mode to discover packing search states:
            # - **groupFirst**  - tries to pack the group with the highest group score frist,
            # - **layerFirst**  - tries to fill the lower layer first and then spread the filled layer.
            'searchMode3D': 'String', # String
            # The threshold ratio on how similar a newly generated placement of items should be to already found placements to ignore the newly generated placement.
            'similarityIntersectionThresh': 'Float', # Float
            # Set to true to skip pack formation validation.
            'skipPackFormationValidation': 'Boolean', # Boolean
            # s, max time to wait to improve solution after one is found.
            'solutionImproveTimeoutSec': 'Float', # Float
            # If true, stop as soon as a packing satisfying constraints is found. If false, continue computation after a solution is found to improve the found packing.
            'stopAfterFirstSolution': 'Boolean', # Boolean
            # The filling ratio that is sufficient to consider the pack as a solution. Used to speed up packing and switch to the next pack calculation.
            'sufficientFillingRate': 'Float', # Float
            # s, max time for computing a pack before giving up.
            'timeoutSec': 'Float', # Float
            # Set to true to enable packing computation and pack formation following features.
            'use': 'Boolean', # Boolean
        },

        # Parameters controlling the packing behaviors and algorithms for startPackFormationComputation command.
        'PackFormationParametersInput': {
            # If true, then allow packing into multiple containers and the pack will continue packing until all packing items not packed.
            'allowMultipleContainer': 'Boolean', # Boolean
            # Parameters controlling same item automatic packing computation.
            'autoPackFormationComputationParameters': 'AutoPackFormationComputationParametersInput', # AutoPackFormationComputationParametersInput
            # Ratio of how many states to remove if the current state has no placements. Only states from the same search subtree (with common root state) will be removed.
            'badStatesPruningRatio': 'Float', # Float
            # If true, then will center the final pack in the middle of the container by X axis.
            'centerFinalPackOnX': 'Boolean', # Boolean
            # If true, then will center the final pack in the middle of the container by Y axis.
            'centerFinalPackOnY': 'Boolean', # Boolean
            'debuglevel': 'Int', # Int
            # Dynamic goals generator parameters. Used only if useDynamicGoals is True
            'dynamicGoalsGeneratorParameters': 'Any', # Any
            # Dynamic goals generator parameters that overwrite original parameters if any object type in pack computation request is a key value of this dictionary. Key value of the dictionary must be one from objectTypeMapping.
            'dynamicGoalsGeneratorParametersPerAnyObjectType': 'Any', # Any
            # If true, then will check each unique group member for 2D search when packing. If true, the 2D search will be much slower, but sometimes can give better solutions. Not recommended to turn on.
            'forceCheckEachUniqueGroupMember': 'Boolean', # Boolean
            # Parameters used to prioritize and order items for packing
            'groupComparatorParameters': 'GroupComparatorParametersInput', # GroupComparatorParametersInput
            # HACK for Cosmos beer packing ordering. If true, then will define packingOrderPriority per each item in packing request. If any packingOrderPriority or packingOrderPriorities defined, then parameter will be ignored. The order will be the following: group items by height and priorities groups with bigger amount of items, in side of each group order items by number of same items in the group. For example:
            # - 3 SKU A (500 ml)
            # - 1 SKU B (500 ml)
            # - 5 SKU C (300 ml)
            # - 3 SKU D (300 ml)
            # will be ordered as following:
            # First, decide to pack 500ml and 350ml with the larger total number first. ( 3A +1B ) < ( 5C + 3D ); ( 4 500ml) < ( 8 350ml)   => 350ml first ,500ml later
            # Next, decide the order in each ml. 350ml  5C > 3D  => C first, D 2nd; 500ml  3A > 1B  =>  A 3rd, B 4th
            # Therefore order will be: C -> D -> A -> B
            'isStrictGroupSizeOrdering': 'Boolean', # Boolean
            # Maximum number of items which can be packed to the same container. If 0, then no limit.
            'maxNumItemsInPack': 'Int', # Int
            # The maximum layers to palletize for. If 0, then no limit.
            'maxPalletLayerNumber': 'Int', # Int
            # mm, the maximum allowed gap to move packed items to spread the layer. Must be computed automatically in the parameters parsing depending on the smallest item leftover, etc.
            'maxSpreadPlacementGap': 'Int', # Int
            # Maximum number of spread iterations to perform on the layer before stopping.
            'maxSpreadPlacementsIteration': 'Int', # Int
            # Maximum branching factor for discovering states. For example, if maxStateBranchingFactor=7, then each state can have 7 children explored, 49 grandchildren, 343 great-grandchildren, etc.
            'maxStateBranchingFactor': 'Int', # Int
            # If less than this amount of packed items are improved in packingSpeedIntervalSec time, then packing computation will be stopped.
            'minItemsToPackInSpeedInterval': 'Int', # Int
            # Minimum number of groups to check for search state
            'minNumGroupsToCheck': 'Int', # Int
            # deg, minimum angle which the packing should hold until toppling.
            'minToppleAngle': 'Float', # Float
            # deg, minimum angle which the packing should hold until toppling at the bottom of the container.
            'minToppleAngleAtBottom': 'Float', # Float
            # deg, minimum angle which the packing should hold until toppling at top edge of the container.
            'minToppleAngleAtTop': 'Float', # Float
            # multiplier for "minToppleAngle", "minToppleAngleAtBottom", "minToppleAngleAtTop" to have a stricter topple angle in directions where packing container does not have wall.
            'minToppleAngleOpenWallMult': 'Float', # Float
            # Defines how many states per face of the item to consider after 2D placement of a group of items into a layer (plane with the same height). The bigger makes discovering more states, therefore final result might be better, but the overall search will be slower.
            'numMaxBestStatesPerFace': 'Int', # Int
            # Defines how many states per rotation of the item to consider after 2D placement of a group of items into a layer (plane with the same height). The bigger makes discovering more states, therefore final result might be better, but the overall search will be slower.
            'numMaxBestStatesPerRotation': 'Int', # Int
            # Maximum number of solutions for the 2D search to consider. Larger values make 2D packing better, but will decrease the overall search speed.
            'numMaxSolutions2DSearch': 'Int', # Int
            # If true, then will reorganize the input order depending on the results of the search.
            'outOfOrderSearch': 'Boolean', # Boolean
            # Pack formation parameters that overwrite original parameters if any object type in pack computation request is a key value of this dictionary. Key value of the dictionary must be one from objectTypeMapping.
            'packFormationParametersPerAnyObjectType': 'Any', # Any
            # Parameters that controll the packing 2D pattern automatic selection when packing pattern name is not defined.
            'packing2DPatternAutoSelection': 'Packing2DPatternSelectionInput', # Packing2DPatternSelectionInput
            # Coefficients used to prioritize the search order of items placement.
            'packingCoefficients': 'PackingCoefficientsInput', # PackingCoefficientsInput
            # Multiplier how much weight can be placed onto each item. The multiplier will be applied on (item weight * number of layers the same item can hold).
            'packingPartMaxLoadMult': 'Float', # Float
            # s, time interval during which the packing speed is checked. The speed is computed by number of packed items improvement per 1 second.
            'packingSpeedIntervalSec': 'Float', # Float
            # If true, same items will be placed nearby within the same container. (note: same items can be separated into different containers if allowMultipleContainer is true).
            'placeOnlyNearSameItem': 'Boolean', # Boolean
            # If true, then reorder packed items, so that try to place lower items at placements with targetTopZ before items with bigger placementHeight. Still preserve dependOn
            'postProcessOrdering': 'Boolean', # Boolean
            # If true, then return only the solution which can pack all items. If false, the packing state with the best score will be returned after timing out.
            'returnCompleteSolution': 'Boolean', # Boolean
            # If true, return the first candidate in 2D search (actually switches off 2D search).
            'returnFirstCandidateOn2DSearch': 'Boolean', # Boolean
            # The search mode to discover packing search states:
            # - **groupFirst**  - tries to pack the group with the highest group score frist,
            # - **layerFirst**  - tries to fill the lower layer first and then spread the filled layer.
            'searchMode3D': 'String', # String
            # The threshold ratio on how similar a newly generated placement of items should be to already found placements to ignore the newly generated placement.
            'similarityIntersectionThresh': 'Float', # Float
            # Set to true to skip pack formation validation.
            'skipPackFormationValidation': 'Boolean', # Boolean
            # s, max time to wait to improve solution after one is found.
            'solutionImproveTimeoutSec': 'Float', # Float
            # If true, stop as soon as a packing satisfying constraints is found. If false, continue computation after a solution is found to improve the found packing.
            'stopAfterFirstSolution': 'Boolean', # Boolean
            # The filling ratio that is sufficient to consider the pack as a solution. Used to speed up packing and switch to the next pack calculation.
            'sufficientFillingRate': 'Float', # Float
            # s, max time for computing a pack before giving up.
            'timeoutSec': 'Float', # Float
            # Set to true to enable packing computation and pack formation following features.
            'use': 'Boolean', # Boolean
        },

        # Part Filter Schema.
        'Packing2DPatternCandidateFilterInfo': {
            # List of barcodes to force current packing pattern. If specified and non empty, then will ignore size and mass checks.
            'barcodes': 'String', # [String]
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # kg, allowed range of case mass, inclusive.
            'mass': 'Packing2DPatternCandidateFilterInfo_Mass', # Packing2DPatternCandidateFilterInfo_Mass
            'packingPatternName': 'String', # String
            # mm, the biggest dimension of [width,depth]
            'x': 'Packing2DPatternCandidateFilterInfo_X', # Packing2DPatternCandidateFilterInfo_X
            # mm, the smallest dimension of [width,depth]
            'y': 'Packing2DPatternCandidateFilterInfo_Y', # Packing2DPatternCandidateFilterInfo_Y
            # mm, height
            'z': 'Packing2DPatternCandidateFilterInfo_Z', # Packing2DPatternCandidateFilterInfo_Z
        },

        # Part Filter Schema.
        'Packing2DPatternCandidateFilterInfoInput': {
            # List of barcodes to force current packing pattern. If specified and non empty, then will ignore size and mass checks.
            'barcodes': 'String', # [String]
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # kg, allowed range of case mass, inclusive.
            'mass': 'Packing2DPatternCandidateFilterInfoInput_Mass', # Packing2DPatternCandidateFilterInfoInput_Mass
            'packingPatternName': 'String', # String
            # mm, the biggest dimension of [width,depth]
            'x': 'Packing2DPatternCandidateFilterInfoInput_X', # Packing2DPatternCandidateFilterInfoInput_X
            # mm, the smallest dimension of [width,depth]
            'y': 'Packing2DPatternCandidateFilterInfoInput_Y', # Packing2DPatternCandidateFilterInfoInput_Y
            # mm, height
            'z': 'Packing2DPatternCandidateFilterInfoInput_Z', # Packing2DPatternCandidateFilterInfoInput_Z
        },

        # kg, allowed range of case mass, inclusive.
        'Packing2DPatternCandidateFilterInfoInput_Mass': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # mm, the biggest dimension of [width,depth]
        'Packing2DPatternCandidateFilterInfoInput_X': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # mm, the smallest dimension of [width,depth]
        'Packing2DPatternCandidateFilterInfoInput_Y': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # mm, height
        'Packing2DPatternCandidateFilterInfoInput_Z': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # kg, allowed range of case mass, inclusive.
        'Packing2DPatternCandidateFilterInfo_Mass': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # mm, the biggest dimension of [width,depth]
        'Packing2DPatternCandidateFilterInfo_X': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # mm, the smallest dimension of [width,depth]
        'Packing2DPatternCandidateFilterInfo_Y': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # mm, height
        'Packing2DPatternCandidateFilterInfo_Z': {
            'lower': 'Float', # Float
            'upper': 'Float', # Float
        },

        # Parameters that controll the packing 2D pattern automatic selection when packing pattern name is not defined.
        'Packing2DPatternSelection': {
            # List of packing 2d pattern candidates filtering information. Will be checked in the order of appearance here.
            'candidatesInfo': 'Packing2DPatternCandidateFilterInfo', # [Packing2DPatternCandidateFilterInfo]
            # Set to true to enable automatic packing pattern selection.
            'use': 'Boolean', # Boolean
            # if true and the candidate target does not satisfy any "candidatesInfo" will drop back to single SKU general pack computation, otherwise stop with a PackingComputationError.
            'useAutoPackWhenNoCandidate': 'Boolean', # Boolean
        },

        # Parameters that controll the packing 2D pattern automatic selection when packing pattern name is not defined.
        'Packing2DPatternSelectionInput': {
            # List of packing 2d pattern candidates filtering information. Will be checked in the order of appearance here.
            'candidatesInfo': 'Packing2DPatternCandidateFilterInfoInput', # [Packing2DPatternCandidateFilterInfoInput]
            # Set to true to enable automatic packing pattern selection.
            'use': 'Boolean', # Boolean
            # if true and the candidate target does not satisfy any "candidatesInfo" will drop back to single SKU general pack computation, otherwise stop with a PackingComputationError.
            'useAutoPackWhenNoCandidate': 'Boolean', # Boolean
        },

        # Coefficients used to prioritize the search order of items placement.
        'PackingCoefficients': {
            # The coefficient to prioritize packs with COM of pmass closer to the pivotCOM. Pivot of the COM is in the origin of the inner area of the container.
            'comCostCoefficient': 'Float', # Float
            # The coefficient used to prioritize states with smaller area of the container floor not filled.
            'floorEmptyCoefficient': 'Float', # Float
            # The blow up factor for footprint heuristics. The larger it is, the more valuable the footprint heuristic's value will be.
            'footprintBlowupFactor': 'Float', # Float
            # The blow up factor for heuristics in prioritization of which search state to explore first. The larger it is, the more valuable the heuristic's value will be.
            'heuristicBlowupFactor': 'Float', # Float
            # Coefficient to prioritize more spread layer. Greater means greater cost for not filled layers
            'layerNotFilledCoefficient': 'Float', # Float
            # coefficient to prioritize states with more max load possible into the container.
            'maxLoadLeftCoefficient': 'Float', # Float
            # The coefficient to penalize not packed ratio of the container. The value without coefficient could be a little bit bigger than 1.0, because of boxes streching above the walls.
            'notFilledVolumeCoefficient': 'Float', # Float
            # Coefficient to prioritize placement with smaller not supported area ratio for the search.
            'notSupportedAreaRatioCoefficient': 'Float', # Float
            # Coefficient to penalize individual pack surfaces that are not touching.
            'notTouchingRatioCoefficient': 'Float', # Float
            # The coefficient for number of layers open for packing. Usually, less not packed layers is better.
            'numNotPackedLayersCoefficient': 'Float', # Float
            # The coefficient to prioritize packs which have less unique groups not fully packed. Ignored if placeOnlyNearSameItem = False.
            'numUniqueGroupsStartedCoefficient': 'Float', # Float
            # mm (x,y,z), used to prioritize packing by x,y or z dimension. Smaller coefficient means less penalty for the size by the dimension. For example: [0.2, 0.1, 2.0] prioritizes package dimensions by y first, x second, z third. All dimensions are in packing container coordinate system.
            'packageDimensionCoefficients': 'Float', # [Float]
            # The coefficient to prioritize 2D packs with same orientation of items.
            'sameOrienation2DCoefficient': 'Float', # Float
            # The coefficient to prioritize stability.
            'stabilityCoefficient': 'Float', # Float
            # The standard deviation coefficient of the depth matrix. Used to prioritize discovering states with less heights variatione of depthMatrix.
            'stdHeightCoefficient': 'Float', # Float
            # Coefficient to penalize packages where placement touches opposite faces while placing, because such placements are more difficult and slower to execute.
            'touchingOppositeFacesCoefficient': 'Float', # Float
            # The coefficient to prioritize packs with higher packing weight score. Packing weight score is ratio between sum of packed items weight and the sum of all items weight.
            'weightCoefficient': 'Float', # Float
        },

        # Coefficients used to prioritize the search order of items placement.
        'PackingCoefficientsInput': {
            # The coefficient to prioritize packs with COM of pmass closer to the pivotCOM. Pivot of the COM is in the origin of the inner area of the container.
            'comCostCoefficient': 'Float', # Float
            # The coefficient used to prioritize states with smaller area of the container floor not filled.
            'floorEmptyCoefficient': 'Float', # Float
            # The blow up factor for footprint heuristics. The larger it is, the more valuable the footprint heuristic's value will be.
            'footprintBlowupFactor': 'Float', # Float
            # The blow up factor for heuristics in prioritization of which search state to explore first. The larger it is, the more valuable the heuristic's value will be.
            'heuristicBlowupFactor': 'Float', # Float
            # Coefficient to prioritize more spread layer. Greater means greater cost for not filled layers
            'layerNotFilledCoefficient': 'Float', # Float
            # coefficient to prioritize states with more max load possible into the container.
            'maxLoadLeftCoefficient': 'Float', # Float
            # The coefficient to penalize not packed ratio of the container. The value without coefficient could be a little bit bigger than 1.0, because of boxes streching above the walls.
            'notFilledVolumeCoefficient': 'Float', # Float
            # Coefficient to prioritize placement with smaller not supported area ratio for the search.
            'notSupportedAreaRatioCoefficient': 'Float', # Float
            # Coefficient to penalize individual pack surfaces that are not touching.
            'notTouchingRatioCoefficient': 'Float', # Float
            # The coefficient for number of layers open for packing. Usually, less not packed layers is better.
            'numNotPackedLayersCoefficient': 'Float', # Float
            # The coefficient to prioritize packs which have less unique groups not fully packed. Ignored if placeOnlyNearSameItem = False.
            'numUniqueGroupsStartedCoefficient': 'Float', # Float
            # mm (x,y,z), used to prioritize packing by x,y or z dimension. Smaller coefficient means less penalty for the size by the dimension. For example: [0.2, 0.1, 2.0] prioritizes package dimensions by y first, x second, z third. All dimensions are in packing container coordinate system.
            'packageDimensionCoefficients': 'Float', # [Float]
            # The coefficient to prioritize 2D packs with same orientation of items.
            'sameOrienation2DCoefficient': 'Float', # Float
            # The coefficient to prioritize stability.
            'stabilityCoefficient': 'Float', # Float
            # The standard deviation coefficient of the depth matrix. Used to prioritize discovering states with less heights variatione of depthMatrix.
            'stdHeightCoefficient': 'Float', # Float
            # Coefficient to penalize packages where placement touches opposite faces while placing, because such placements are more difficult and slower to execute.
            'touchingOppositeFacesCoefficient': 'Float', # Float
            # The coefficient to prioritize packs with higher packing weight score. Packing weight score is ratio between sum of packed items weight and the sum of all items weight.
            'weightCoefficient': 'Float', # Float
        },

        # Parameters for robot path planning.
        'PathPlannerParameters': {
            # Indicates whether to check for torque limits when planning.
            'dynamicsConstraintsType': 'String', # String
            # The time limit for path planning. 0 means no limits.
            'maxPlanningTime': 'Float', # Float
            # The limit for path planning iterations.
            'maxiter': 'Int', # Int
            # The name of the path planner to use.
            'pathPlannerName': 'String', # String
            # rad, The minimum step size when exploring the space when planning P2P movements
            'steplength': 'Float', # Float
        },

        # Parameters for robot path planning.
        'PathPlannerParametersInput': {
            # Indicates whether to check for torque limits when planning.
            'dynamicsConstraintsType': 'String', # String
            # The time limit for path planning. 0 means no limits.
            'maxPlanningTime': 'Float', # Float
            # The limit for path planning iterations.
            'maxiter': 'Int', # Int
            # The name of the path planner to use.
            'pathPlannerName': 'String', # String
            # rad, The minimum step size when exploring the space when planning P2P movements
            'steplength': 'Float', # Float
        },

        # Describes the pick location and properties about it to initialize the cycle.
        'PickLocationInfo': {
            # The containerId expected for this location for robot to start picking/placing. If empty, then any container Id will be accepted.
            'containerId': 'String', # String
            # The containerType expected for this location for robot to start picking/placing. If empty, then any container Type will be accepted. Types are the basic names of the URIs/filenames of the containers.
            'containerType': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The name of the Ik Parameter/Position associated with the location. Can be used for picking/placing from a specific place in the location. Usually should be with respect to the container detected.
            'ikParamName': 'String', # String
            # If the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle.
            'isContainerChanged': 'Boolean', # Boolean
            # If True and the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle. By default, it is False so that the robot does not assume the contents of the container and has to scan them.
            'isContainerEmptyOnChange': 'Boolean', # Boolean
            # The name of the 'location' object.
            'locationName': 'String', # String
        },

        # Describes the pick location and properties about it to initialize the cycle.
        'PickLocationInfoInput': {
            # The containerId expected for this location for robot to start picking/placing. If empty, then any container Id will be accepted.
            'containerId': 'String', # String
            # The containerType expected for this location for robot to start picking/placing. If empty, then any container Type will be accepted. Types are the basic names of the URIs/filenames of the containers.
            'containerType': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The name of the Ik Parameter/Position associated with the location. Can be used for picking/placing from a specific place in the location. Usually should be with respect to the container detected.
            'ikParamName': 'String', # String
            # If the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle.
            'isContainerChanged': 'Boolean', # Boolean
            # If True and the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle. By default, it is False so that the robot does not assume the contents of the container and has to scan them.
            'isContainerEmptyOnChange': 'Boolean', # Boolean
            # The name of the 'location' object.
            'locationName': 'String', # String
        },

        # Each place location info
        'PlaceLocationInfo': {
            # The containerId expected for this location for robot to start picking/placing. If empty, then any container Id will be accepted.
            'containerId': 'String', # String
            # The containerType expected for this location for robot to start picking/placing. If empty, then any container Type will be accepted. Types are the basic names of the URIs/filenames of the containers.
            'containerType': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The name of the Ik Parameter/Position associated with the location. Can be used for picking/placing from a specific place in the location. Usually should be with respect to the container detected.
            'ikParamName': 'String', # String
            # If the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle.
            'isContainerChanged': 'Boolean', # Boolean
            # If True and the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle. By default, it is False so that the robot does not assume the contents of the container and has to scan them.
            'isContainerEmptyOnChange': 'Boolean', # Boolean
            # The name of the 'location' object.
            'locationName': 'String', # String
        },

        # Each place location info
        'PlaceLocationInfoInput': {
            # The containerId expected for this location for robot to start picking/placing. If empty, then any container Id will be accepted.
            'containerId': 'String', # String
            # The containerType expected for this location for robot to start picking/placing. If empty, then any container Type will be accepted. Types are the basic names of the URIs/filenames of the containers.
            'containerType': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The name of the Ik Parameter/Position associated with the location. Can be used for picking/placing from a specific place in the location. Usually should be with respect to the container detected.
            'ikParamName': 'String', # String
            # If the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle.
            'isContainerChanged': 'Boolean', # Boolean
            # If True and the container is changing for the first time in this cycle, then expect the container to be empty. This can help reduce some computation and speed up the cycle. By default, it is False so that the robot does not assume the contents of the container and has to scan them.
            'isContainerEmptyOnChange': 'Boolean', # Boolean
            # The name of the 'location' object.
            'locationName': 'String', # String
        },

        # Information for each placement area by height.
        'PlacementAreaByHeightInfo': {
            # mm, the minimum height from the bottom of the container to the top placed item surface to apply placement area.
            'borderHeight': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The maximum X position of the placement area.
            'maxX': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The maximum Y position of the placement area.
            'maxY': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The minimum X position of the placement area.
            'minX': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The minimum Y position of the placement area.
            'minY': 'Float', # Float
        },

        # Information for each placement area by height.
        'PlacementAreaByHeightInfoInput': {
            # mm, the minimum height from the bottom of the container to the top placed item surface to apply placement area.
            'borderHeight': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The maximum X position of the placement area.
            'maxX': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The maximum Y position of the placement area.
            'maxY': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The minimum X position of the placement area.
            'minX': 'Float', # Float
            # mm, in inner container coordinates from the center of the inner container region. The minimum Y position of the placement area.
            'minY': 'Float', # Float
        },

        # Placement to rioritize placement of the dynamicgoal generated placements. Bigger coefficient means prioritize placement by the criteria. Negative means penalize. All criterias are normalized, the minimum value of the criteria is 0.0, the maximum is 1.0.
        'PlacementPriorityParameters': {
            # Coefficient to multiply the biggest possible free square after from the opposite to 0,0 corner of the container for the placement of the box.
            'biggestSquareSizeCoefficient': 'Float', # Float
            # If > 0, then the number of seconds to cutoff any new goals generated. If no goals have been generated yet, search will continue. But if goals have been generated already, then search will terminate.
            'continueSearchTimeLimit': 'Float', # Float
            # Coefficient to multiply the placement depth position from the container floor. Usually negative, to prioritize placement lower.
            'depthCoefficient': 'Float', # Float
            # Coefficient to multiply the distance from negative x, negative y corner of the destintation container.
            'distanceFrom00Coefficient': 'Float', # Float
            # Discretization step of the biggest empty square used for biggestSquareSizeCoefficient. If the dscretization step is 5 then squares of the side size 10, 11, 12, 13, 14 will be treated as the same and have the same score.
            'intBiggestSquareDiscretization': 'Int', # Int
            # Coefficient to multiply the distance from the box to the wall of the container by the smaller dimension of the container.
            'leftoverMinContainerDimensionCoefficient': 'Float', # Float
            # Coefficient to multiply the minimum distance from the box to walls of the container.
            'minDistanceToWallsCoefficient': 'Float', # Float
            # Discretization for touching walls ratio, should be 0.01..1.0. Discretization 0.1 means that touching if the 0.1..0.1999999 of box face touching wall will be treated as the same score.
            'ratioTouchingWallsDiscretization': 'Float', # Float
            # Set to true to enable placement priority score function.
            'use': 'Boolean', # Boolean
            # Coefficient to prioritize touching walls and/or other placed objects.
            'wallTouchingCoefficient': 'Float', # Float
        },

        # Placement to rioritize placement of the dynamicgoal generated placements. Bigger coefficient means prioritize placement by the criteria. Negative means penalize. All criterias are normalized, the minimum value of the criteria is 0.0, the maximum is 1.0.
        'PlacementPriorityParametersInput': {
            # Coefficient to multiply the biggest possible free square after from the opposite to 0,0 corner of the container for the placement of the box.
            'biggestSquareSizeCoefficient': 'Float', # Float
            # If > 0, then the number of seconds to cutoff any new goals generated. If no goals have been generated yet, search will continue. But if goals have been generated already, then search will terminate.
            'continueSearchTimeLimit': 'Float', # Float
            # Coefficient to multiply the placement depth position from the container floor. Usually negative, to prioritize placement lower.
            'depthCoefficient': 'Float', # Float
            # Coefficient to multiply the distance from negative x, negative y corner of the destintation container.
            'distanceFrom00Coefficient': 'Float', # Float
            # Discretization step of the biggest empty square used for biggestSquareSizeCoefficient. If the dscretization step is 5 then squares of the side size 10, 11, 12, 13, 14 will be treated as the same and have the same score.
            'intBiggestSquareDiscretization': 'Int', # Int
            # Coefficient to multiply the distance from the box to the wall of the container by the smaller dimension of the container.
            'leftoverMinContainerDimensionCoefficient': 'Float', # Float
            # Coefficient to multiply the minimum distance from the box to walls of the container.
            'minDistanceToWallsCoefficient': 'Float', # Float
            # Discretization for touching walls ratio, should be 0.01..1.0. Discretization 0.1 means that touching if the 0.1..0.1999999 of box face touching wall will be treated as the same score.
            'ratioTouchingWallsDiscretization': 'Float', # Float
            # Set to true to enable placement priority score function.
            'use': 'Boolean', # Boolean
            # Coefficient to prioritize touching walls and/or other placed objects.
            'wallTouchingCoefficient': 'Float', # Float
        },

        # A robot configuration defined via joint values.
        'PositionConfiguration': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The unique identifier of the PositionConfiguration
            'id': 'String', # String!
            # The joint states that make up the PositionConfiguration
            'jointConfigurationStates': 'JointConfigurationState', # [JointConfigurationState!]
            # The non-unique name of the PositionConfiguration
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
        },

        # A robot configuration defined via joint values.
        'PositionConfigurationInput': {
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The unique identifier of the PositionConfiguration
            'id': 'String', # String
            # The joint states that make up the PositionConfiguration
            'jointConfigurationStates': 'JointConfigurationStateInput', # [JointConfigurationStateInput!]
            # The non-unique name of the PositionConfiguration
            'name': 'String', # String
        },

        # Post cycle execution and conveyor parameters.
        'PostCycleExecutionConfigurations': {
            # The maximum allowed speed for measuring trajectory
            'circularMeasuringDistanceSpeed': 'Float', # Float
            # Length of the conveyor's placement compartment (mm)
            'compartmentLength': 'Float', # Float
            # Length of the conveyor (mm)
            'conveyorLength': 'Float', # Float
            # Speed of the conveyor (mm/s)
            'conveyorSpeed': 'Float', # Float
            # Maximum distance from the sensor to the object (mm)
            'distSensorMaxDist': 'Float', # Float
            # Minimum allowed distance from the sensor to the object in mm
            'distSensorMinDist': 'Float', # Float
            # Name of the distance sensor body in environment
            'distSensorName': 'String', # String
            # Offset from the sensor to the placement position by Z axis (mm)
            'distSensorToPlaceOffset': 'Float', # Float
            # COM 2 port: URI = serial:///dev/ttyS1?baud=9600&bytesize=8&parity=N&stopbits=1&timeout=0.02&offset=600&type=keyenceIL1000
            'distSensorUri': 'String', # String
            # Ratio of encoder pulses to mm, how much pulses equivalent to 1 mm of conveyor belt
            'encoderRatio': 'Float', # Float
            # Delay of the reading value from the conveyor encoder in seconds
            'encoderReadDelay': 'Float', # Float
            # The position of the placement sensor from the beginning of the conveyor belt from the encoder sensor (mm)
            'fLineSensorOffset': 'Float', # Float
            # How much to constraint the max accelerations so that parts do not fly out of hand. 1.0 means no constraint, smaller value makes movements slower
            'grabbingaccelmult': 'Float', # Float
            # bodies specified in the list will be ignored for collision checking while placing on the conveyor belt
            'ignorePlacementBodyNames': 'String', # [String]
            # The deceleration (mm/s) by Z axis with which robot can decelarate by Z axis during the placement of the item on the conveyor. If it's big, the part could fall out of the hand
            'maxPlaceZDeceleration': 'Float', # Float
            # Radius of the circle (mm) which the manipulator uses for measuring trajectory
            'measuringDistancsRadius': 'Float', # Float
            # If the box has width/depth less than these dimensions (mm), then robot will circle around the sensor in order to make sure it scanned the bottom.
            'minBoxCheckThreshold': 'Float', # Float
            # If the sensor measures any target heights lower than this value (mm), will clamp it to this value
            'minTargetHeight': 'Float', # Float
            # If target height is less than this value (mm), then will skip the sensor measurement and go directly to placing the part down
            'minTargetHeightForSensor': 'Float', # Float
            # Name of the IK parameter on the destination body
            'placename': 'String', # String
            # Type of the post cycle execution.
            'postCycleType': 'String', # String
            # The position of the robot from the beginning of the conveyor belt from the encoder sensor (mm)
            'robotOffset': 'Float', # Float
            # If true, will use distance sensor measurements to get the box height.
            'useDistSensor': 'Boolean', # Boolean
            # The distance (mm) to travel in order to acceleration at conveyor speed along its movement
            'xacceloffset': 'Float', # Float
            # The distance (mm) to travel when going down to place to the conveyor
            'xoffset': 'Float', # Float
            # The distance (mm) to start from the place point and go down, this has to be bigger or equal to the maximum height of the item on the conveyor
            'zoffset': 'Float', # Float
        },

        # Post cycle execution and conveyor parameters.
        'PostCycleExecutionConfigurationsInput': {
            # The maximum allowed speed for measuring trajectory
            'circularMeasuringDistanceSpeed': 'Float', # Float
            # Length of the conveyor's placement compartment (mm)
            'compartmentLength': 'Float', # Float
            # Length of the conveyor (mm)
            'conveyorLength': 'Float', # Float
            # Speed of the conveyor (mm/s)
            'conveyorSpeed': 'Float', # Float
            # Maximum distance from the sensor to the object (mm)
            'distSensorMaxDist': 'Float', # Float
            # Minimum allowed distance from the sensor to the object in mm
            'distSensorMinDist': 'Float', # Float
            # Name of the distance sensor body in environment
            'distSensorName': 'String', # String
            # Offset from the sensor to the placement position by Z axis (mm)
            'distSensorToPlaceOffset': 'Float', # Float
            # COM 2 port: URI = serial:///dev/ttyS1?baud=9600&bytesize=8&parity=N&stopbits=1&timeout=0.02&offset=600&type=keyenceIL1000
            'distSensorUri': 'String', # String
            # Ratio of encoder pulses to mm, how much pulses equivalent to 1 mm of conveyor belt
            'encoderRatio': 'Float', # Float
            # Delay of the reading value from the conveyor encoder in seconds
            'encoderReadDelay': 'Float', # Float
            # The position of the placement sensor from the beginning of the conveyor belt from the encoder sensor (mm)
            'fLineSensorOffset': 'Float', # Float
            # How much to constraint the max accelerations so that parts do not fly out of hand. 1.0 means no constraint, smaller value makes movements slower
            'grabbingaccelmult': 'Float', # Float
            # bodies specified in the list will be ignored for collision checking while placing on the conveyor belt
            'ignorePlacementBodyNames': 'String', # [String]
            # The deceleration (mm/s) by Z axis with which robot can decelarate by Z axis during the placement of the item on the conveyor. If it's big, the part could fall out of the hand
            'maxPlaceZDeceleration': 'Float', # Float
            # Radius of the circle (mm) which the manipulator uses for measuring trajectory
            'measuringDistancsRadius': 'Float', # Float
            # If the box has width/depth less than these dimensions (mm), then robot will circle around the sensor in order to make sure it scanned the bottom.
            'minBoxCheckThreshold': 'Float', # Float
            # If the sensor measures any target heights lower than this value (mm), will clamp it to this value
            'minTargetHeight': 'Float', # Float
            # If target height is less than this value (mm), then will skip the sensor measurement and go directly to placing the part down
            'minTargetHeightForSensor': 'Float', # Float
            # Name of the IK parameter on the destination body
            'placename': 'String', # String
            # Type of the post cycle execution.
            'postCycleType': 'String', # String
            # The position of the robot from the beginning of the conveyor belt from the encoder sensor (mm)
            'robotOffset': 'Float', # Float
            # If true, will use distance sensor measurements to get the box height.
            'useDistSensor': 'Boolean', # Boolean
            # The distance (mm) to travel in order to acceleration at conveyor speed along its movement
            'xacceloffset': 'Float', # Float
            # The distance (mm) to travel when going down to place to the conveyor
            'xoffset': 'Float', # Float
            # The distance (mm) to start from the place point and go down, this has to be bigger or equal to the maximum height of the item on the conveyor
            'zoffset': 'Float', # Float
        },

        # Describes where to place predicted target before detection results.
        'PredictDetectionInfo': {
            # if true, will align the longest axis of the predicted body to the x direction of the ik parameter.
            'alignLongAxisToX': 'Boolean', # Boolean
            # if true, will align the longest axis of the predicted body to the Y direction of the ik parameter. Used only if alignLongAxisToX is False or not defined.
            'alignLongAxisToY': 'Boolean', # Boolean
            # if true, allows approach to the predicted target (except linear movement) even if a real target is not yet detected. if false, wait until the real target is detected, no approach movement allowed.
            'allowPredictedMovementBeforeDetection': 'Boolean', # Boolean
            # ratio of center of box offset from the ik parameter.
            'boxLocalOffset': 'Float', # [Float]
            # information about predicted target placements
            'placeInfos': 'PredictedPlaceInfo', # [PredictedPlaceInfo]
            # mm, The size to use to validate if the predicted target is close enough to run the cycle with.
            'sizeThreshXYZ': 'Float', # [Float]
            # Set to true to enable prediction of detection.
            'use': 'Boolean', # Boolean
            # if true fills inner container region with an obstacle to prevent collision with a real target if the position of predicted target differs a lot
            'useContainerRegionForPadding': 'Boolean', # Boolean
            # If True, only uses the existing target, does not create a new predictive target.
            'useExistingTargetOnly': 'Boolean', # Boolean
        },

        # Describes where to place predicted target before detection results.
        'PredictDetectionInfoInput': {
            # if true, will align the longest axis of the predicted body to the x direction of the ik parameter.
            'alignLongAxisToX': 'Boolean', # Boolean
            # if true, will align the longest axis of the predicted body to the Y direction of the ik parameter. Used only if alignLongAxisToX is False or not defined.
            'alignLongAxisToY': 'Boolean', # Boolean
            # if true, allows approach to the predicted target (except linear movement) even if a real target is not yet detected. if false, wait until the real target is detected, no approach movement allowed.
            'allowPredictedMovementBeforeDetection': 'Boolean', # Boolean
            # ratio of center of box offset from the ik parameter.
            'boxLocalOffset': 'Float', # [Float]
            # information about predicted target placements
            'placeInfos': 'PredictedPlaceInfoInput', # [PredictedPlaceInfoInput]
            # mm, The size to use to validate if the predicted target is close enough to run the cycle with.
            'sizeThreshXYZ': 'Float', # [Float]
            # Set to true to enable prediction of detection.
            'use': 'Boolean', # Boolean
            # if true fills inner container region with an obstacle to prevent collision with a real target if the position of predicted target differs a lot
            'useContainerRegionForPadding': 'Boolean', # Boolean
            # If True, only uses the existing target, does not create a new predictive target.
            'useExistingTargetOnly': 'Boolean', # Boolean
        },

        # Information about predicted placement.
        'PredictedPlaceInfo': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Should be in the format instobjectname/ikparamname
            'ikParamName': 'String', # String
            'sourcecontainername': 'String', # String
        },

        # Information about predicted placement.
        'PredictedPlaceInfoInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Should be in the format instobjectname/ikparamname
            'ikParamName': 'String', # String
            'sourcecontainername': 'String', # String
        },

        # ITL program.
        'Program': {
            # Last author who modified the program.
            'author': 'String', # String!
            # Timestamp when the program was created.
            'createdAt': 'DateTime', # DateTime
            # Files in the program.
            'files': 'ProgramFile', # [ProgramFile!]
            # Reference ID of the HEAD.
            'headReferenceId': 'String', # String
            # The globally unique ID of the program.
            'id': 'String', # String!
            # Timestamp when the program was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # References in the program.
            'references': 'ProgramReference', # [ProgramReference!]
        },

        'ProgramFile': {
            # Content of the file.
            'content': 'Data', # Data!
            # Timestamp when the file was created.
            'createdAt': 'DateTime', # DateTime
            # Path of the file in the repository.
            'id': 'String', # String!
            # Mode of the file, only acceptable values are: 0100644 for regular files, 0100755 for executable files, 0120000 for symlinks, and 0160000 for submodules.
            'mode': 'Int', # Int!
            # Timestamp when the file was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # SHA-1 hash of the object that contains this file.
            'objectId': 'String', # String!
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Size of the content.
            'size': 'Int', # Int!
        },

        # A named reference pointing to a commit object.
        'ProgramReference': {
            # Timestamp when the program was created.
            'createdAt': 'DateTime', # DateTime
            # The globally unique ID of the reference.
            'id': 'String', # String!
            # Timestamp when the program was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # Object ID that the reference is pointing to.
            'objectId': 'String', # String!
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
        },

        # Configuration of Canon RV.
        'RVSensorConfiguration': {
            # The number of Region Of Interest.
            'ROINum': 'Int', # Int
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # If true, check time drift between RV vision PC and Mujin controller using a NTP server in RV vision PC.
            'sensorHasNTPServer': 'Boolean', # Boolean
            # The IP address of RV vision PC.
            'serverIp': 'String', # String
            # The Port number of RV vision PC.
            'serverPort': 'Int', # Int
            # The task ID of RV. Task ID is calculated in following steps.
            # 1. If used container names are matched with entry in taskIDContainerMapping, taskID in taskIDContainerMapping is used.
            # 2. If used target name is matched with entry in recognitionWorkConfig, taskID in recognitionWorkConfig is used.
            # 3. taskID in sensorStreamerConfig is used.
            'taskID': 'Int', # Int
            # Override taskID if used source or dest container names matched with containername.
            'taskIDContainerMapping': 'RVSensorTaskIDContainerNameMapping', # [RVSensorTaskIDContainerNameMapping]
        },

        # Configuration of Canon RV.
        'RVSensorConfigurationInput': {
            # The number of Region Of Interest.
            'ROINum': 'Int', # Int
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # If true, check time drift between RV vision PC and Mujin controller using a NTP server in RV vision PC.
            'sensorHasNTPServer': 'Boolean', # Boolean
            # The IP address of RV vision PC.
            'serverIp': 'String', # String
            # The Port number of RV vision PC.
            'serverPort': 'Int', # Int
            # The task ID of RV. Task ID is calculated in following steps.
            # 1. If used container names are matched with entry in taskIDContainerMapping, taskID in taskIDContainerMapping is used.
            # 2. If used target name is matched with entry in recognitionWorkConfig, taskID in recognitionWorkConfig is used.
            # 3. taskID in sensorStreamerConfig is used.
            'taskID': 'Int', # Int
            # Override taskID if used source or dest container names matched with containername.
            'taskIDContainerMapping': 'RVSensorTaskIDContainerNameMappingInput', # [RVSensorTaskIDContainerNameMappingInput]
        },

        # Override taskID if used source or dest container names matched with containername.
        'RVSensorTaskIDContainerNameMapping': {
            # The name of container.
            'containerName': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The task ID of RV.
            'taskID': 'Int', # Int
        },

        # Override taskID if used source or dest container names matched with containername.
        'RVSensorTaskIDContainerNameMappingInput': {
            # The name of container.
            'containerName': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The task ID of RV.
            'taskID': 'Int', # Int
        },

        # Info structure for maintaining grasp parameters for random box picking. Used when picking up randomized boxes (targetIsRandomBox is True).
        'RandomBoxInfo': {
            # A bit mask of the up axes of the target that should be considered when placing. 1 is X, 2 is Y, 4 is Z, 7 is all. By default, random boxes are created in the environment such that the Z axis face (positive) is supposed to be grasped.
            'allowedPlacementOrientations': 'Int', # Int
            # degrees, max angle of the tool to the box surface that is allowed for pickup.
            'boxDirAngle': 'Float', # Float
            # Priorities of the faces to pick up the box.
            'dictFacePriorities': 'FacePickUpPriorities', # FacePickUpPriorities
            # kg, specifies mass of random box if vision does not send a mass with it.
            'objectMass': 'Float', # Float
            # mm, full size of random box. Always detected z up.
            'objectSize': 'Float', # [Float]
            # Specifies where to place the origin of the incoming box detections. By default, this is [0,0,1], which means the origin will be at the center of the +Z (top) face.
            'randomBoxOrigin': 'Float', # [Float]
            # Step of 6D grasp rotation around z axis in degrees, defaults to 45 degrees.
            'rollStepDegree': 'Float', # Float
            'scaleObjectWeightByTransferSpeedMult': 'Boolean', # Boolean
            # mm (x,y,z) for rounding up incoming boxes from the detector. This allows previous grasping models to be cached and re-used since the sizes will be multiples of the current precision.
            'sizePrecisionXYZ': 'Float', # [Float]
            # Valid if 'toolTranslationOffsets' are specified. Priority multiplier added to the grasp priority for the distance between tool translation offset and tool translation without offset. If set to 0 then no tool offset priority modifier will be applied.
            'toolOffsetDistancePriorityMult': 'Float', # Float
            # mm, (x,y,z)
            'toolTranslationOffsets': 'Float', # [[Float]]
            # List of faces of the box used to pick it up
            'usefaces': 'String', # [String]
        },

        # Info structure for maintaining grasp parameters for random box picking. Used when picking up randomized boxes (targetIsRandomBox is True).
        'RandomBoxInfoInput': {
            # A bit mask of the up axes of the target that should be considered when placing. 1 is X, 2 is Y, 4 is Z, 7 is all. By default, random boxes are created in the environment such that the Z axis face (positive) is supposed to be grasped.
            'allowedPlacementOrientations': 'Int', # Int
            # degrees, max angle of the tool to the box surface that is allowed for pickup.
            'boxDirAngle': 'Float', # Float
            # Priorities of the faces to pick up the box.
            'dictFacePriorities': 'FacePickUpPrioritiesInput', # FacePickUpPrioritiesInput
            # kg, specifies mass of random box if vision does not send a mass with it.
            'objectMass': 'Float', # Float
            # mm, full size of random box. Always detected z up.
            'objectSize': 'Float', # [Float]
            # Specifies where to place the origin of the incoming box detections. By default, this is [0,0,1], which means the origin will be at the center of the +Z (top) face.
            'randomBoxOrigin': 'Float', # [Float]
            # Step of 6D grasp rotation around z axis in degrees, defaults to 45 degrees.
            'rollStepDegree': 'Float', # Float
            'scaleObjectWeightByTransferSpeedMult': 'Boolean', # Boolean
            # mm (x,y,z) for rounding up incoming boxes from the detector. This allows previous grasping models to be cached and re-used since the sizes will be multiples of the current precision.
            'sizePrecisionXYZ': 'Float', # [Float]
            # Valid if 'toolTranslationOffsets' are specified. Priority multiplier added to the grasp priority for the distance between tool translation offset and tool translation without offset. If set to 0 then no tool offset priority modifier will be applied.
            'toolOffsetDistancePriorityMult': 'Float', # Float
            # mm, (x,y,z)
            'toolTranslationOffsets': 'Float', # [[Float]]
            # List of faces of the box used to pick it up
            'usefaces': 'String', # [String]
        },

        # Parameters of an OpenRAVE body.
        'ReadableInterfaces': {
            # Parameters of an OpenRAVE 'Body'
            'bodyparameters': 'BodyParameters', # BodyParameters
            'extendable': 'Any', # Any
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # A set of parameters that constrain the motion of a robot, e.g. maximum tool (cartesian) speed and acceleration.
            # Also includes information about the robot model and maker.
            # These parameters are used only during planning - the values in SafetySpeedConstraintsInfo are used to limit speed during execution.
            'robotmotionparameters': 'RobotMotionParameters', # RobotMotionParameters
        },

        # Parameters of an OpenRAVE body.
        'ReadableInterfacesInput': {
            # Parameters of an OpenRAVE 'Body'
            'bodyparameters': 'BodyParametersInput', # BodyParametersInput
            'extendable': 'Any', # Any
            # A set of parameters that constrain the motion of a robot, e.g. maximum tool (cartesian) speed and acceleration.
            # Also includes information about the robot model and maker.
            # These parameters are used only during planning - the values in SafetySpeedConstraintsInfo are used to limit speed during execution.
            'robotmotionparameters': 'RobotMotionParametersInput', # RobotMotionParametersInput
        },

        # Configuration of restricting label orientation of placed items. labelerDirection has to be defined for restriction to be applied.
        'RestrictLabelOrientationInfo': {
            # Allowed label orientations after placing an item in dest container. Works only when mode is 'specifyAllowedOrientations'.
            'allowedOrientations': 'Float', # [[Float]]
            # Coordinates in which to restrict orientations of labels (container or global). Works only when mode is 'specifyAllowedOrientations'.
            'coordinates': 'String', # String
            # Mode by which to restrict label orientation.
            #                 If 'specifyAllowedOrientations', then labels will be facing only in orientations specified by coordinates and allowedOrientations.
            #                 If 'allowOnlyFacingOutside', then only orientations facing outside of the cage will be allowed.
            'mode': 'String', # String
            # Restrict orientations of items after placing in dest container
            'use': 'Boolean', # Boolean
        },

        # Configuration of restricting label orientation of placed items. labelerDirection has to be defined for restriction to be applied.
        'RestrictLabelOrientationInfoInput': {
            # Allowed label orientations after placing an item in dest container. Works only when mode is 'specifyAllowedOrientations'.
            'allowedOrientations': 'Float', # [[Float]]
            # Coordinates in which to restrict orientations of labels (container or global). Works only when mode is 'specifyAllowedOrientations'.
            'coordinates': 'String', # String
            # Mode by which to restrict label orientation.
            #                 If 'specifyAllowedOrientations', then labels will be facing only in orientations specified by coordinates and allowedOrientations.
            #                 If 'allowOnlyFacingOutside', then only orientations facing outside of the cage will be allowed.
            'mode': 'String', # String
            # Restrict orientations of items after placing in dest container
            'use': 'Boolean', # Boolean
        },

        # Revision of an environment, contains backward and forward differences.
        'Revision': {
            'author': 'String', # String!
            # An OpenRAVE Environment
            'backward': 'Environment', # Environment
            'createdAt': 'DateTime', # DateTime
            # An OpenRAVE Environment
            'forward': 'Environment', # Environment
            'id': 'Int', # Int!
            'message': 'String', # String
            'modifiedAt': 'DateTime', # DateTime
        },

        'RobotBridgesConfiguration': {
            # Last author who modified the configuration.
            'author': 'String', # String!
            # Timestamp when the configuration was created.
            'createdAt': 'DateTime', # DateTime
            'devices': 'DeviceConfiguration', # [DeviceConfiguration]
            'grippers': 'GripperConfiguration', # [GripperConfiguration]
            # ID of the configuration.
            'id': 'String', # String!
            # Current locale setting, such as "en_US.UTF-8".
            'locale': 'String', # String
            # Timestamp when the configuration was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # For linking the imported configuration file to a file in the configuration library that is part of the runtime image.
            'referenceFilename': 'String', # String
            # The ID of the parent configuration of this configuration. Fields that are undefined in this configuration will be taken from the parent (recursively).
            'referenceId': 'String', # String
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Latest revision id of the configuration.
            'revisionId': 'Int', # Int!
            'robots': 'RobotConfiguration', # [RobotConfiguration]
            # URI of the scene file to load.
            'sceneuri': 'String', # String
        },

        'RobotBridgesConfigurationInput': {
            'devices': 'Any', # [Any]
            'grippers': 'Any', # [Any]
            # ID of the configuration.
            'id': 'String', # String
            # Current locale setting, such as "en_US.UTF-8".
            'locale': 'String', # String
            # For linking the imported configuration file to a file in the configuration library that is part of the runtime image.
            'referenceFilename': 'String', # String
            # The ID of the parent configuration of this configuration. Fields that are undefined in this configuration will be taken from the parent (recursively).
            'referenceId': 'String', # String
            'robots': 'Any', # [Any]
            # URI of the scene file to load.
            'sceneuri': 'String', # String
        },

        'RobotConfiguration': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Name of the robot bridge to load
            'robotBridgeType': 'String', # String
            # ID of the robot defined in the scene
            'robotname': 'String', # String
            # Set to false to disable robot.
            'use': 'Boolean', # Boolean
        },

        # A set of parameters that constrain the motion of a robot, e.g. maximum tool (cartesian) speed and acceleration.
        # Also includes information about the robot model and maker.
        # These parameters are used only during planning - the values in SafetySpeedConstraintsInfo are used to limit speed during execution.
        'RobotMotionParameters': {
            'controllerDOFMults': 'Float', # [Float!]
            'controllerDOFOrder': 'Int', # [Int!]
            'controllerTimestep': 'Float', # Float
            'dynamicsConstraintsType': 'String', # String
            # A named parameter holding an array of float values
            'floatParameters': 'FloatsParameter', # [FloatsParameter!]
            'ikTypeName': 'String', # String
            # A named parameter holding an array of integer values
            'intParameters': 'IntsParameter', # [IntsParameter!]
            'maxToolAccelRotation': 'Float', # Float
            'maxToolAccelTranslation': 'Float', # Float
            'maxToolSpeedRotation': 'Float', # Float
            'maxToolSpeedTranslation': 'Float', # Float
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            'robotController': 'String', # String
            'robotLanguage': 'String', # String
            'robotMaker': 'String', # String
            'robotSimulationFile': 'String', # String
            'robotType': 'String', # String
            # Safety-relevant tool speed limits.
            # 
            # This limits the robot speed during execution, so that the robot can be slowed down when e.g. a light curtain detects a human in the workspace. This speed limit only affects execution, not planning - use the RobotMotionParameters to affect the planning result.
            'safetySpeedConstraintsInfo': 'SafetySpeedConstraintsInfo', # SafetySpeedConstraintsInfo
            # A named parameter holding an array of string values
            'stringParameters': 'StringsParameter', # [StringsParameter!]
        },

        # A set of parameters that constrain the motion of a robot, e.g. maximum tool (cartesian) speed and acceleration.
        # Also includes information about the robot model and maker.
        # These parameters are used only during planning - the values in SafetySpeedConstraintsInfo are used to limit speed during execution.
        'RobotMotionParametersInput': {
            'controllerDOFMults': 'Float', # [Float!]
            'controllerDOFOrder': 'Int', # [Int!]
            'controllerTimestep': 'Float', # Float
            'dynamicsConstraintsType': 'String', # String
            # A named parameter holding an array of float values
            'floatParameters': 'FloatsParameterInput', # [FloatsParameterInput!]
            'ikTypeName': 'String', # String
            # A named parameter holding an array of integer values
            'intParameters': 'IntsParameterInput', # [IntsParameterInput!]
            'maxToolAccelRotation': 'Float', # Float
            'maxToolAccelTranslation': 'Float', # Float
            'maxToolSpeedRotation': 'Float', # Float
            'maxToolSpeedTranslation': 'Float', # Float
            'robotController': 'String', # String
            'robotLanguage': 'String', # String
            'robotMaker': 'String', # String
            'robotSimulationFile': 'String', # String
            'robotType': 'String', # String
            # Safety-relevant tool speed limits.
            # 
            # This limits the robot speed during execution, so that the robot can be slowed down when e.g. a light curtain detects a human in the workspace. This speed limit only affects execution, not planning - use the RobotMotionParameters to affect the planning result.
            'safetySpeedConstraintsInfo': 'SafetySpeedConstraintsInfoInput', # SafetySpeedConstraintsInfoInput
            # A named parameter holding an array of string values
            'stringParameters': 'StringsParameterInput', # [StringsParameterInput!]
        },

        # Configuration of each Keyence SR barcode scanner.
        'SRBarcodeScanner': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Configuration of FTP Server
            'ftpServerConfig': 'SensorStreamerFTPServerConfiguration', # SensorStreamerFTPServerConfiguration
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Specific parameters of Keyence SR.
            'parameters': 'SRBarcodeScannerParameters', # SRBarcodeScannerParameters
            # The IP addres of Keyence SR sensor.
            'serverIp': 'String', # String
            # The port number of Keyence SR sensor. The default port number is 9004.
            'serverPort': 'Int', # Int
            # If false, this sensor is ignored and not initialized.
            'use': 'Boolean', # Boolean
        },

        # Parameters of capture
        'SRBarcodeScannerCaptureParameters': {
            # Specify in units of ms between 0-10
            'exposure': 'String', # String
            # Specify between 0-240
            'gain': 'Int', # Int
        },

        # Parameters of capture
        'SRBarcodeScannerCaptureParametersInput': {
            # Specify in units of ms between 0-10
            'exposure': 'String', # String
            # Specify between 0-240
            'gain': 'Int', # Int
        },

        # Parameters of detection
        'SRBarcodeScannerDetectionParameters': {
            # Specify in units of 10ms between 10-2550
            'duration': 'Int', # Int
            # If enabled, barcode with narrow bar smaller than threshold (ppcThreshold) is filtered out
            'enablePpcFiltering': 'Boolean', # Boolean
            # Specify between 1-128
            'number': 'Int', # Int
            # PPC: a value indicating how many pixels one of cells making up the two-dimensional code is, range is between 0.5-1.5
            'ppcThreshold': 'Float', # Float
            # Allow reduced detection count or not
            'singleDetectionSuccess': 'Boolean', # Boolean
            # Code type to detect
            'type': 'String', # [String]
        },

        # Parameters of detection
        'SRBarcodeScannerDetectionParametersInput': {
            # Specify in units of 10ms between 10-2550
            'duration': 'Int', # Int
            # If enabled, barcode with narrow bar smaller than threshold (ppcThreshold) is filtered out
            'enablePpcFiltering': 'Boolean', # Boolean
            # Specify between 1-128
            'number': 'Int', # Int
            # PPC: a value indicating how many pixels one of cells making up the two-dimensional code is, range is between 0.5-1.5
            'ppcThreshold': 'Float', # Float
            # Allow reduced detection count or not
            'singleDetectionSuccess': 'Boolean', # Boolean
            # Code type to detect
            'type': 'String', # [String]
        },

        # Configuration of each Keyence SR barcode scanner.
        'SRBarcodeScannerInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Configuration of FTP Server
            'ftpServerConfig': 'SensorStreamerFTPServerConfigurationInput', # SensorStreamerFTPServerConfigurationInput
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Specific parameters of Keyence SR.
            'parameters': 'SRBarcodeScannerParametersInput', # SRBarcodeScannerParametersInput
            # The IP addres of Keyence SR sensor.
            'serverIp': 'String', # String
            # The port number of Keyence SR sensor. The default port number is 9004.
            'serverPort': 'Int', # Int
            # If false, this sensor is ignored and not initialized.
            'use': 'Boolean', # Boolean
        },

        # Parameters of output data besides detected code string
        'SRBarcodeScannerOutputDataParameters': {
            # If enabled, SnapImage can be supported
            'filename': 'Boolean', # Boolean
        },

        # Parameters of output data besides detected code string
        'SRBarcodeScannerOutputDataParametersInput': {
            # If enabled, SnapImage can be supported
            'filename': 'Boolean', # Boolean
        },

        # Parameters of output image
        'SRBarcodeScannerOutputImageParameters': {
            # Specify "JPEG" or "BMP"
            'format': 'String', # String
            # Specify between 1-10
            'jpegQuality': 'Int', # Int
        },

        # Parameters of output image
        'SRBarcodeScannerOutputImageParametersInput': {
            # Specify "JPEG" or "BMP"
            'format': 'String', # String
            # Specify between 1-10
            'jpegQuality': 'Int', # Int
        },

        # Specific parameters of Keyence SR.
        'SRBarcodeScannerParameters': {
            # Parameters of capture
            'Capture': 'SRBarcodeScannerCaptureParameters', # SRBarcodeScannerCaptureParameters
            # Parameters of detection
            'Detection': 'SRBarcodeScannerDetectionParameters', # SRBarcodeScannerDetectionParameters
            # Parameters of output image
            'Image': 'SRBarcodeScannerOutputImageParameters', # SRBarcodeScannerOutputImageParameters
            # Parameters of output data besides detected code string
            'Output': 'SRBarcodeScannerOutputDataParameters', # SRBarcodeScannerOutputDataParameters
            # Parameters of reading behavior
            'Reading': 'SRBarcodeScannerReadingParameters', # SRBarcodeScannerReadingParameters
        },

        # Specific parameters of Keyence SR.
        'SRBarcodeScannerParametersInput': {
            # Parameters of capture
            'Capture': 'SRBarcodeScannerCaptureParametersInput', # SRBarcodeScannerCaptureParametersInput
            # Parameters of detection
            'Detection': 'SRBarcodeScannerDetectionParametersInput', # SRBarcodeScannerDetectionParametersInput
            # Parameters of output image
            'Image': 'SRBarcodeScannerOutputImageParametersInput', # SRBarcodeScannerOutputImageParametersInput
            # Parameters of output data besides detected code string
            'Output': 'SRBarcodeScannerOutputDataParametersInput', # SRBarcodeScannerOutputDataParametersInput
            # Parameters of reading behavior
            'Reading': 'SRBarcodeScannerReadingParametersInput', # SRBarcodeScannerReadingParametersInput
        },

        # Parameters of reading behavior
        'SRBarcodeScannerReadingParameters': {
            # Specify in units of ms between 0-255
            'burstInterval': 'Int', # Int
            # Specify in units of ms between 10-1000
            'decodeTimeout': 'Int', # Int
            # Specify between 0-99
            'matchingLevelThreshold': 'Int', # Int
            # Specify "Single" or "Burst"
            'mode': 'String', # String
        },

        # Parameters of reading behavior
        'SRBarcodeScannerReadingParametersInput': {
            # Specify in units of ms between 0-255
            'burstInterval': 'Int', # Int
            # Specify in units of ms between 10-1000
            'decodeTimeout': 'Int', # Int
            # Specify between 0-99
            'matchingLevelThreshold': 'Int', # Int
            # Specify "Single" or "Burst"
            'mode': 'String', # String
        },

        # Configuration of Keyence SR barcode scanner.
        'SRSensorConfiguration': {
            # List of available SR sensors.
            'sensorList': 'SRBarcodeScanner', # [SRBarcodeScanner]
        },

        # Configuration of Keyence SR barcode scanner.
        'SRSensorConfigurationInput': {
            # List of available SR sensors.
            'sensorList': 'SRBarcodeScannerInput', # [SRBarcodeScannerInput]
        },

        # Safety-relevant tool speed limits.
        # 
        # This limits the robot speed during execution, so that the robot can be slowed down when e.g. a light curtain detects a human in the workspace. This speed limit only affects execution, not planning - use the RobotMotionParameters to affect the planning result.
        'SafetySpeedConstraintsInfo': {
            # The cartesian speed limit for a tool.
            'speedLimitForToolNames': 'SpeedLimitForToolName', # [SpeedLimitForToolName!]!
            # if omitted, is SafetySpeedConstraintsInfo in effect by default? if so, need the tri-state
            'use': 'Boolean', # Boolean
        },

        # Safety-relevant tool speed limits.
        # 
        # This limits the robot speed during execution, so that the robot can be slowed down when e.g. a light curtain detects a human in the workspace. This speed limit only affects execution, not planning - use the RobotMotionParameters to affect the planning result.
        'SafetySpeedConstraintsInfoInput': {
            # The cartesian speed limit for a tool.
            'speedLimitForToolNames': 'SpeedLimitForToolNameInput', # [SpeedLimitForToolNameInput!]!
            # if omitted, is SafetySpeedConstraintsInfo in effect by default? if so, need the tri-state
            'use': 'Boolean', # Boolean
        },

        # Information for each individual camera.
        'ScannerCameraInfo': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The {instobjectname}/{cameraname} identifying the sensor. For Example: scanner/MatrixCamera.
            'name': 'String', # String
            # A value in (0,1] describing the percentage of scan field to use for barcode detection from the raw geometry of the scanner. 0.9 means will use 90% of the scan field starting from center, so each side will be missing 5%
            'scanFieldUsageRatio': 'Float', # Float
            # mm, The distance to put the barcode from the scanner origin.
            'scannerDist': 'Float', # Float
            # The name of the IO to use to trigger the barcode scanner.
            'triggerIO': 'String', # String
        },

        # Information for each individual camera.
        'ScannerCameraInfoInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The {instobjectname}/{cameraname} identifying the sensor. For Example: scanner/MatrixCamera.
            'name': 'String', # String
            # A value in (0,1] describing the percentage of scan field to use for barcode detection from the raw geometry of the scanner. 0.9 means will use 90% of the scan field starting from center, so each side will be missing 5%
            'scanFieldUsageRatio': 'Float', # Float
            # mm, The distance to put the barcode from the scanner origin.
            'scannerDist': 'Float', # Float
            # The name of the IO to use to trigger the barcode scanner.
            'triggerIO': 'String', # String
        },

        # Sensor Bias By IO Signal
        'SensorBiasByIoSignals': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # IO Name to be used to predict bias force torque
            'ioname': 'String', # String
            # Bias force torque that can be predicted by IO value
            'sensorBiasPerIoValue': 'SensorBiasPerIOValue', # [SensorBiasPerIOValue]
            # method type to compute bias force torque. onlyMatch: subtract bias force torque when IO value matches with specified value. linearInterpolation: compute bias force torque by linear interpolation
            'type': 'String', # String
        },

        # Sensor Bias By IO Signal
        'SensorBiasByIoSignalsInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # IO Name to be used to predict bias force torque
            'ioname': 'String', # String
            # Bias force torque that can be predicted by IO value
            'sensorBiasPerIoValue': 'SensorBiasPerIOValueInput', # [SensorBiasPerIOValueInput]
            # method type to compute bias force torque. onlyMatch: subtract bias force torque when IO value matches with specified value. linearInterpolation: compute bias force torque by linear interpolation
            'type': 'String', # String
        },

        # Pair of IO Value and Bias Force Torque
        'SensorBiasPerIOValue': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Bias Force Torque
            'forceTorque': 'Float', # [Float]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # IO Value for certain bias force torque
            'iovalue': 'Int', # Int
        },

        # Pair of IO Value and Bias Force Torque
        'SensorBiasPerIOValueInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Bias Force Torque
            'forceTorque': 'Float', # [Float]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # IO Value for certain bias force torque
            'iovalue': 'Int', # Int
        },

        # The geometry of a sensor with additional data.
        'SensorGeometry': {
            'gain': 'Float', # Float
            'hardwareId': 'String', # String
            # The height of the sensor image (in pixels)
            'height': 'Int', # Int
            # The intrinsic parameters of the camera.
            'intrinsics': 'CameraIntrinsics', # CameraIntrinsics
            'measurementTime': 'Float', # Float
            # Deprecated. Keeping it only for backcompatibility conversion.
            'sensorReference': 'String', # String
            # The region that the sensor points/looks at
            'targetRegion': 'String', # String
            # The width of the sensor image (in pixels)
            'width': 'Int', # Int
        },

        # The geometry of a sensor with additional data.
        'SensorGeometryInput': {
            'gain': 'Float', # Float
            'hardwareId': 'String', # String
            # The height of the sensor image (in pixels)
            'height': 'Int', # Int
            # The intrinsic parameters of the camera.
            'intrinsics': 'CameraIntrinsicsInput', # CameraIntrinsicsInput
            'measurementTime': 'Float', # Float
            # Deprecated. Keeping it only for backcompatibility conversion.
            'sensorReference': 'String', # String
            # The region that the sensor points/looks at
            'targetRegion': 'String', # String
            # The width of the sensor image (in pixels)
            'width': 'Int', # Int
        },

        # Information for each individual sensor streamer.
        'SensorStreamerConfiguration': {
            # Configuration of Cognex barcode scanner.
            'cognexSensorConfig': 'CognexSensorConfiguration', # CognexSensorConfiguration
            # Configuration of Keyence CV-X.
            'cvxSensorConfig': 'CVXSensorConfiguration', # CVXSensorConfiguration
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Configuration of Datalogic Matrixbarcode scanner.
            'matrixSensorConfig': 'MatrixSensorConfiguration', # MatrixSensorConfiguration
            # Configuration of Canon RV.
            'rvSensorConfig': 'RVSensorConfiguration', # RVSensorConfiguration
            # [CVX, RV, TVS, Matrix] is for 3rdparty streamer.
            # [ensenso, zivid, photoneo, percipio, irayple, cognex, sr] is for sensorbridge.
            # It is allowed to specify one sensor type for 3rdparty streamer or specify multiple sensor types for sensorbridge.
            # Combination is not possible.
            'sensorTypes': 'String', # [String]
            # Configuration of Keyence SR barcode scanner.
            'srSensorConfig': 'SRSensorConfiguration', # SRSensorConfiguration
            # the IP address of a sensor streamer
            'streamerIp': 'String', # String
            # custom parameters for a sensor streamer
            'streamerOption': 'String', # String
            # the port number of a sensor streamer. 5718 is default for sensor streamer
            'streamerPort': 'Int', # Int
            # Configuration of 3D media/Kyoto robotics TVS.
            'tvsSensorConfig': 'TVSSensorConfiguration', # TVSSensorConfiguration
            # Set to true to enable this sensor.
            'use': 'Boolean', # Boolean
        },

        # Information for each individual sensor streamer.
        'SensorStreamerConfigurationInput': {
            # Configuration of Cognex barcode scanner.
            'cognexSensorConfig': 'CognexSensorConfigurationInput', # CognexSensorConfigurationInput
            # Configuration of Keyence CV-X.
            'cvxSensorConfig': 'CVXSensorConfigurationInput', # CVXSensorConfigurationInput
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Configuration of Datalogic Matrixbarcode scanner.
            'matrixSensorConfig': 'MatrixSensorConfigurationInput', # MatrixSensorConfigurationInput
            # Configuration of Canon RV.
            'rvSensorConfig': 'RVSensorConfigurationInput', # RVSensorConfigurationInput
            # [CVX, RV, TVS, Matrix] is for 3rdparty streamer.
            # [ensenso, zivid, photoneo, percipio, irayple, cognex, sr] is for sensorbridge.
            # It is allowed to specify one sensor type for 3rdparty streamer or specify multiple sensor types for sensorbridge.
            # Combination is not possible.
            'sensorTypes': 'String', # [String]
            # Configuration of Keyence SR barcode scanner.
            'srSensorConfig': 'SRSensorConfigurationInput', # SRSensorConfigurationInput
            # the IP address of a sensor streamer
            'streamerIp': 'String', # String
            # custom parameters for a sensor streamer
            'streamerOption': 'String', # String
            # the port number of a sensor streamer. 5718 is default for sensor streamer
            'streamerPort': 'Int', # Int
            # Configuration of 3D media/Kyoto robotics TVS.
            'tvsSensorConfig': 'TVSSensorConfigurationInput', # TVSSensorConfigurationInput
            # Set to true to enable this sensor.
            'use': 'Boolean', # Boolean
        },

        # Configuration of FTP Server
        'SensorStreamerFTPServerConfiguration': {
            # The IP address of FTP server to connect.
            'connectServerIP': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The password used to login FTP server
            'password': 'String', # String
            # The directory of FTP server to use as a root.
            'serverRootDir': 'String', # String
            # If true, FTP server is used.
            'use': 'Boolean', # Boolean
            # The username used to login FTP server
            'username': 'String', # String
        },

        # Configuration of FTP Server
        'SensorStreamerFTPServerConfigurationInput': {
            # The IP address of FTP server to connect.
            'connectServerIP': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The password used to login FTP server
            'password': 'String', # String
            # The directory of FTP server to use as a root.
            'serverRootDir': 'String', # String
            # If true, FTP server is used.
            'use': 'Boolean', # Boolean
            # The username used to login FTP server
            'username': 'String', # String
        },

        # The side walls of e.g. a cage or roll cart.
        'SideWall': {
            'halfExtents': 'Float', # [Float!]!
            'transform': 'Float', # [Float!]!
            'type': 'String', # String!
        },

        # The side walls of e.g. a cage or roll cart.
        'SideWallInput': {
            'halfExtents': 'Float', # [Float!]!
            'transform': 'Float', # [Float!]!
            'type': 'String', # String!
        },

        'SignalMapConfiguration': {
            # Last author who modified the configuration.
            'author': 'String', # String!
            # Defines scaling factors to convert from real physical units to the memory values.
            'conversionInfo': 'SignalMapConversionInfo', # SignalMapConversionInfo
            # Timestamp when the configuration was created.
            'createdAt': 'DateTime', # DateTime
            # Defining the a signal on the memory and how that signal is treated.
            'defaultSignalParameters': 'SignalMapSignalEntry', # SignalMapSignalEntry
            # Defines the memory devices in the PLC and the type of memory they hold.
            'deviceEntries': 'SignalMapDeviceEntry', # [SignalMapDeviceEntry]
            # Defines the format for grabbedTargetInfo that is set whenever the robot grabs a target.
            'grabbedTargetInfoFormat': 'SignalMapFormatEntry', # [SignalMapFormatEntry]
            # ID of the configuration.
            'id': 'String', # String!
            # Defines how location states and information gets sent to and received by the memory.
            'locationEntries': 'SignalMapLocationEntry', # [SignalMapLocationEntry]
            # Timestamp when the configuration was last modified.
            'modifiedAt': 'DateTime', # DateTime
            # Format for how to extract the packFormation data from the memory.
            'packFormationFormat': 'SignalMapPackFormationFormat', # SignalMapPackFormationFormat
            # Defines the format for placedTargetInfo that is set whenever the robot placed a target somewhere.
            'placedTargetInfoFormat': 'SignalMapFormatEntry', # [SignalMapFormatEntry]
            # The number of bytes that each entry in placedTargetInfoFormat takes. If 0, then compute from max byte used in placedTargetInfoFormat.
            'placedTargetInfoNumBytes': 'Int', # Int
            # Defining memory structs specifically for production cycle.
            'productionCycleFormat': 'SignalMapProductionCycleFormat', # SignalMapProductionCycleFormat
            # For linking the imported configuration file to a file in the configuration library that is part of the runtime image.
            'referenceFilename': 'String', # String
            # The ID of the parent configuration of this configuration. Fields that are undefined in this configuration will be taken from the parent (recursively).
            'referenceId': 'String', # String
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # Latest revision id of the configuration.
            'revisionId': 'Int', # Int!
            # Defines the signals that get sent to and received by the memory.
            'signalEntries': 'SignalMapSignalEntry', # [SignalMapSignalEntry]
        },

        'SignalMapConfigurationInput': {
            # Defines scaling factors to convert from real physical units to the memory values.
            'conversionInfo': 'SignalMapConversionInfoInput', # SignalMapConversionInfoInput
            # Defining the a signal on the memory and how that signal is treated.
            'defaultSignalParameters': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
            # Defines the memory devices in the PLC and the type of memory they hold.
            'deviceEntries': 'SignalMapDeviceEntryInput', # [SignalMapDeviceEntryInput]
            # Defines the format for grabbedTargetInfo that is set whenever the robot grabs a target.
            'grabbedTargetInfoFormat': 'SignalMapFormatEntryInput', # [SignalMapFormatEntryInput]
            # ID of the configuration.
            'id': 'String', # String
            # Defines how location states and information gets sent to and received by the memory.
            'locationEntries': 'SignalMapLocationEntryInput', # [SignalMapLocationEntryInput]
            # Format for how to extract the packFormation data from the memory.
            'packFormationFormat': 'SignalMapPackFormationFormatInput', # SignalMapPackFormationFormatInput
            # Defines the format for placedTargetInfo that is set whenever the robot placed a target somewhere.
            'placedTargetInfoFormat': 'SignalMapFormatEntryInput', # [SignalMapFormatEntryInput]
            # The number of bytes that each entry in placedTargetInfoFormat takes. If 0, then compute from max byte used in placedTargetInfoFormat.
            'placedTargetInfoNumBytes': 'Int', # Int
            # Defining memory structs specifically for production cycle.
            'productionCycleFormat': 'SignalMapProductionCycleFormatInput', # SignalMapProductionCycleFormatInput
            # For linking the imported configuration file to a file in the configuration library that is part of the runtime image.
            'referenceFilename': 'String', # String
            # The ID of the parent configuration of this configuration. Fields that are undefined in this configuration will be taken from the parent (recursively).
            'referenceId': 'String', # String
            # Defines the signals that get sent to and received by the memory.
            'signalEntries': 'SignalMapSignalEntryInput', # [SignalMapSignalEntryInput]
        },

        # Defines scaling factors to convert from real physical units to the memory values.
        'SignalMapConversionInfo': {
            # Type of unit the length signal is encoded for.
            'defaultLengthUnitType': 'String', # String
            # Type of unit the mass signal is encoded for.
            'defaultMassUnitType': 'String', # String
            # When strings are represented with an array of 16bit or 32bit integers, shows the order of the bytes to extract from that Value. Can be Little Endian (first byte is lowest bits) or Big Endian (first byte is highest bits)
            'stringEndianness': 'String', # String
        },

        # Defines scaling factors to convert from real physical units to the memory values.
        'SignalMapConversionInfoInput': {
            # Type of unit the length signal is encoded for.
            'defaultLengthUnitType': 'String', # String
            # Type of unit the mass signal is encoded for.
            'defaultMassUnitType': 'String', # String
            # When strings are represented with an array of 16bit or 32bit integers, shows the order of the bytes to extract from that Value. Can be Little Endian (first byte is lowest bits) or Big Endian (first byte is highest bits)
            'stringEndianness': 'String', # String
        },

        # Defining the connection, definition, and properties of a specific memory device on the PLC.
        'SignalMapDeviceEntry': {
            # Decimal address offset to add to all the signals specified in this map before addressing them in the real device. Mutually exclusive with addressOffsetHex.
            'addressOffset': 'Int', # Int
            # Hex address offset to add to all the signals specified in this map before addressing them in the real device. Mutually exclusive with addressOffset.
            'addressOffsetHex': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Identifies the internal memory device via a specified code for sending read/write commands.
            'deviceCode': 'String', # String
            # The number of bits for each memory address in the device. Usually this is 16.
            'entryBitWidth': 'Int', # Int
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
        },

        # Defining the connection, definition, and properties of a specific memory device on the PLC.
        'SignalMapDeviceEntryInput': {
            # Decimal address offset to add to all the signals specified in this map before addressing them in the real device. Mutually exclusive with addressOffsetHex.
            'addressOffset': 'Int', # Int
            # Hex address offset to add to all the signals specified in this map before addressing them in the real device. Mutually exclusive with addressOffset.
            'addressOffsetHex': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Identifies the internal memory device via a specified code for sending read/write commands.
            'deviceCode': 'String', # String
            # The number of bits for each memory address in the device. Usually this is 16.
            'entryBitWidth': 'Int', # Int
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
        },

        # Defining the format of a single entry in the device memory.
        'SignalMapFormatEntry': {
            # Byte offset from start of entry.
            'byteOffset': 'Int', # Int
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The number of bytes of the signal.
            'numBytes': 'Int', # Int
            # Type of memory data format (in PLC memory) for the signal.
            'signalDataType': 'String', # String
            # Name of the signal used to set/get IO.
            'signalName': 'String', # String
            # Type of unit the signal is encoded for. Units can physical measurements, URIs, or objects.
            # 
            # - default - try to infer the unit type from the name
            #  - locationIndex - PLC memory holds an integer of the location, which is then converted to a string of the actual location name.
            # - objectURI - Supposed to represent the name of an object in the webstack, and will create the URI using mujin:/%s.mujin.msgpack
            'signalUnitType': 'String', # String
        },

        # Defining the format of a single entry in the device memory.
        'SignalMapFormatEntryInput': {
            # Byte offset from start of entry.
            'byteOffset': 'Int', # Int
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The number of bytes of the signal.
            'numBytes': 'Int', # Int
            # Type of memory data format (in PLC memory) for the signal.
            'signalDataType': 'String', # String
            # Name of the signal used to set/get IO.
            'signalName': 'String', # String
            # Type of unit the signal is encoded for. Units can physical measurements, URIs, or objects.
            # 
            # - default - try to infer the unit type from the name
            #  - locationIndex - PLC memory holds an integer of the location, which is then converted to a string of the actual location name.
            # - objectURI - Supposed to represent the name of an object in the webstack, and will create the URI using mujin:/%s.mujin.msgpack
            'signalUnitType': 'String', # String
        },

        # Defines the memory maps for locations being tracked in.
        'SignalMapLocationEntry': {
            # Defining the a signal on the memory and how that signal is treated.
            'containerId': 'SignalMapSignalEntry', # SignalMapSignalEntry
            # Defining the a signal on the memory and how that signal is treated.
            'containerMetaData': 'SignalMapSignalEntry', # SignalMapSignalEntry
            # Defining the a signal on the memory and how that signal is treated.
            'containerType': 'SignalMapSignalEntry', # SignalMapSignalEntry
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Defining the a signal on the memory and how that signal is treated.
            'hasContainer': 'SignalMapSignalEntry', # SignalMapSignalEntry
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Location index used to initialize all the other IO variables like locationXReleased.
            'locationIndex': 'Int', # Int
            # Name of an already defined Location in the system.
            'locationName': 'String', # String
            # Defining the a signal on the memory and how that signal is treated.
            'numPlacedInContainer': 'SignalMapSignalEntry', # SignalMapSignalEntry
            # Defining the a signal on the memory and how that signal is treated.
            'prohibited': 'SignalMapSignalEntry', # SignalMapSignalEntry
            # Defining the a signal on the memory and how that signal is treated.
            'released': 'SignalMapSignalEntry', # SignalMapSignalEntry
        },

        # Defines the memory maps for locations being tracked in.
        'SignalMapLocationEntryInput': {
            # Defining the a signal on the memory and how that signal is treated.
            'containerId': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
            # Defining the a signal on the memory and how that signal is treated.
            'containerMetaData': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
            # Defining the a signal on the memory and how that signal is treated.
            'containerType': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Defining the a signal on the memory and how that signal is treated.
            'hasContainer': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Location index used to initialize all the other IO variables like locationXReleased.
            'locationIndex': 'Int', # Int
            # Name of an already defined Location in the system.
            'locationName': 'String', # String
            # Defining the a signal on the memory and how that signal is treated.
            'numPlacedInContainer': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
            # Defining the a signal on the memory and how that signal is treated.
            'prohibited': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
            # Defining the a signal on the memory and how that signal is treated.
            'released': 'SignalMapSignalEntryInput', # SignalMapSignalEntryInput
        },

        # Format for how to extract the packFormation data from the memory.
        'SignalMapPackFormationFormat': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Defines the format for each item entry.
            'entryFormat': 'SignalMapFormatEntry', # [SignalMapFormatEntry]
            # The number of bytes that each entry takes. If 0, then compute from max byte used in entryFormat.
            'entryNumBytes': 'Int', # Int
            # Defines the format of the packing header.
            'headerFormat': 'SignalMapFormatEntry', # [SignalMapFormatEntry]
            # The number of bytes that the header takes. If 0, then compute from max byte used in headerFormat.
            'headerNumBytes': 'Int', # Int
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
        },

        # Format for how to extract the packFormation data from the memory.
        'SignalMapPackFormationFormatInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # Defines the format for each item entry.
            'entryFormat': 'SignalMapFormatEntryInput', # [SignalMapFormatEntryInput]
            # The number of bytes that each entry takes. If 0, then compute from max byte used in entryFormat.
            'entryNumBytes': 'Int', # Int
            # Defines the format of the packing header.
            'headerFormat': 'SignalMapFormatEntryInput', # [SignalMapFormatEntryInput]
            # The number of bytes that the header takes. If 0, then compute from max byte used in headerFormat.
            'headerNumBytes': 'Int', # Int
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
        },

        # Defining memory structs specifically for production cycle.
        'SignalMapProductionCycleFormat': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # If > 0, then the number of bytes for each orderQueue entry. If == 0, then compute that from the orderQueueFormat entry.
            'orderEntryNumBytes': 'Int', # Int
            # Defines the format of a queue entry within the device memory.
            'orderQueueFormat': 'SignalMapFormatEntry', # [SignalMapFormatEntry]
            # If > 0, then the number of bytes for each predictQueue entry. If == 0, then compute that from the predictQueueFormat entry.
            'predictEntryNumBytes': 'Int', # Int
            # Defines the format of a queue entry within the device memory.
            'predictQueueFormat': 'SignalMapFormatEntry', # [SignalMapFormatEntry]
            # If > 0, then the number of bytes for each resultQueue entry. If == 0, then compute that from the resultQueueFormat entry.
            'resultEntryNumBytes': 'Int', # Int
            # Defines the format of a queue entry within the device memory.
            'resultQueueFormat': 'SignalMapFormatEntry', # [SignalMapFormatEntry]
        },

        # Defining memory structs specifically for production cycle.
        'SignalMapProductionCycleFormatInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # If > 0, then the number of bytes for each orderQueue entry. If == 0, then compute that from the orderQueueFormat entry.
            'orderEntryNumBytes': 'Int', # Int
            # Defines the format of a queue entry within the device memory.
            'orderQueueFormat': 'SignalMapFormatEntryInput', # [SignalMapFormatEntryInput]
            # If > 0, then the number of bytes for each predictQueue entry. If == 0, then compute that from the predictQueueFormat entry.
            'predictEntryNumBytes': 'Int', # Int
            # Defines the format of a queue entry within the device memory.
            'predictQueueFormat': 'SignalMapFormatEntryInput', # [SignalMapFormatEntryInput]
            # If > 0, then the number of bytes for each resultQueue entry. If == 0, then compute that from the resultQueueFormat entry.
            'resultEntryNumBytes': 'Int', # Int
            # Defines the format of a queue entry within the device memory.
            'resultQueueFormat': 'SignalMapFormatEntryInput', # [SignalMapFormatEntryInput]
        },

        # Defining the a signal on the memory and how that signal is treated.
        'SignalMapSignalEntry': {
            # Decimal address of the entry, can include bit offset via 'XXX.YY' where XXX is integer part and YY is the bit offset with a value in 0-15.
            'address': 'String', # String
            # Hex address of the entry, can include bit offset via 'XXX.Y' where XXX is integer part and Y is the bit offset with a value from 0-F.
            'addresshex': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The description of the signal and any type of custom notes for it.
            'description': 'String', # String
            # Identifies the internal memory device via a specified code for sending read/write commands.
            'deviceCode': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # If true, then the signal is inverted when sent/received from to/from the PLC.
            'isInvert': 'Boolean', # Boolean
            # If true, then signal should be sent/received periodically.
            'isPeriodic': 'Boolean', # Boolean
            # If true, for received signals, once received, will re-routed through the rest of the IO system via SetIOVariable.
            'isReroute': 'Boolean', # Boolean
            # If true, then signal is a send type and does not have to worry about what is in the PLC memory, otherwise it is receive type.
            'isSend': 'Boolean', # Boolean
            # Number of units of the data specified by signalDataType. If signalDataType is string, then this is the number of ascii characters. The size on the device memory depends on the device bit width. Should be signed due to comparisons with indices.
            'numEntries': 'Int', # Int
            # Type of memory data format (in PLC memory) for the signal.
            'signalDataType': 'String', # String
            # Name of the signal used to set/get IO.
            'signalName': 'String', # String
            # Type of unit the signal is encoded for. Units can physical measurements, URIs, or objects.
            # 
            # - default - try to infer the unit type from the name
            #  - locationIndex - PLC memory holds an integer of the location, which is then converted to a string of the actual location name.
            # - objectURI - Supposed to represent the name of an object in the webstack, and will create the URI using mujin:/%s.mujin.msgpack
            'signalUnitType': 'String', # String
        },

        # Defining the a signal on the memory and how that signal is treated.
        'SignalMapSignalEntryInput': {
            # Decimal address of the entry, can include bit offset via 'XXX.YY' where XXX is integer part and YY is the bit offset with a value in 0-15.
            'address': 'String', # String
            # Hex address of the entry, can include bit offset via 'XXX.Y' where XXX is integer part and Y is the bit offset with a value from 0-F.
            'addresshex': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The description of the signal and any type of custom notes for it.
            'description': 'String', # String
            # Identifies the internal memory device via a specified code for sending read/write commands.
            'deviceCode': 'String', # String
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # If true, then the signal is inverted when sent/received from to/from the PLC.
            'isInvert': 'Boolean', # Boolean
            # If true, then signal should be sent/received periodically.
            'isPeriodic': 'Boolean', # Boolean
            # If true, for received signals, once received, will re-routed through the rest of the IO system via SetIOVariable.
            'isReroute': 'Boolean', # Boolean
            # If true, then signal is a send type and does not have to worry about what is in the PLC memory, otherwise it is receive type.
            'isSend': 'Boolean', # Boolean
            # Number of units of the data specified by signalDataType. If signalDataType is string, then this is the number of ascii characters. The size on the device memory depends on the device bit width. Should be signed due to comparisons with indices.
            'numEntries': 'Int', # Int
            # Type of memory data format (in PLC memory) for the signal.
            'signalDataType': 'String', # String
            # Name of the signal used to set/get IO.
            'signalName': 'String', # String
            # Type of unit the signal is encoded for. Units can physical measurements, URIs, or objects.
            # 
            # - default - try to infer the unit type from the name
            #  - locationIndex - PLC memory holds an integer of the location, which is then converted to a string of the actual location name.
            # - objectURI - Supposed to represent the name of an object in the webstack, and will create the URI using mujin:/%s.mujin.msgpack
            'signalUnitType': 'String', # String
        },

        # a dictionary specifying what kind of destinations can be skipped during destination validation process
        'SkipCollidingDestsInfo': {
            # if True then will skip any colliding destinations with the environment from being considered in the loop
            'skipEnvironmentCollidingDests': 'Boolean', # Boolean
            # if True then will skip any colliding destinations with already placed items from being considered in the loop
            'skipPlacedCollidingDests': 'Boolean', # Boolean
            # if True then will skip any destinations filtered out by targeturi. if False and all destinations are filtered out by validTargetUri, then raise an exception
            'skipUriFilteredDests': 'Boolean', # Boolean
        },

        # a dictionary specifying what kind of destinations can be skipped during destination validation process
        'SkipCollidingDestsInfoInput': {
            # if True then will skip any colliding destinations with the environment from being considered in the loop
            'skipEnvironmentCollidingDests': 'Boolean', # Boolean
            # if True then will skip any colliding destinations with already placed items from being considered in the loop
            'skipPlacedCollidingDests': 'Boolean', # Boolean
            # if True then will skip any destinations filtered out by targeturi. if False and all destinations are filtered out by validTargetUri, then raise an exception
            'skipUriFilteredDests': 'Boolean', # Boolean
        },

        # Parameters dealing with getting smoother paths for the robot planning.
        'SmoothingParameters': {
            # How many iterations used for linear smoothing
            'linearSmoothingIterations': 'Int', # Int
            # The number of smoother iterations to force before the process can terminate early.
            'minSmootherIterations': 'Int', # Int
            # number of iterations to smooth trajectory using a parabolic smoother. Bigger the value more smooth trajectory, but the computation time and planning failures increases.
            'smootheriterations': 'Int', # Int
            # The name of the trajectory post-processing smoother to use.
            'smootherplannername': 'String', # String
            # Used to decide whether to continue the smoothing process every time the smoother makes an improvement. If the ratio of the improvement score from the current iteration and the best improvement score so far is less than this number, will stop post-processing.
            'smoothingDurationImprovementCutoffRatio': 'Float', # Float
            # The point tolerance for subsampling parabolic arcs
            'smoothingPointTolerance': 'Float', # Float
            # number of iterations to smooth in parabolic smoother
            'smoothingStepLength': 'Float', # Float
            # The time limit for trajectory post-processing via a parabolic smoother. 0 means no limits.
            'smoothingTimeLimit': 'Float', # Float
        },

        # Parameters dealing with getting smoother paths for the robot planning.
        'SmoothingParametersInput': {
            # How many iterations used for linear smoothing
            'linearSmoothingIterations': 'Int', # Int
            # The number of smoother iterations to force before the process can terminate early.
            'minSmootherIterations': 'Int', # Int
            # number of iterations to smooth trajectory using a parabolic smoother. Bigger the value more smooth trajectory, but the computation time and planning failures increases.
            'smootheriterations': 'Int', # Int
            # The name of the trajectory post-processing smoother to use.
            'smootherplannername': 'String', # String
            # Used to decide whether to continue the smoothing process every time the smoother makes an improvement. If the ratio of the improvement score from the current iteration and the best improvement score so far is less than this number, will stop post-processing.
            'smoothingDurationImprovementCutoffRatio': 'Float', # Float
            # The point tolerance for subsampling parabolic arcs
            'smoothingPointTolerance': 'Float', # Float
            # number of iterations to smooth in parabolic smoother
            'smoothingStepLength': 'Float', # Float
            # The time limit for trajectory post-processing via a parabolic smoother. 0 means no limits.
            'smoothingTimeLimit': 'Float', # Float
        },

        # The cartesian speed limit for a tool.
        'SpeedLimitForToolName': {
            # Maximum cartesian (XYZ) tool speed in m/s or mm/s (depending on the unit of the scene)
            'maxToolSpeed': 'Float', # Float!
            # The name of the tool this speed limit applies to
            'toolname': 'String', # String!
        },

        # The cartesian speed limit for a tool.
        'SpeedLimitForToolNameInput': {
            # Maximum cartesian (XYZ) tool speed in m/s or mm/s (depending on the unit of the scene)
            'maxToolSpeed': 'Float', # Float!
            # The name of the tool this speed limit applies to
            'toolname': 'String', # String!
        },

        # Statistics about the system
        'Stats': {
            'lastDetectedAt': 'DateTime', # DateTime
            'lastPickedAt': 'DateTime', # DateTime
        },

        # Describes the order of targets to be picked up. Currently available strategies are
        # 'axis'
        # 'containerLocalAxis'
        # 'name'
        # 'type'
        'StrictPickOrdering': {
            # Order targets to be picked up base on their global coordinates. Available options are
            # 'yp' : choose the target with the greatest y-coordinate first.
            # 'zp' : choose the target with the greatest z-coordinate first.
            'axis': 'String', # String
            # Order targets to be picked up based on their poses with respect to the container's local coordinate frame. Only targets that are furthest along the indicated container axis are allowed to be picked up. Available options are
            # 'xp'
            # 'xn'
            # 'yp'
            # 'yn'
            # 'zp'
            # 'zn'
            'containerLocalAxis': 'String', # String
            # For use with strict pick ordering 'type'. Available options are
            # 'zp'
            # 'xyz'
            # 'boxSize_xy' (default)
            'criteria': 'String', # String
            # list of dictionaries where each dictionary contains description of low priority types.
            'lowPriorityTypeInfos': 'LowPriorityTypeInfo', # [LowPriorityTypeInfo]
            # Order targets to be picked up based on their names. Available options are
            # 'ascending' : sort target names in the ascending order and choose the first one on the list
            # 'descending' : sort target names in the descending order and choose the first one on the list
            'name': 'String', # String
            # mm, For use with strict pick ordering 'axis:zp' and 'containerLocalAxis'. Only consider targets whose AABBs are within `threshForAxis` mm along the specified axis from the AABB of the furthest target.
            'threshForAxis': 'Float', # Float
            # Order targets to be picked up base on their types. Available options are
            # 'chooseOneType' : targets (boxes) are categorized base on their sizes. targets with the biggest size are considered first.
            # 'lowPriorityTypes' : targets that are categorized as low pripority are not picked until all high priority targets are picked or become unpickable. when low priority targets can be picked with parameters specified in lowPriorityTypeInfos.
            'type': 'String', # String
            # Set to true to enable strict pick ordering.
            'use': 'Boolean', # Boolean
        },

        # Describes the order of targets to be picked up. Currently available strategies are
        # 'axis'
        # 'containerLocalAxis'
        # 'name'
        # 'type'
        'StrictPickOrderingInput': {
            # Order targets to be picked up base on their global coordinates. Available options are
            # 'yp' : choose the target with the greatest y-coordinate first.
            # 'zp' : choose the target with the greatest z-coordinate first.
            'axis': 'String', # String
            # Order targets to be picked up based on their poses with respect to the container's local coordinate frame. Only targets that are furthest along the indicated container axis are allowed to be picked up. Available options are
            # 'xp'
            # 'xn'
            # 'yp'
            # 'yn'
            # 'zp'
            # 'zn'
            'containerLocalAxis': 'String', # String
            # For use with strict pick ordering 'type'. Available options are
            # 'zp'
            # 'xyz'
            # 'boxSize_xy' (default)
            'criteria': 'String', # String
            # list of dictionaries where each dictionary contains description of low priority types.
            'lowPriorityTypeInfos': 'LowPriorityTypeInfoInput', # [LowPriorityTypeInfoInput]
            # Order targets to be picked up based on their names. Available options are
            # 'ascending' : sort target names in the ascending order and choose the first one on the list
            # 'descending' : sort target names in the descending order and choose the first one on the list
            'name': 'String', # String
            # mm, For use with strict pick ordering 'axis:zp' and 'containerLocalAxis'. Only consider targets whose AABBs are within `threshForAxis` mm along the specified axis from the AABB of the furthest target.
            'threshForAxis': 'Float', # Float
            # Order targets to be picked up base on their types. Available options are
            # 'chooseOneType' : targets (boxes) are categorized base on their sizes. targets with the biggest size are considered first.
            # 'lowPriorityTypes' : targets that are categorized as low pripority are not picked until all high priority targets are picked or become unpickable. when low priority targets can be picked with parameters specified in lowPriorityTypeInfos.
            'type': 'String', # String
            # Set to true to enable strict pick ordering.
            'use': 'Boolean', # Boolean
        },

        # A named parameter holding a single string value
        'StringParameter': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String!
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            'value': 'String', # String
        },

        # A named parameter holding a single string value
        'StringParameterInput': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String
            'value': 'String', # String
        },

        # A named parameter holding an array of string values
        'StringsParameter': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String!
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            'values': 'String', # [String!]
        },

        # A named parameter holding an array of string values
        'StringsParameterInput': {
            'deleted': 'Boolean', # Boolean
            'id': 'String', # String
            'values': 'String', # [String!]
        },

        # Scores the performance of a set of suction cups.
        'SuctionCupsPerformance': {
            # Can be either 'SCS_Unknown', 'SCS_Bad', 'SCS_Good' or 'SCS_VeryGood'
            'score': 'String', # String!
            # The model numbers of the suction cups
            'suctionCupPartTypes': 'String', # [String!]!
        },

        # Scores the performance of a set of suction cups.
        'SuctionCupsPerformanceInput': {
            # Can be either 'SCS_Unknown', 'SCS_Bad', 'SCS_Good' or 'SCS_VeryGood'
            'score': 'String', # String!
            # The model numbers of the suction cups
            'suctionCupPartTypes': 'String', # [String!]!
        },

        # The mapping from camera Name to task ID.
        'TVSSensorCameraNameTaskIDMapping': {
            # The name of camera.
            'cameraName': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The task ID used in TVS. Task is known as preprocessing file too.
            'taskID': 'Int', # Int
        },

        # The mapping from camera Name to task ID.
        'TVSSensorCameraNameTaskIDMappingInput': {
            # The name of camera.
            'cameraName': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The task ID used in TVS. Task is known as preprocessing file too.
            'taskID': 'Int', # Int
        },

        # Configuration of 3D media/Kyoto robotics TVS.
        'TVSSensorConfiguration': {
            # The mapping from camera Name to task ID. If task ID is not specified, this mapping is used to deduce task ID for a camera.
            'cameraNameTaskIDMapping': 'TVSSensorCameraNameTaskIDMapping', # [TVSSensorCameraNameTaskIDMapping]
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The head ID to be activated with current configuration.
            'headID': 'Int', # Int
            # List of head ID avilable with this TVS sensor.
            'headIDList': 'Int', # [Int]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The model ID used to capture a part.
            'modelID': 'Int', # Int
            # The IP address of TVS vision PC.
            'serverIp': 'String', # String
            # The Port number of TVS vision PC. Usually specify 5001.
            'serverPort': 'Int', # Int
            # The task ID used in TVS. Task is known as preprocessing file too. If task ID is not specified, cameraNameTaskIDMapping is used to deduce task ID.
            'taskID': 'Int', # Int
        },

        # Configuration of 3D media/Kyoto robotics TVS.
        'TVSSensorConfigurationInput': {
            # The mapping from camera Name to task ID. If task ID is not specified, this mapping is used to deduce task ID for a camera.
            'cameraNameTaskIDMapping': 'TVSSensorCameraNameTaskIDMappingInput', # [TVSSensorCameraNameTaskIDMappingInput]
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The head ID to be activated with current configuration.
            'headID': 'Int', # Int
            # List of head ID avilable with this TVS sensor.
            'headIDList': 'Int', # [Int]
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # The model ID used to capture a part.
            'modelID': 'Int', # Int
            # The IP address of TVS vision PC.
            'serverIp': 'String', # String
            # The Port number of TVS vision PC. Usually specify 5001.
            'serverPort': 'Int', # Int
            # The task ID used in TVS. Task is known as preprocessing file too. If task ID is not specified, cameraNameTaskIDMapping is used to deduce task ID.
            'taskID': 'Int', # Int
        },

        # Describes how overlapped regions in targets should be processed.
        'TargetOverlapConstraintInfo': {
            # mm, Threshold on how much to ignore the relative heights of two neighboring targets when they are overlapped to determine if the candidate is too much *above* the current pickup target, and therefore should be ignored. Positive value the pickup target is allowed to be under the other non-pickup targets by this amount, and still be pickable. When two targets are deemed to be overlapping on the face orthogonal to overlapUpAxis based on neighOverlapThresh, then check the heights of the targets to make sure that one target is really above the other. Sometimes a candidate can be so high above that the pickup target is not being affected by the above target, this happens in truck unloading often.
            'aboveBoxOverlap': 'Float', # Float
            # mm, Threshold on how much to ignore the relative heights of two neighboring targets to determine if the candidate is *below* the current pickup target. Positive value the pickup target is allowed to be under the other non-pickup targets by this amount, and still be pickable. When two targets are deemed to be overlapping on the face orthogonal to overlapUpAxis based on neighOverlapThresh, then check the heights of the targets to make sure that one target is really above the other. Sometimes detection error can cause two targets on the same height to be overlapped a little, but that doesn't mean that one target is on top of the other.
            'belowBoxOverlap': 'Float', # Float
            # If True, then allow robot to pick up part and drop it in the source when it is too overlapped and have to use OnFail thresholds.
            'canDropInSourceOnFail': 'Boolean', # Boolean
            # deg, Threshold the angle coming from the 'overlapConstraintAxis' in order to reject picking up an object using 'graspDepartOverlapOffsetDir'.
            'constraintAngle': 'Float', # Float
            # mm (x,y,z)
            'graspDepartOverlapOffsetDir': 'Float', # [Float]
            # mm, amount of target extents reduction when counting the number of overlapping pointcloud points. This is so that pointcloud near the edges of the target (can come from noises from nearby targets, for example) can be ignored.
            'ignoreOverlapPointsFromNearbyTargets': 'Float', # Float
            # mm, distance from the container inner walls within which pointcloud points do not count towards overlapping points
            'ignoreOverlapPointsFromWall': 'Float', # Float
            # If the object is being overlapped by this many points from the point cloud, then it will be considered slightly overlapped and will change the direction of pickup.
            'maxChangeDirNumOverlappingPoints': 'Int', # Int
            # If the object is being overlapped by this many points from the point cloud, then it will be considered overlapped and will not be picked up.
            'maxPickupNumOverlappingPoints': 'Int', # Int
            # Same as maxPickupNumOverlappingPoints except that it is a threshold used when planning has already failed to find a pickable target using the normal parameters.
            'maxPickupNumOverlappingPointsOnFail': 'Int', # Int
            # Max overlap a target can have before robot starts considering changing the grasp depart direction to avoid the overlap regions.
            'neighOverlapChangeDepartThresh': 'Float', # Float
            # Ratio of max overlap a target can have before robot gives up trying to pick up the part. 0 means only pickup targets with no overlap, 1 means can pickup any target regardless of overlap. Overlap is measured on the plane orthogonal to overlapUpAxis.
            'neighOverlapThresh': 'Float', # Float
            # Ratio of max overlap a target can have before robot gives up trying to pick up the part for dropping off. 0 means only pickup targets with no overlap, 1 means can pickup any target regardless of overlap. Overlap is measured on the plane orthogonal to overlapUpAxis.
            'neighOverlapThreshOnFail': 'Float', # Float
            # mm (x,y,z) Depending on the 'graspDepartOverlapOffsetDir' when an object is overlapped, sometimes it can still hit other objects when pulling if the overlap region is big. This parameter checks if the direction from the object center to the overlap region centroid makes an angle with respect to this axis that is within 'constraintAngle', if not, then the target is not picked up.
            'overlapConstraintAxis': 'Float', # [Float]
            # mm (x,y,z) The axis used to compute the 2D overlap information. Usually this is the direction of gravity (usually Z axis).
            'overlapUpAxis': 'Float', # [Float]
            # multiplier to increase size of points in point cloud for overlap checking. the greater multiplier will provide the more conservative overlap checking
            'pointSizeIncreaseMultForOverlapChecking': 'Float', # Float
            # ratio [0-1], When target is at the max allowed overlap, what should be the speed percentage that it is slowed down to when grasping. This is multiplied with the rest of the transferSpeedMult settings
            'transferSpeedMultAtMaxNeighOverlapThresh': 'Float', # Float
            # ratio [0-1], If robot uses OnFail overlap constraints, and target is at the max allowed overlap, what should be the speed percentage that it is slowed down to when grasping. This is multiplied with the rest of the transferSpeedMult settings
            'transferSpeedMultAtMaxNeighOverlapThreshOnFail': 'Float', # Float
            # Set to true to enable using these overlapped parameters.
            'use': 'Boolean', # Boolean
            # Depending on when and how the part is overlapped, robot will use 'graspDepartOverlapOffsetDir' to pull out.
            'useOverlapToComputeGraspDepart': 'Boolean', # Boolean
            # Set to true to enable using shadow regions that objects cast so can prevent robot from picking up objects that are below some objects and in danger of toppling the top objects once they are moved.
            'useShadowExtents': 'Boolean', # Boolean
            # If robot uses OnFail overlap constraints, there is a chance that the source container could have a lot of moved parts. If this parameter is True, then have the robot wait until it can take a new snapshot after the trajectory with OnFail, if False, robot will not pause and will continue to plan ahead.
            'waitForNewDetectionAfterOnFail': 'Boolean', # Boolean
        },

        # Describes how overlapped regions in targets should be processed.
        'TargetOverlapConstraintInfoInput': {
            # mm, Threshold on how much to ignore the relative heights of two neighboring targets when they are overlapped to determine if the candidate is too much *above* the current pickup target, and therefore should be ignored. Positive value the pickup target is allowed to be under the other non-pickup targets by this amount, and still be pickable. When two targets are deemed to be overlapping on the face orthogonal to overlapUpAxis based on neighOverlapThresh, then check the heights of the targets to make sure that one target is really above the other. Sometimes a candidate can be so high above that the pickup target is not being affected by the above target, this happens in truck unloading often.
            'aboveBoxOverlap': 'Float', # Float
            # mm, Threshold on how much to ignore the relative heights of two neighboring targets to determine if the candidate is *below* the current pickup target. Positive value the pickup target is allowed to be under the other non-pickup targets by this amount, and still be pickable. When two targets are deemed to be overlapping on the face orthogonal to overlapUpAxis based on neighOverlapThresh, then check the heights of the targets to make sure that one target is really above the other. Sometimes detection error can cause two targets on the same height to be overlapped a little, but that doesn't mean that one target is on top of the other.
            'belowBoxOverlap': 'Float', # Float
            # If True, then allow robot to pick up part and drop it in the source when it is too overlapped and have to use OnFail thresholds.
            'canDropInSourceOnFail': 'Boolean', # Boolean
            # deg, Threshold the angle coming from the 'overlapConstraintAxis' in order to reject picking up an object using 'graspDepartOverlapOffsetDir'.
            'constraintAngle': 'Float', # Float
            # mm (x,y,z)
            'graspDepartOverlapOffsetDir': 'Float', # [Float]
            # mm, amount of target extents reduction when counting the number of overlapping pointcloud points. This is so that pointcloud near the edges of the target (can come from noises from nearby targets, for example) can be ignored.
            'ignoreOverlapPointsFromNearbyTargets': 'Float', # Float
            # mm, distance from the container inner walls within which pointcloud points do not count towards overlapping points
            'ignoreOverlapPointsFromWall': 'Float', # Float
            # If the object is being overlapped by this many points from the point cloud, then it will be considered slightly overlapped and will change the direction of pickup.
            'maxChangeDirNumOverlappingPoints': 'Int', # Int
            # If the object is being overlapped by this many points from the point cloud, then it will be considered overlapped and will not be picked up.
            'maxPickupNumOverlappingPoints': 'Int', # Int
            # Same as maxPickupNumOverlappingPoints except that it is a threshold used when planning has already failed to find a pickable target using the normal parameters.
            'maxPickupNumOverlappingPointsOnFail': 'Int', # Int
            # Max overlap a target can have before robot starts considering changing the grasp depart direction to avoid the overlap regions.
            'neighOverlapChangeDepartThresh': 'Float', # Float
            # Ratio of max overlap a target can have before robot gives up trying to pick up the part. 0 means only pickup targets with no overlap, 1 means can pickup any target regardless of overlap. Overlap is measured on the plane orthogonal to overlapUpAxis.
            'neighOverlapThresh': 'Float', # Float
            # Ratio of max overlap a target can have before robot gives up trying to pick up the part for dropping off. 0 means only pickup targets with no overlap, 1 means can pickup any target regardless of overlap. Overlap is measured on the plane orthogonal to overlapUpAxis.
            'neighOverlapThreshOnFail': 'Float', # Float
            # mm (x,y,z) Depending on the 'graspDepartOverlapOffsetDir' when an object is overlapped, sometimes it can still hit other objects when pulling if the overlap region is big. This parameter checks if the direction from the object center to the overlap region centroid makes an angle with respect to this axis that is within 'constraintAngle', if not, then the target is not picked up.
            'overlapConstraintAxis': 'Float', # [Float]
            # mm (x,y,z) The axis used to compute the 2D overlap information. Usually this is the direction of gravity (usually Z axis).
            'overlapUpAxis': 'Float', # [Float]
            # multiplier to increase size of points in point cloud for overlap checking. the greater multiplier will provide the more conservative overlap checking
            'pointSizeIncreaseMultForOverlapChecking': 'Float', # Float
            # ratio [0-1], When target is at the max allowed overlap, what should be the speed percentage that it is slowed down to when grasping. This is multiplied with the rest of the transferSpeedMult settings
            'transferSpeedMultAtMaxNeighOverlapThresh': 'Float', # Float
            # ratio [0-1], If robot uses OnFail overlap constraints, and target is at the max allowed overlap, what should be the speed percentage that it is slowed down to when grasping. This is multiplied with the rest of the transferSpeedMult settings
            'transferSpeedMultAtMaxNeighOverlapThreshOnFail': 'Float', # Float
            # Set to true to enable using these overlapped parameters.
            'use': 'Boolean', # Boolean
            # Depending on when and how the part is overlapped, robot will use 'graspDepartOverlapOffsetDir' to pull out.
            'useOverlapToComputeGraspDepart': 'Boolean', # Boolean
            # Set to true to enable using shadow regions that objects cast so can prevent robot from picking up objects that are below some objects and in danger of toppling the top objects once they are moved.
            'useShadowExtents': 'Boolean', # Boolean
            # If robot uses OnFail overlap constraints, there is a chance that the source container could have a lot of moved parts. If this parameter is True, then have the robot wait until it can take a new snapshot after the trajectory with OnFail, if False, robot will not pause and will continue to plan ahead.
            'waitForNewDetectionAfterOnFail': 'Boolean', # Boolean
        },

        # Multipliers and other related quantities for various target priority values.
        'TargetPriorityMultipliers': {
            # Multiplier for target angle, which is the angle between the source container's z-axis and the target axis that is the closest to the container's z-axis. This is used to prioritize right-up targets in the container. A higher value means penalizing more. The default value is 0.
            'angleMult': 'Float', # Float
            # Multiplier for target distance from the center of the source container. A higher value means penalizing more for the targets that are further away from the center. The default value is 0.
            'centerDistXYMult': 'Float', # Float
            # mm. Discretization for target position used for positiveXYZMult, negativeXYZMult, and centerDistXYMult.
            'discretizationXYZ': 'Float', # Float
            # Multiplier for the number of times this target has failed. This should be a positive number. A higher value means penalizing this target more.
            'extraOffsetMult': 'Float', # Float
            # Multiplier for the time remaining (in seconds.) until this target is clear from this penalty. The time is counting down starting from when the target previously failed. The amount of countdown is specified by parameter maxTimeForDecrease.
            'failureCountdownMult': 'Float', # Float
            # Multipliers for prioritizing targets that are further along the negative direction of the global x-, y-, or z-axes. A higher value for x, for example, means prioritizing a target more if the target is further along the global -x-axis compared to others.
            'negativeXYZMult': 'Float', # [Float]
            # Multiplier for the ratio of the target not overlapped by others. A higher value means prioritizing targets with less overlapping. The default value is 0.2.
            'nonOverlappedMult': 'Float', # Float
            # Multiplier for the number of occluded edges. This is usually a negative number. A more negative number means more penalty for targets with more occluded edges.
            'occludedEdgeMult': 'Float', # Float
            # Multipliers for prioritizing targets that are further along the positive direction of the global x-, y-, or z-axes. A higher value for x, for example, means prioritizing a target more if the target is further along the global +x-axis compared to others.
            'positiveXYZMult': 'Float', # [Float]
            # Multiplier for the distance between the currently considered target and the closest previously picked target. The farther away the closest target is, the safer this pick becomes. A higher value means more priority for targets whose closest previously picked targets are farther away.
            'prevPickedTargetsDistMult': 'Float', # Float
            # Multiplier for target confidence. A higher value means prioritizing more for targets that have higher confidence (based on detection results). The default value is 1.
            'targetConfidenceMult': 'Float', # Float
            # Multiplier for the number of uncertain corners. This is usually a negative number. A more negative number meas more penalty for targets with more uncertain corners.
            'uncertainCornerMult': 'Float', # Float
            # Multiplier for the XY area of the AABB of the target. A higher value means favoring targets with greater XY area of their AABBs. The default value is 0.
            'xyAreaMult': 'Float', # Float
        },

        # Multipliers and other related quantities for various target priority values.
        'TargetPriorityMultipliersInput': {
            # Multiplier for target angle, which is the angle between the source container's z-axis and the target axis that is the closest to the container's z-axis. This is used to prioritize right-up targets in the container. A higher value means penalizing more. The default value is 0.
            'angleMult': 'Float', # Float
            # Multiplier for target distance from the center of the source container. A higher value means penalizing more for the targets that are further away from the center. The default value is 0.
            'centerDistXYMult': 'Float', # Float
            # mm. Discretization for target position used for positiveXYZMult, negativeXYZMult, and centerDistXYMult.
            'discretizationXYZ': 'Float', # Float
            # Multiplier for the number of times this target has failed. This should be a positive number. A higher value means penalizing this target more.
            'extraOffsetMult': 'Float', # Float
            # Multiplier for the time remaining (in seconds.) until this target is clear from this penalty. The time is counting down starting from when the target previously failed. The amount of countdown is specified by parameter maxTimeForDecrease.
            'failureCountdownMult': 'Float', # Float
            # Multipliers for prioritizing targets that are further along the negative direction of the global x-, y-, or z-axes. A higher value for x, for example, means prioritizing a target more if the target is further along the global -x-axis compared to others.
            'negativeXYZMult': 'Float', # [Float]
            # Multiplier for the ratio of the target not overlapped by others. A higher value means prioritizing targets with less overlapping. The default value is 0.2.
            'nonOverlappedMult': 'Float', # Float
            # Multiplier for the number of occluded edges. This is usually a negative number. A more negative number means more penalty for targets with more occluded edges.
            'occludedEdgeMult': 'Float', # Float
            # Multipliers for prioritizing targets that are further along the positive direction of the global x-, y-, or z-axes. A higher value for x, for example, means prioritizing a target more if the target is further along the global +x-axis compared to others.
            'positiveXYZMult': 'Float', # [Float]
            # Multiplier for the distance between the currently considered target and the closest previously picked target. The farther away the closest target is, the safer this pick becomes. A higher value means more priority for targets whose closest previously picked targets are farther away.
            'prevPickedTargetsDistMult': 'Float', # Float
            # Multiplier for target confidence. A higher value means prioritizing more for targets that have higher confidence (based on detection results). The default value is 1.
            'targetConfidenceMult': 'Float', # Float
            # Multiplier for the number of uncertain corners. This is usually a negative number. A more negative number meas more penalty for targets with more uncertain corners.
            'uncertainCornerMult': 'Float', # Float
            # Multiplier for the XY area of the AABB of the target. A higher value means favoring targets with greater XY area of their AABBs. The default value is 0.
            'xyAreaMult': 'Float', # Float
        },

        # Describes which target properties should be used for 2D pack formation caching. WARNING: if target hash matche, the pack formation will be used blindly and can cause not executable packs.
        'TemplateTargetHashPropertiesSchema': {
            # Set to true to use maxPalletLayerNumber of target for hash generation.
            'useMaxPalletLayerNumber': 'Boolean', # Boolean
            # Set to true to use objectPackingId of target for hash generation.
            'useObjectPackingId': 'Boolean', # Boolean
            # Set to true to use objectType of target for hash generation.
            'useObjectType': 'Boolean', # Boolean
            # Set to true to use part type of target for hash generation.
            'usePartType': 'Boolean', # Boolean
            # Set to true to use mass of target for hash generation.
            'useTargetMass': 'Boolean', # Boolean
            # Set to true to use X,Y,Z size of target for hash generation.
            'useTargetSize': 'Boolean', # Boolean
        },

        # Describes which target properties should be used for 2D pack formation caching. WARNING: if target hash matche, the pack formation will be used blindly and can cause not executable packs.
        'TemplateTargetHashPropertiesSchemaInput': {
            # Set to true to use maxPalletLayerNumber of target for hash generation.
            'useMaxPalletLayerNumber': 'Boolean', # Boolean
            # Set to true to use objectPackingId of target for hash generation.
            'useObjectPackingId': 'Boolean', # Boolean
            # Set to true to use objectType of target for hash generation.
            'useObjectType': 'Boolean', # Boolean
            # Set to true to use part type of target for hash generation.
            'usePartType': 'Boolean', # Boolean
            # Set to true to use mass of target for hash generation.
            'useTargetMass': 'Boolean', # Boolean
            # Set to true to use X,Y,Z size of target for hash generation.
            'useTargetSize': 'Boolean', # Boolean
        },

        # Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
        'Tool': {
            # The link at which the IK chain begins
            'baseLinkName': 'String', # String
            'chuckingDirections': 'Float', # [Float!]
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The direction in which the tool should approach an object (e.g. to grasp)
            'direction': 'Float', # [Float!]
            # The link in which the tool is defined
            'effectorLinkName': 'String', # String
            # The names of the joints in the gripper
            'gripperJointNames': 'String', # [String!]
            # The name of the gripper
            'grippername': 'String', # String
            # The ID of the tool. Unique within a body.
            'id': 'String', # String!
            # The link at which the IK solver ends
            'ikChainEndLinkName': 'String', # String
            # The type of Inverse Kinematics (IK) solver to use
            'ikSolverType': 'String', # String
            # The name of the tool. Unique within a body.
            'name': 'String', # String
            # Parent IDs, exposed to API but not saved internally.
            'parentIds': 'String', # [String!]!
            # Whether the data is in resolved mode, exposed to API but not saved internally.
            'resolveReferences': 'Boolean', # Boolean!
            # When this parameter is not empty, only grasp sets listed here are applicable for this manipulator.
            'restrictGraspSetNames': 'String', # [String!]
            # The tool name in each connected body to use when the connected body is activated by the tool changer.
            'toolChangerConnectedBodyToolName': 'String', # String
            # The link name that the connected bodies are attached to that belongs to this tool changer.
            'toolChangerLinkName': 'String', # String
            # The Transform from the Effector Link to the tool coordinate frame.
            'transform': 'Float', # [Float!]
        },

        # Tool describes a manipulator coordinate system of a robot. Other frameworks may use the term "TCP" or "tool tip".
        'ToolInput': {
            # The link at which the IK chain begins
            'baseLinkName': 'String', # String
            'chuckingDirections': 'Float', # [Float!]
            # For differential reference system, this flag indicates that the object specified by ID has been deleted.
            'deleted': 'Boolean', # Boolean
            # The direction in which the tool should approach an object (e.g. to grasp)
            'direction': 'Float', # [Float!]
            # The link in which the tool is defined
            'effectorLinkName': 'String', # String
            # The names of the joints in the gripper
            'gripperJointNames': 'String', # [String!]
            # The name of the gripper
            'grippername': 'String', # String
            # The ID of the tool. Unique within a body.
            'id': 'String', # String
            # The link at which the IK solver ends
            'ikChainEndLinkName': 'String', # String
            # The type of Inverse Kinematics (IK) solver to use
            'ikSolverType': 'String', # String
            # The name of the tool. Unique within a body.
            'name': 'String', # String
            # When this parameter is not empty, only grasp sets listed here are applicable for this manipulator.
            'restrictGraspSetNames': 'String', # [String!]
            # The tool name in each connected body to use when the connected body is activated by the tool changer.
            'toolChangerConnectedBodyToolName': 'String', # String
            # The link name that the connected bodies are attached to that belongs to this tool changer.
            'toolChangerLinkName': 'String', # String
            # The Transform from the Effector Link to the tool coordinate frame.
            'transform': 'Float', # [Float!]
        },

        # Allows specifying limits on the speed and acceleration of the manipulator.
        'ToolSpeedAccelInfo': {
            # mm/s^2, if != 0, then constrain the manipulator's max accel when not grabbing anything.
            'maxFreeManipAccel': 'Float', # Float
            # mm/s, if != 0, then constrain the manipulator's max speed when not grabbing anything.
            'maxFreeManipSpeed': 'Float', # Float
            # mm/s^2, if != 0, then constrain the manipulator's max accel when a target is grabbed.
            'maxGrabbingManipAccel': 'Float', # Float
            # mm/s, if != 0, then constrain the manipulator's max speed when a target is grabbed.
            'maxGrabbingManipSpeed': 'Float', # Float
            # Set to true to enable tool speed acceleration constraints.
            'use': 'Boolean', # Boolean
        },

        # Allows specifying limits on the speed and acceleration of the manipulator.
        'ToolSpeedAccelInfoInput': {
            # mm/s^2, if != 0, then constrain the manipulator's max accel when not grabbing anything.
            'maxFreeManipAccel': 'Float', # Float
            # mm/s, if != 0, then constrain the manipulator's max speed when not grabbing anything.
            'maxFreeManipSpeed': 'Float', # Float
            # mm/s^2, if != 0, then constrain the manipulator's max accel when a target is grabbed.
            'maxGrabbingManipAccel': 'Float', # Float
            # mm/s, if != 0, then constrain the manipulator's max speed when a target is grabbed.
            'maxGrabbingManipSpeed': 'Float', # Float
            # Set to true to enable tool speed acceleration constraints.
            'use': 'Boolean', # Boolean
        },

        # Array of the pair of transferSpeedMult and weight.
        'TransferSpeedMultPerWeight': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Specifies the number by which the transfer speed multiplied.
            'transferSpeedMult': 'Float', # Float
            # kg, Specifies part weight.
            'weight': 'Float', # Float
        },

        # Array of the pair of transferSpeedMult and weight.
        'TransferSpeedMultPerWeightInput': {
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Specifies the number by which the transfer speed multiplied.
            'transferSpeedMult': 'Float', # Float
            # kg, Specifies part weight.
            'weight': 'Float', # Float
        },

        # Sensor definition
        'TriggerDecelIOSensorDefinition': {
            # Specifies action taken by robot when sensor is activated.
            # - 'decel': for starting to decelerate when target is dropped. As soon as signal goes on, robot decelerates. Used in depalletizing on conveyors
            # - 'stop': for validating that a target has been dropped at the destination. As soon as signal goes on, robot drops the target. Used in depalletizing on conveyors.
            'action': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Names of the IK parameters which gives the direction of the sensor ray. Assuming +Z axis as the direction of the ray. should be in format of instobjectname/ikparamname. instobject for the ik param will be automatically included in region body names
            'ikparamNames': 'String', # [String]
            # Name of IO signal to use.
            'ioname': 'String', # String
            # If all, all rays defined by ikParamNames need to be occluded by robot or grabbed target. If any, any of rays need to be.
            'rayCheckMode': 'String', # String
        },

        # Sensor definition
        'TriggerDecelIOSensorDefinitionInput': {
            # Specifies action taken by robot when sensor is activated.
            # - 'decel': for starting to decelerate when target is dropped. As soon as signal goes on, robot decelerates. Used in depalletizing on conveyors
            # - 'stop': for validating that a target has been dropped at the destination. As soon as signal goes on, robot drops the target. Used in depalletizing on conveyors.
            'action': 'String', # String
            # For differential reference system, this flag indicates that the item specified by "id" has been deleted.
            'deleted': 'Boolean', # Boolean
            # The identifier for the item. Unique within the array.
            'id': 'String', # String
            # Names of the IK parameters which gives the direction of the sensor ray. Assuming +Z axis as the direction of the ray. should be in format of instobjectname/ikparamname. instobject for the ik param will be automatically included in region body names
            'ikparamNames': 'String', # [String]
            # Name of IO signal to use.
            'ioname': 'String', # String
            # If all, all rays defined by ikParamNames need to be occluded by robot or grabbed target. If any, any of rays need to be.
            'rayCheckMode': 'String', # String
        },

        # The unit used for a value (e.g. mm, cm, m, inches).
        'Unit': {
            # The name of the unit
            'unitName': 'String', # String!
            # The scaling factor to convert this unit to a basic SI unit. For mm, this is 0.001
            'unitScale': 'Float', # Float!
        },

        # The unit used for a value (e.g. mm, cm, m, inches).
        'UnitInput': {
            # The name of the unit
            'unitName': 'String', # String!
            # The scaling factor to convert this unit to a basic SI unit. For mm, this is 0.001
            'unitScale': 'Float', # Float!
        },

        # Optional unit selection.
        'UnitSelectionInput': {
            # Unit for angles, one of: deg, rad.
            'angleUnit': 'String', # String
            # Unit for length values, one of: m, meter, cm, mm, um, nm, inch.
            'lengthUnit': 'String', # String
            # Unit for mass values, one of: g, kg.
            'massUnit': 'String', # String
        },

        # The home position of the UI viewer virtual camera. Defines the view of the simulated system on startup.
        'UserCameraHome': {
            # Focus distance
            'distanceToFocus': 'Float', # Float
            # A 7-element vector representing a 6D pose. Consists of a wxyz quaternion and an xyz position.
            'pose': 'Float', # [Float]
        },

        # The home position of the UI viewer virtual camera. Defines the view of the simulated system on startup.
        'UserCameraHomeInput': {
            # Focus distance
            'distanceToFocus': 'Float', # Float
            # A 7-element vector representing a 6D pose. Consists of a wxyz quaternion and an xyz position.
            'pose': 'Float', # [Float]
        },

        # User information
        'UserInfo': {
            'firstName': 'String', # String
            'isAdmin': 'Boolean', # Boolean
            'lastLoginTime': 'Float', # Float
            'lastName': 'String', # String
            'password': 'String', # String
            # If the user can be removed by an administrator or not
            'removable': 'Boolean', # Boolean
            'userGroup': 'String', # String
            'username': 'String', # String
        },

        # User information
        'UserInfoInput': {
            'firstName': 'String', # String
            'isAdmin': 'Boolean', # Boolean
            'lastLoginTime': 'Float', # Float
            'lastName': 'String', # String
            'password': 'String', # String
            # If the user can be removed by an administrator or not
            'removable': 'Boolean', # Boolean
            'userGroup': 'String', # String
            'username': 'String', # String
        },

        # Configurable UI controls, do not affect how production system manager works
        'UserInterfaceOptions': {
            # Allow sending moveIn and moveOut command to conveyor when production cycle is paused. Otherwise conveyor will move only when production cycle is running
            'allowMoveLocationDuringPause': 'Boolean', # Boolean
            # If disabled, will prevent UI from Pausing production cycle by hiding specific UI elements.
            'allowPauseProductionCycle': 'Boolean', # Boolean
            # If disabled, the Error State Dialog in Error Recovery Page will not be able to be dismissed until resetError signal is received from plc
            'allowResetError': 'Boolean', # Boolean
            # If disabled, will prevent UI from Resuming production cycle by hidding specific UI elements.
            'allowResumeProductionCycle': 'Boolean', # Boolean
            # If disabled, will prevent UI from Starting production cycle by hidding specific UI elements.
            'allowStartProductionCycle': 'Boolean', # Boolean
            # If enabled, UI can switch scenario ID.
            'allowSwitchScenarioId': 'Boolean', # Boolean
            # If set, then allow drop off recovery in the production cycle state machine when a robot stops with a grabbing target. Otherwise, skip it and go directly to unchucking.
            'onRecoveryAllowDropOff': 'Boolean', # Boolean
            # If set, then have the user go home every time before being able to resume the production cycle.
            'onRecoveryForceMoveToHome': 'Boolean', # Boolean
            # If preparation cycle finishes with an finish code which is not in this list, pause production cycle.
            'preparationExpectedFinishCodes': 'String', # [String]
            # When dest location has no container ID, it either means there is no container for dest location, or dest location is a conveyor. Setting this to True will skip user input during recover when dest location container ID is empty
            'skipRecoverIfNoDestContainerId': 'Boolean', # Boolean
        },

        # Configurable UI controls, do not affect how production system manager works
        'UserInterfaceOptionsInput': {
            # Allow sending moveIn and moveOut command to conveyor when production cycle is paused. Otherwise conveyor will move only when production cycle is running
            'allowMoveLocationDuringPause': 'Boolean', # Boolean
            # If disabled, will prevent UI from Pausing production cycle by hiding specific UI elements.
            'allowPauseProductionCycle': 'Boolean', # Boolean
            # If disabled, the Error State Dialog in Error Recovery Page will not be able to be dismissed until resetError signal is received from plc
            'allowResetError': 'Boolean', # Boolean
            # If disabled, will prevent UI from Resuming production cycle by hidding specific UI elements.
            'allowResumeProductionCycle': 'Boolean', # Boolean
            # If disabled, will prevent UI from Starting production cycle by hidding specific UI elements.
            'allowStartProductionCycle': 'Boolean', # Boolean
            # If enabled, UI can switch scenario ID.
            'allowSwitchScenarioId': 'Boolean', # Boolean
            # If set, then allow drop off recovery in the production cycle state machine when a robot stops with a grabbing target. Otherwise, skip it and go directly to unchucking.
            'onRecoveryAllowDropOff': 'Boolean', # Boolean
            # If set, then have the user go home every time before being able to resume the production cycle.
            'onRecoveryForceMoveToHome': 'Boolean', # Boolean
            # If preparation cycle finishes with an finish code which is not in this list, pause production cycle.
            'preparationExpectedFinishCodes': 'String', # [String]
            # When dest location has no container ID, it either means there is no container for dest location, or dest location is a conveyor. Setting this to True will skip user input during recover when dest location container ID is empty
            'skipRecoverIfNoDestContainerId': 'Boolean', # Boolean
        },

        # Settings for Robot Jogging
        'UserRobotJogParameters': {
            # If True, environment collisions are checked during jogging.
            'jogCheckEnvCollision': 'Boolean', # Boolean
            # If True, self collision is enabled during jogging.
            'jogCheckSelfCollision': 'Boolean', # Boolean
            # If True, then jogging will maintain environment clearance, so that the robot cannot move closer to environment objects than the distance given in the Environment Clearance parameter.
            'jogEnvClearance': 'Boolean', # Boolean
            # If True, then joints 7-12 will be jogged. If False, then joints 1-6.
            'jogextended': 'Boolean', # Boolean
            # The type of jogging to perform (robot, joints or tool).
            'jogtype': 'String', # String
        },

        # Settings for Robot Jogging
        'UserRobotJogParametersInput': {
            # If True, environment collisions are checked during jogging.
            'jogCheckEnvCollision': 'Boolean', # Boolean
            # If True, self collision is enabled during jogging.
            'jogCheckSelfCollision': 'Boolean', # Boolean
            # If True, then jogging will maintain environment clearance, so that the robot cannot move closer to environment objects than the distance given in the Environment Clearance parameter.
            'jogEnvClearance': 'Boolean', # Boolean
            # If True, then joints 7-12 will be jogged. If False, then joints 1-6.
            'jogextended': 'Boolean', # Boolean
            # The type of jogging to perform (robot, joints or tool).
            'jogtype': 'String', # String
        },

        'VisionLoggingConfiguration': {
            # Log mode to be used in vision controller
            'logMode': 'String', # String
            # Number of log images to be kept
            'numberOfImages': 'Int', # Int
            # Enable logging or not
            'use': 'Boolean', # Boolean
        },

        'VisionLoggingConfigurationInput': {
            # Log mode to be used in vision controller
            'logMode': 'String', # String
            # Number of log images to be kept
            'numberOfImages': 'Int', # Int
            # Enable logging or not
            'use': 'Boolean', # Boolean
        },

        # Vision Manager Configurations
        'VisionManagerConfiguration': {
            # Project-Id-Version: PACKAGE VERSION
            # Report-Msgid-Bugs-To: 
            # PO-Revision-Date: 2015-07-17 11:57+0900
            # Last-Translator: Automatically generated
            # Language-Team: none
            # Language: en_US
            # MIME-Version: 1.0
            # Content-Type: text/plain; charset=UTF-8
            # Content-Transfer-Encoding: 8bit
            # Plural-Forms: nplurals=2; plural=(n != 1);
            'applicationType': 'String', # String
            'containerInspection': 'ContainerInspectionConfiguration', # ContainerInspectionConfiguration
            'defaultMaxCleanSizeXYZ': 'Float', # [Float]
            'defaultMinCleanSizeXYZ': 'Float', # [Float]
            'disableRegistration': 'Boolean', # Boolean
            'enableMeasureHeightFromVision': 'Boolean', # Boolean
            'enableMeasurePickedBoxesHeight': 'Boolean', # Boolean
            # 'Shadow Regions' are regions occluded by items in the container. See 'shadowRegionType' for details.
            'enableShadowRegion': 'Boolean', # Boolean
            'enableSnapPoseToOpenCorners': 'Boolean', # Boolean
            'filteringnumnn': 'Int', # Int
            'filteringstddev': 'Float', # Float
            'filteringsubsample': 'Int', # Int
            'logging': 'VisionLoggingConfiguration', # VisionLoggingConfiguration
            # The maximum candidate mass of parts. This is for auto-registration
            'maxCandidateMass': 'Float', # Float
            # The maximum candidate size of parts. This is for auto-registration
            'maxCandidateSize': 'Float', # [Float]
            'maxNumInObjectSet': 'Int', # Int
            'maxNumRegistrationDebugData': 'Int', # Int
            # The minimum candidate size of parts. This is for auto-registration
            'minCandidateSize': 'Float', # [Float]
            'minShadowRegion': 'Float', # Float
            'percentageOfMinObjectDimForCleanSize': 'Float', # Float
            'pointsize': 'Float', # Float
            'radiusfilteringminnn': 'Int', # Int
            'radiusfilteringradius': 'Float', # Float
            'returnObjectURI': 'Boolean', # Boolean
            'returnTopMVR': 'Boolean', # Boolean
            'shadowFarDist': 'Float', # Float
            # Thickness to be used for shadow region
            'shadowRegionThickness': 'Int', # Int
            # Choose which shadow region type to use for planning.
            # 
            # 'Shadow regions' are regions under detected objects which are occluded from the camera's view. They are treated as obstacles during planning, as undetected objects may be in them. Shadow regions can be estimated in multiple ways, with different advantages and disadvantages.
            # 
            # For example, 'cameraProjectedAABB' projects the axis-aligned bounding box of the object away from the camera (conservative, good for blocky objects, eye-in-hand cameras and wide containers). 'zProjectTrimesh' projects the object's mesh downward in z (good for objects where the AABB is too imprecise).
            'shadowRegionType': 'String', # String
            'useColorCameraForDetection': 'Boolean', # Boolean
            'visualizationfilteringnumnn': 'Int', # Int
            'visualizationfilteringstddev': 'Float', # Float
            'visualizationfilteringsubsample': 'Int', # Int
            'visualizationpointsize': 'Float', # Float
            'visualizationradiusfilteringminnn': 'Int', # Int
            'visualizationradiusfilteringradius': 'Float', # Float
        },

        # Vision Manager Configurations
        'VisionManagerConfigurationInput': {
            # Project-Id-Version: PACKAGE VERSION
            # Report-Msgid-Bugs-To: 
            # PO-Revision-Date: 2015-07-17 11:57+0900
            # Last-Translator: Automatically generated
            # Language-Team: none
            # Language: en_US
            # MIME-Version: 1.0
            # Content-Type: text/plain; charset=UTF-8
            # Content-Transfer-Encoding: 8bit
            # Plural-Forms: nplurals=2; plural=(n != 1);
            'applicationType': 'String', # String
            'containerInspection': 'ContainerInspectionConfigurationInput', # ContainerInspectionConfigurationInput
            'defaultMaxCleanSizeXYZ': 'Float', # [Float]
            'defaultMinCleanSizeXYZ': 'Float', # [Float]
            'disableRegistration': 'Boolean', # Boolean
            'enableMeasureHeightFromVision': 'Boolean', # Boolean
            'enableMeasurePickedBoxesHeight': 'Boolean', # Boolean
            # 'Shadow Regions' are regions occluded by items in the container. See 'shadowRegionType' for details.
            'enableShadowRegion': 'Boolean', # Boolean
            'enableSnapPoseToOpenCorners': 'Boolean', # Boolean
            'filteringnumnn': 'Int', # Int
            'filteringstddev': 'Float', # Float
            'filteringsubsample': 'Int', # Int
            'logging': 'VisionLoggingConfigurationInput', # VisionLoggingConfigurationInput
            # The maximum candidate mass of parts. This is for auto-registration
            'maxCandidateMass': 'Float', # Float
            # The maximum candidate size of parts. This is for auto-registration
            'maxCandidateSize': 'Float', # [Float]
            'maxNumInObjectSet': 'Int', # Int
            'maxNumRegistrationDebugData': 'Int', # Int
            # The minimum candidate size of parts. This is for auto-registration
            'minCandidateSize': 'Float', # [Float]
            'minShadowRegion': 'Float', # Float
            'percentageOfMinObjectDimForCleanSize': 'Float', # Float
            'pointsize': 'Float', # Float
            'radiusfilteringminnn': 'Int', # Int
            'radiusfilteringradius': 'Float', # Float
            'returnObjectURI': 'Boolean', # Boolean
            'returnTopMVR': 'Boolean', # Boolean
            'shadowFarDist': 'Float', # Float
            # Thickness to be used for shadow region
            'shadowRegionThickness': 'Int', # Int
            # Choose which shadow region type to use for planning.
            # 
            # 'Shadow regions' are regions under detected objects which are occluded from the camera's view. They are treated as obstacles during planning, as undetected objects may be in them. Shadow regions can be estimated in multiple ways, with different advantages and disadvantages.
            # 
            # For example, 'cameraProjectedAABB' projects the axis-aligned bounding box of the object away from the camera (conservative, good for blocky objects, eye-in-hand cameras and wide containers). 'zProjectTrimesh' projects the object's mesh downward in z (good for objects where the AABB is too imprecise).
            'shadowRegionType': 'String', # String
            'useColorCameraForDetection': 'Boolean', # Boolean
            'visualizationfilteringnumnn': 'Int', # Int
            'visualizationfilteringstddev': 'Float', # Float
            'visualizationfilteringsubsample': 'Int', # Int
            'visualizationpointsize': 'Float', # Float
            'visualizationradiusfilteringminnn': 'Int', # Int
            'visualizationradiusfilteringradius': 'Float', # Float
        },

        # Information on controlling ykk external devices
        'YKKControlInfo': {
            # mm, size of the one compartment to move the device
            'deviceCompartmentSize': 'Float', # Float
            # io names to move device by one compartment.
            'deviceMoveIO': 'String', # [String]
            # Signals which has to be set to reset device position.
            'devicePositionResetIO': 'String', # [String]
            # mm, if part is successfully clamped, the distance measurement should move at least this much.
            'distSensorPartClampedJigThreshold': 'Float', # Float
            # optional distance sensor that measures how far the jig has grasped the part, used to determine if part is grasped successfully or not. COM 2 port: URI = serial:///dev/ttyS1?baud=9600&bytesize=8&parity=N&stopbits=1&timeout=0.02&offset=600&type=keyenceIL1000
            'distSensorUri': 'String', # String
            # Initial position index to drive the jig at. If not set, then do not move the jig.
            'initialPosition': 'Int', # Int
            # io names to close jig.
            'jigCloseIO': 'String', # [String]
            # io names to open jig.
            'jigOpenIO': 'String', # [String]
            # total number of possible positions of the device
            'numDevicePositions': 'Int', # Int
            # s, time needed for device to close the jig and for the robot to depart. After this time the distance measurement will be made if defined 'useDistSensor' is True
            'timeToCloseJig': 'Float', # Float
            # s, time needed for device to move by one compartment
            'timeToMoveOneCompartment': 'Float', # Float
            # s, max time needed for device to open itself
            'timeToOpenJig': 'Float', # Float
            # If true, will use distance sensor measurements to measure the height of the jig.
            'useDistSensor': 'Boolean', # Boolean
        },

        # Information on controlling ykk external devices
        'YKKControlInfoInput': {
            # mm, size of the one compartment to move the device
            'deviceCompartmentSize': 'Float', # Float
            # io names to move device by one compartment.
            'deviceMoveIO': 'String', # [String]
            # Signals which has to be set to reset device position.
            'devicePositionResetIO': 'String', # [String]
            # mm, if part is successfully clamped, the distance measurement should move at least this much.
            'distSensorPartClampedJigThreshold': 'Float', # Float
            # optional distance sensor that measures how far the jig has grasped the part, used to determine if part is grasped successfully or not. COM 2 port: URI = serial:///dev/ttyS1?baud=9600&bytesize=8&parity=N&stopbits=1&timeout=0.02&offset=600&type=keyenceIL1000
            'distSensorUri': 'String', # String
            # Initial position index to drive the jig at. If not set, then do not move the jig.
            'initialPosition': 'Int', # Int
            # io names to close jig.
            'jigCloseIO': 'String', # [String]
            # io names to open jig.
            'jigOpenIO': 'String', # [String]
            # total number of possible positions of the device
            'numDevicePositions': 'Int', # Int
            # s, time needed for device to close the jig and for the robot to depart. After this time the distance measurement will be made if defined 'useDistSensor' is True
            'timeToCloseJig': 'Float', # Float
            # s, time needed for device to move by one compartment
            'timeToMoveOneCompartment': 'Float', # Float
            # s, max time needed for device to open itself
            'timeToOpenJig': 'Float', # Float
            # If true, will use distance sensor measurements to measure the height of the jig.
            'useDistSensor': 'Boolean', # Boolean
        },
    }

#
# DO NOT EDIT, THIS FILE WAS AUTO-GENERATED, SEE HEADER
#

